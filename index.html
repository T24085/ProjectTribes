<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tribes Professional League | Live Hub</title>
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" href="Tribes Professional League.png" type="image/png">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.10/dist/tailwind.min.css">
  <script src="oauth.js"></script>
  <style>
    :root {
      --bg-color: #030712;
      --bg-gradient: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 55%), radial-gradient(circle at 80% 30%, rgba(129, 140, 248, 0.12), transparent 60%), linear-gradient(220deg, rgba(15, 23, 42, 0.88), rgba(2, 6, 23, 0.94));
      --panel-bg: rgba(15, 23, 42, 0.82);
      --surface-glass: rgba(17, 24, 39, 0.65);
      --card-bg: rgba(13, 19, 33, 0.84);
      --text-primary: #e2e8f0;
      --text-muted: #94a3b8;
      --accent: #8b5cf6;
      --accent-strong: #38bdf8;
      --success: #22c55e;
      --danger: #f87171;
      --transition-snappy: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --shadow-xl: 0 32px 65px -25px rgba(46, 78, 155, 0.48);
    }
    *, *::before, *::after { box-sizing: border-box; }
    body > *:not(#support-effect-layer):not(#live-team-backdrop) {
      position: relative;
      z-index: 2;
    }
    body.has-live-backdrop {
      background: #030712;
    }
    #live-team-backdrop {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: stretch;
      justify-content: center;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      visibility: hidden;
      overflow: hidden;
      transition: opacity 0.45s ease;
    }
    #live-team-backdrop.is-visible {
      opacity: 1;
      visibility: visible;
    }
    #live-team-backdrop::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(15, 23, 42, 0.75), transparent 65%), radial-gradient(circle at 80% 30%, rgba(15, 23, 42, 0.65), transparent 60%), linear-gradient(220deg, rgba(2, 6, 23, 0.8), rgba(2, 6, 23, 0.7));
      pointer-events: none;
      z-index: 1;
    }
    .live-team-panel {
      flex: 1 1 0;
      min-width: 0;
      position: relative;
      background-position: center;
      background-repeat: repeat;
      background-size: clamp(12rem, 22vw, 26rem);
      filter: saturate(1.05);
    }
    .live-team-panel::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(3, 7, 18, 0.65), rgba(3, 7, 18, 0.35));
      pointer-events: none;
      z-index: 1;
    }
    #live-team-backdrop[data-count="1"] .live-team-panel {
      background-size: clamp(18rem, 32vw, 40rem);
    }
    #live-team-backdrop[data-count="2"] .live-team-panel {
      background-size: clamp(12rem, 24vw, 28rem);
    }
    #live-team-backdrop[data-count="3"] .live-team-panel {
      background-size: clamp(9rem, 18vw, 22rem);
    }
    #live-team-backdrop[data-count="4"] .live-team-panel {
      background-size: clamp(7rem, 14vw, 18rem);
    }
    body {
      margin: 0;

      min-height: 100vh;
      background: var(--bg-gradient), var(--bg-color);
      color: var(--text-primary);
      font-family: 'Inter', 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    a { color: inherit; text-decoration: none; }
    button { font: inherit; }
    nav#global-header {
      position: sticky;
      top: 0;
      z-index: 40;
      background: rgba(8, 11, 26, 0.85);
      border-bottom: 1px solid rgba(148, 163, 184, 0.16);
      backdrop-filter: blur(16px);
      padding: 0.95rem 2.25rem;
    }
    nav#global-header .header-shell { display:flex; align-items:center; justify-content: space-between; gap: 1.5rem; max-width: 1440px; margin: 0 auto; }
    .header-brand { display:flex; align-items:center; gap: 1rem; }
    .header-brand img { height: 46px; width:auto; border-radius: 0.75rem; background: rgba(30, 41, 59, 0.65); padding: 0.35rem 0.5rem; border: 1px solid rgba(148, 163, 184, 0.18); }
    .brand-title { margin: 0; font-size: 1.05rem; font-weight: 700; letter-spacing: 0.06em; text-transform: uppercase; }
    .brand-subtitle { margin: 0; font-size: 0.75rem; color: var(--text-muted); letter-spacing: 0.24em; text-transform: uppercase; }
    .header-actions { display:flex; align-items:center; gap: 0.8rem; flex-wrap: wrap; }
    .hero-link {
      border-radius: 9999px;
      padding: 0.55rem 1.15rem;
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.22);
      color: var(--text-primary);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      transition: background var(--transition-snappy), border-color var(--transition-snappy);
    }
    .hero-link:hover { background: rgba(129, 140, 248, 0.34); border-color: rgba(129, 140, 248, 0.52); }
    .auth-group { display:flex; align-items:center; gap: 0.65rem; }
    #twitch-user { font-size: 0.8rem; color: var(--text-muted); display: none; }
    .hero-cta {
      border: none;
      border-radius: 9999px;
      padding: 0.65rem 1.55rem;
      background: linear-gradient(135deg, rgba(129, 140, 248, 0.95), rgba(56, 189, 248, 0.95));
      color: #020617;
      font-size: 0.85rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      box-shadow: 0 16px 45px -18px rgba(56, 189, 248, 0.65);
      transition: transform 0.2s ease;
    }
    .hero-cta:hover { transform: translateY(-1px); }
    .live-teams-wrapper { position: relative; }
    #live-teams-panel {
      position: absolute;
      top: calc(100% + 0.75rem);
      right: 0;
      min-width: 240px;
      background: rgba(9, 13, 30, 0.92);
      border: 1px solid rgba(129, 140, 248, 0.3);
      border-radius: 0.9rem;
      box-shadow: var(--shadow-xl);
      padding: 0.75rem;
    }
    #live-teams-panel.hidden { display: none; }
    #live-teams-panel.visible { display: grid; gap: 0.5rem; }
    #live-teams-panel .live-box {
      display:flex;
      align-items:center;
      gap: 0.4rem;
      padding: 0.4rem 0.6rem;
      border-radius: 0.6rem;
      background: rgba(129, 140, 248, 0.12);
      font-size: 0.85rem;
    }
    #live-teams-panel .live-dot { color: #34d399; font-size: 0.8rem; }
    .live-announcement-banner {
      position: fixed;
      top: 0;
      left: 50%;
      transform: translate(-50%, -120%) scaleX(0.94);
      transform-origin: top center;
      padding: 0.6rem 1.75rem;
      background: linear-gradient(90deg, rgba(147, 51, 234, 0.95), rgba(59, 130, 246, 0.95));
      border: 1px solid rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(14px);
      color: #f8fafc;
      border-radius: 9999px;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      box-shadow: 0 22px 45px rgba(76, 29, 149, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.55s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.35s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.65rem;
      max-width: min(90vw, 44rem);
      text-align: center;
      z-index: 60;
    }
    .live-announcement-banner::after {
      content: '';
      position: absolute;
      inset: 1px;
      border-radius: inherit;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0));
      opacity: 0;
      transition: opacity 0.35s ease;
      animation: banner-sheen 3.5s linear infinite;
      pointer-events: none;
    }
    .live-announcement-banner span { position: relative; z-index: 1; white-space: nowrap; }
    .live-announcement-banner strong { color: #fff; }
    .live-announcement-banner .banner-icon { position: relative; z-index: 1; display: inline-flex; width: 1.15rem; height: 1.15rem; }
    .live-announcement-banner .banner-icon svg { width: 100%; height: 100%; }
    .live-announcement-banner.is-visible { opacity: 1; transform: translate(-50%, 0) scaleX(1); }
    .live-announcement-banner.is-visible::after { opacity: 1; }
    @keyframes banner-sheen {
      0% { transform: translateX(-100%); opacity: 0; }
      30% { opacity: 0.45; }
      70% { opacity: 0.15; }
      100% { transform: translateX(100%); opacity: 0; }
    }
    @media (max-width: 640px) {
      .live-announcement-banner {
        font-size: 0.85rem;
        padding: 0.55rem 1.25rem;
        gap: 0.5rem;
      }
      .live-announcement-banner span { white-space: normal; }
    }
    main {
      max-width: 1440px;
      margin: 0 auto;
      padding: 1.75rem 2rem 4rem;
      display: flex;
      flex-direction: column;
      gap: 2.5rem;
    }
    .hero {
      display: grid;
      grid-template-columns: minmax(0, 1.25fr) minmax(0, 1fr);
      gap: 2rem;
      align-items: stretch;
      margin-top: 0.5rem;
    }
    .hero-card {
      background: var(--surface-glass);
      border-radius: 1.35rem;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: 0 24px 60px -28px rgba(14, 116, 144, 0.45);
      padding: 1.85rem;
      display: flex;
      flex-direction: column;
      gap: 1.35rem;
      position: relative;
      overflow: hidden;
    }
    .hero-card::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.18), transparent 60%);
      pointer-events: none;
    }
    .hero-card h1 {
      margin: 0;
      font-size: clamp(2rem, 3vw, 2.8rem);
      letter-spacing: -0.02em;
      z-index: 1;
    }
    .hero-card p {
      margin: 0;
      color: var(--text-muted);
      font-size: 1rem;
      line-height: 1.65;
      z-index: 1;
    }
    .hero-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.8rem;
      z-index: 1;
    }
    .hero-metrics .metric {
      background: rgba(15, 23, 42, 0.58);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 1rem;
      padding: 1rem;
    }
    .hero-metrics .metric span {
      display: block;
      font-size: 0.72rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-muted);
    }
    .hero-metrics .metric strong {
      display: block;
      margin-top: 0.3rem;
      font-size: 1.55rem;
      font-weight: 700;
    }
    .hero-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      z-index: 1;
    }
    .hero-actions button {
      border-radius: 9999px;
      padding: 0.65rem 1.2rem;
      border: 1px solid rgba(129, 140, 248, 0.45);
      background: rgba(15, 23, 42, 0.65);
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background var(--transition-snappy), border-color var(--transition-snappy);
    }
    .hero-actions button:hover { background: rgba(79, 70, 229, 0.45); border-color: rgba(129, 140, 248, 0.7); }
    .support-card {
      background: linear-gradient(135deg, rgba(17, 24, 39, 0.9), rgba(24, 24, 110, 0.65));
      border-radius: 1.35rem;
      border: 1px solid rgba(99, 102, 241, 0.28);
      padding: 1.85rem;
      box-shadow: 0 24px 65px -30px rgba(56, 189, 248, 0.52);
      display: flex;
      flex-direction: column;
      gap: 1.35rem;
      position: relative;
      overflow: hidden;
    }
    .support-card::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 15% 25%, rgba(139, 92, 246, 0.22), transparent 60%);
      pointer-events: none;
    }
    .support-card h2 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: -0.01em;
      z-index: 1;
    }
    .support-card p { margin: 0; color: rgba(226, 232, 240, 0.82); line-height: 1.6; z-index: 1; }
    .support-actions { display: flex; flex-direction: column; gap: 0.75rem; z-index: 1; }
    .support-actions button,
    .support-actions a {
      border-radius: 9999px;
      padding: 0.72rem 1.2rem;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      border: 1px solid rgba(255, 255, 255, 0.22);
      color: #e2e8f0;
      background: rgba(15, 23, 42, 0.55);
      cursor: pointer;
      text-align: center;
      transition: background var(--transition-snappy), border-color var(--transition-snappy);
    }
    .support-actions button.primary {
      background: linear-gradient(135deg, rgba(129, 140, 248, 0.95), rgba(56, 189, 248, 0.95));
      border: none;
      color: #020617;
      font-weight: 700;
    }
    .support-actions button.secondary:hover,
    .support-actions a:hover {
      background: rgba(79, 70, 229, 0.4);
      border-color: rgba(148, 163, 184, 0.4);
    }
    .support-note {
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      z-index: 1;
    }
    .support-note code {
      background: rgba(15, 23, 42, 0.65);
      padding: 0.1rem 0.4rem;
      border-radius: 0.4rem;
      font-size: 0.75rem;
      color: #e2e8f0;
    }
    .control-streams {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    .control-panel {
      background: rgba(15, 23, 42, 0.72);
      border-radius: 1.25rem;
      border: 1px solid rgba(148, 163, 184, 0.18);
      padding: 1.1rem 1.5rem;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 1rem 1.25rem;
      position: relative;
      top: auto;
      width: 100%;
      box-shadow: 0 18px 40px -28px rgba(15, 23, 42, 0.75);
    }
    .control-panel header {
      flex: 1 1 100%;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .control-panel header h3 {
      margin: 0;
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: rgba(226, 232, 240, 0.7);
    }
    .control-panel header p { display: none; }
    .control-panel form {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex: 1 1 280px;
      min-width: 260px;
    }
    .control-panel label { display: none; }
    .control-panel .input-row { display: flex; gap: 0.75rem; flex: 1; }
    .control-panel input[type="text"] {
      flex: 1;
      padding: 0.65rem 0.85rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(148, 163, 184, 0.24);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text-primary);
    }
    .control-panel button.submit {
      border-radius: 0.85rem;
      border: none;
      padding: 0.65rem 1.15rem;
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.9), rgba(99, 102, 241, 0.9));
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.75rem;
      font-weight: 600;
      color: #f8fafc;
      cursor: pointer;
    }
    .control-panel .inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }
    .control-panel .inline-actions button {
      border-radius: 9999px;
      padding: 0.45rem 0.95rem;
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-primary);
      font-size: 0.72rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
    }
    .control-panel .inline-actions button:hover {
      background: rgba(129, 140, 248, 0.32);
      border-color: rgba(129, 140, 248, 0.42);
    }
    .channel-manager {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-height: 380px;
      overflow-y: auto;
      padding-right: 0.3rem;
    }
    .channel-row {
      background: rgba(148, 163, 184, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 1rem;
      padding: 0.85rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }
    .channel-row__top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }
    .channel-row__meta { display: flex; flex-direction: column; gap: 0.1rem; }
    .channel-row__name { font-weight: 600; letter-spacing: -0.01em; }
    .channel-row__handle { font-size: 0.75rem; color: var(--text-muted); }
    .channel-row__team { font-size: 0.7rem; color: rgba(129, 140, 248, 0.75); text-transform: uppercase; letter-spacing: 0.12em; }
    .channel-row__badges { display: flex; gap: 0.35rem; flex-wrap: wrap; }
    .channel-row__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .pill-btn {
      border: none;
      border-radius: 9999px;
      padding: 0.35rem 0.9rem;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      background: rgba(79, 70, 229, 0.22);
      color: #e0e7ff;
      cursor: pointer;
      transition: background var(--transition-snappy);
    }
    .pill-btn:hover { background: rgba(99, 102, 241, 0.4); }
    .pill-btn.danger { background: rgba(248, 113, 113, 0.22); color: #fecaca; }
    .pill-btn.secondary { background: rgba(148, 163, 184, 0.15); color: #cbd5f5; }
    .badge {
      font-size: 0.68rem;
      padding: 0.2rem 0.55rem;
      border-radius: 9999px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .badge-live { background: rgba(34, 197, 94, 0.22); color: #bbf7d0; }
    .badge-muted { background: rgba(248, 113, 113, 0.2); color: #fecaca; }
    .streams-area { display: flex; flex-direction: column; gap: 1.35rem; }
    .section-head { display: flex; flex-direction: column; gap: 0.4rem; }
    .section-head h2 { margin: 0; font-size: 1.6rem; letter-spacing: -0.01em; }
    .section-head p { margin: 0; color: var(--text-muted); font-size: 0.95rem; }
    #live-channel-banner {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
    }
    #live-channel-banner .live-box {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(129, 140, 248, 0.14);
      border-radius: 9999px;
      padding: 0.35rem 0.85rem;
      font-size: 0.8rem;
    }
    #live-channel-banner .live-dot { color: var(--success); font-size: 0.8rem; }
    #live-channel-banner .live-name { font-weight: 600; letter-spacing: -0.01em; color: var(--text-primary); }
    #live-channel-banner .viewers { color: rgba(226, 232, 240, 0.65); font-size: 0.7rem; letter-spacing: 0.08em; text-transform: uppercase; }
    #stream-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 1.35rem;
    }
    .stream-card {
      position: relative;
      background: var(--card-bg);
      border-radius: 1.25rem;
      padding: 1.25rem;
      border: 1px solid rgba(99, 102, 241, 0.28);
      overflow: hidden;
      box-shadow: 0 24px 45px -30px rgba(59, 130, 246, 0.45);
      transition: transform var(--transition-snappy), box-shadow var(--transition-snappy);
    }
    .stream-card::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(56, 189, 248, 0.9));
      opacity: 0;
      transition: opacity var(--transition-snappy);
      z-index: 0;
    }
    .stream-card:hover { transform: translateY(-4px); box-shadow: 0 32px 70px -32px rgba(99, 102, 241, 0.6); }
    .stream-card:hover::before { opacity: 0.6; }
    .stream-card__head {
      position: relative;
      z-index: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.8rem;
    }
    .stream-card__identity { display: flex; align-items: center; gap: 0.9rem; cursor: pointer; }
    .stream-card__avatar {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      overflow: hidden;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    .stream-card__avatar img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .stream-card__name { font-size: 1.1rem; font-weight: 600; letter-spacing: -0.01em; }
    .stream-card__team { font-size: 0.78rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.12em; margin-top: 0.25rem; }
    .stream-card__status { display: flex; align-items: center; gap: 0.6rem; }
    .live-pill, .offline-pill {
      border-radius: 9999px;
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
    }
    .live-pill { background: rgba(34, 197, 94, 0.18); color: #bbf7d0; }
    .offline-pill { background: rgba(148, 163, 184, 0.16); color: rgba(148, 163, 184, 0.9); }
    .stream-card__player {
      position: relative;
      z-index: 1;
      border-radius: 1rem;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.16);
      background: #000;
    }
    .player-frame { position: relative; width: 100%; aspect-ratio: 16 / 9; min-height: 300px; }
    .player-frame iframe { position: absolute; inset: 0; width: 100%; height: 100%; border: none; }
    @supports not (aspect-ratio: 16 / 9) {
      .player-frame {
        padding-top: 56.25%;
      }
      .player-frame iframe {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        border: none;
      }
    }
    .stream-card__actions {
      position: relative;
      z-index: 1;
      margin-top: 1.05rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .card-action {
      flex: 1 1 130px;
      border-radius: 9999px;
      padding: 0.55rem 1.1rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.55);
      color: var(--text-primary);
      text-align: center;
      font-size: 0.82rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: background var(--transition-snappy), border-color var(--transition-snappy);
    }
    .card-action:hover { background: rgba(79, 70, 229, 0.4); border-color: rgba(129, 140, 248, 0.6); }
    .card-action.support {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.8), rgba(56, 189, 248, 0.85));
      border: none;
      color: #020617;
    }
    .card-action.link { display: flex; align-items: center; justify-content: center; text-decoration: none; }
    .stream-card__extras {
      position: relative;
      z-index: 1;
      margin-top: 1rem;
      display: none;
      flex-direction: column;
      gap: 0.75rem;
    }
    .stream-card__extras.is-visible { display: flex; }
    .stream-card__extras > div {
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.16);
      background: rgba(15, 23, 42, 0.7);
      padding: 0.95rem;
    }
    .stream-card__stats .stats-body {
      padding: 0;
      overflow: visible;
    }
    .stream-card__stats .stats-summary .stat {
      background: rgba(15, 23, 42, 0.6);
    }
    .stream-card__placeholder {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-muted);
      text-align: center;
    }
    .stream-card__chat iframe {
      width: 100%;
      height: 380px;
      border: none;
      border-radius: 0.85rem;
      background: #0b1220;
    }
    .empty-state {
      text-align: center;
      padding: 2.5rem 1rem;
      background: rgba(148, 163, 184, 0.08);
      border: 1px dashed rgba(148, 163, 184, 0.22);
      border-radius: 1.25rem;
      color: var(--text-muted);
    }
    .empty-state button {
      margin-top: 1rem;
      border-radius: 9999px;
      padding: 0.55rem 1.2rem;
      border: none;
      background: rgba(99, 102, 241, 0.4);
      color: #e0e7ff;
      cursor: pointer;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
      top: 0;
      right: 0;
      padding: 1rem;
    }
    .stats-body {
      padding: 1.5rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1.35rem;
    }
    .stats-body .meta {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .stats-body .meta img {
      width: 72px;
      height: 72px;
      border-radius: 18px;
      object-fit: cover;
      border: 2px solid rgba(129, 140, 248, 0.42);
    }
    .stats-body .meta .details { flex: 1; }
    .stats-body .meta .details p { margin: 0.2rem 0; color: var(--text-muted); font-size: 0.9rem; }
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 0.8rem;
    }
    .stats-summary .stat {
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 0.85rem;
      padding: 0.85rem;
      text-align: center;
    }
    .stats-summary .stat .label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-muted);
    }
    .stats-summary .stat .value {
      margin-top: 0.35rem;
      font-size: 1.25rem;
      font-weight: 600;
    }
    .stats-body .bio {
      font-size: 0.9rem;
      line-height: 1.55;
      color: var(--text-muted);
    }
    .stats-body .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .stats-body .cta-row a,
    .stats-body .cta-row button {
      border-radius: 9999px;
      padding: 0.6rem 1.1rem;
      border: 1px solid rgba(129, 140, 248, 0.3);
      background: rgba(15, 23, 42, 0.75);
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background var(--transition-snappy);
    }
    .stats-body .cta-row a:hover,
    .stats-body .cta-row button:hover {
      background: rgba(79, 70, 229, 0.4);
    }
    #support-effect-layer { position: fixed; inset: 0; pointer-events: none; z-index: 90; overflow: hidden; }
    #support-effect-layer .support-spark {
      position: absolute;
      width: 0.6rem;
      height: 0.6rem;
      border-radius: 50%;
      opacity: 0;
      animation: spark-pop 1.8s ease-out forwards;
    }
    @keyframes spark-pop {
      0% { transform: translate3d(0, 0, 0) scale(0.4); opacity: 1; }
      60% { opacity: 1; }
      100% { transform: translate3d(var(--spark-x), -110vh, 0) scale(0.9) rotate(720deg); opacity: 0; }
    }
    .toast {
      position: fixed;
      left: 50%;
      bottom: 1.4rem;
      transform: translateX(-50%) translateY(20px);
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.4);
      color: #e2e8f0;
      padding: 0.65rem 1.1rem;
      border-radius: 9999px;
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease, transform 0.25s ease;
      z-index: 95;
    }
    .toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
    .is-hidden { display: none !important; }
    .match-poll {
      max-width: 1120px;
      margin: 2.5rem auto 3rem;
      padding: 0 clamp(1rem, 4vw, 1.75rem);
    }
    .match-poll__card {
      position: relative;
      border-radius: 1.5rem;
      padding: clamp(1.75rem, 3vw, 2.4rem);
      background: linear-gradient(160deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.82));
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: 0 35px 80px -45px rgba(56, 189, 248, 0.45);
      overflow: hidden;
      backdrop-filter: blur(18px);
    }
    .match-poll__card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 12% -10%, rgba(129, 140, 248, 0.35), transparent 55%), radial-gradient(circle at 85% 0%, rgba(236, 72, 153, 0.28), transparent 60%);
      opacity: 0.35;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .match-poll__body { position: relative; z-index: 1; display: grid; gap: 1.5rem; }
    .match-poll__header { display: flex; flex-direction: column; gap: 0.5rem; }
    .match-poll__heading { display: flex; flex-direction: column; gap: 0.35rem; }
    .match-poll__eyebrow {
      font-size: 0.75rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.68);
      margin: 0;
    }
    .match-poll__title {
      margin: 0;
      font-size: clamp(1.7rem, 3vw, 2.15rem);
      font-weight: 700;
      letter-spacing: -0.01em;
    }
    .match-poll__subhead {
      margin: 0;
      color: rgba(226, 232, 240, 0.72);
      font-size: 0.9rem;
      line-height: 1.45;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      min-height: 3rem;
    }
    .match-poll__subhead > * {
      flex: 1 1 auto;
    }
    .match-poll__meta,
    .match-poll__status {
      margin: 0;
      color: rgba(226, 232, 240, 0.72);
      font-size: 0.9rem;
      line-height: 1.45;
    }
    .match-poll__status { font-weight: 600; letter-spacing: 0.04em; text-transform: uppercase; color: rgba(148, 163, 184, 0.9); }
    .match-poll__subhead-text {
      display: inline-block;
    }
    .vs-image {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      max-width: 100%;
    }
    .vs-image img {
      display: block;
      max-width: min(100%, 420px);
      height: auto;
      filter: drop-shadow(0 24px 36px -20px rgba(15, 23, 42, 0.65));
    }
    .vs-image[data-state="text"] {
      width: 100%;
    }
    .vs-image__fallback {
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.82);
    }
    .match-poll__subhead .vs-image {
      justify-content: flex-start;
    }
    .match-poll__subhead .vs-image__fallback {
      color: rgba(226, 232, 240, 0.72);
      font-size: 0.9rem;
      letter-spacing: 0.04em;
      line-height: 1.45;
    }
    .match-poll__content { display: grid; gap: 1.25rem; }
    .match-poll__loading {
      display: grid;
      gap: 0.75rem;
    }
    .match-poll__loading > span {
      display: block;
      height: 16px;
      border-radius: 999px;
      background: linear-gradient(100deg, rgba(148, 163, 184, 0.08) 0%, rgba(148, 163, 184, 0.3) 50%, rgba(148, 163, 184, 0.08) 100%);
      background-size: 200% 100%;
      animation: poll-shimmer 1.8s ease-in-out infinite;
    }
    .match-poll__loading > span:nth-child(1) { width: 40%; }
    .match-poll__loading > span:nth-child(2),
    .match-poll__loading > span:nth-child(3) { height: 48px; border-radius: 1rem; }
    @keyframes poll-shimmer {
      0% { background-position: 200% 0; opacity: 0.4; }
      50% { opacity: 0.9; }
      100% { background-position: -200% 0; opacity: 0.4; }
    }
    .match-poll__options {
      display: grid;
      gap: 0.9rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      transition: opacity var(--transition-snappy);
    }
    .match-poll__options.is-disabled { opacity: 0.5; pointer-events: none; }
    .match-poll__option {
      position: relative;
      border-radius: 1.2rem;
      border: 1px solid rgba(99, 102, 241, 0.22);
      background: rgba(15, 23, 42, 0.72);
      padding: 1.05rem 1.1rem 1.05rem 1.25rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: transform var(--transition-snappy), border-color var(--transition-snappy), background var(--transition-snappy), box-shadow var(--transition-snappy);
    }
    .match-poll__option:hover { transform: translateY(-2px); border-color: rgba(129, 140, 248, 0.5); box-shadow: 0 25px 45px -30px rgba(99, 102, 241, 0.55); }
    .match-poll__option.is-selected {
      border-color: rgba(56, 189, 248, 0.85);
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.22), rgba(99, 102, 241, 0.22));
      box-shadow: 0 30px 55px -38px rgba(56, 189, 248, 0.75);
    }
    .match-poll__option.is-selected[data-team="B"] {
      border-color: rgba(236, 72, 153, 0.9);
      background: linear-gradient(135deg, rgba(244, 114, 182, 0.22), rgba(236, 72, 153, 0.18));
      box-shadow: 0 30px 55px -38px rgba(244, 114, 182, 0.75);
    }
    .match-poll__option-label { display: flex; flex-direction: column; gap: 0.25rem; }
    .match-poll__option-label span:first-child {
      font-size: 0.7rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.72);
    }
    .match-poll__option-label strong { font-size: 1.05rem; font-weight: 700; letter-spacing: -0.01em; }
    .match-poll__option-count { font-size: 0.85rem; font-weight: 600; color: rgba(226, 232, 240, 0.78); white-space: nowrap; }
    .match-poll__progress { display: grid; gap: 0.9rem; }
    .match-poll__progress-row { display: grid; gap: 0.45rem; }
    .match-poll__progress-meta { display: flex; justify-content: space-between; font-size: 0.7rem; letter-spacing: 0.2em; text-transform: uppercase; color: rgba(148, 163, 184, 0.7); }
    .match-poll__progress-track {
      position: relative;
      height: 10px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(15, 23, 42, 0.78);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }
    .match-poll__progress-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      border-radius: inherit;
      transition: width 0.45s ease;
    }
    .match-poll__progress-fill[data-team="A"] { background: linear-gradient(135deg, rgba(99, 102, 241, 0.9), rgba(56, 189, 248, 0.85)); }
    .match-poll__progress-fill[data-team="B"] { background: linear-gradient(135deg, rgba(236, 72, 153, 0.9), rgba(244, 114, 182, 0.85)); }
    .match-poll__empty,
    .match-poll__error { font-size: 0.85rem; margin: 0; }
    .match-poll__empty { color: rgba(148, 163, 184, 0.82); }
    .match-poll__error { color: rgba(248, 113, 113, 0.9); }
    .match-poll__login {
      border-radius: 1.1rem;
      border: 1px dashed rgba(148, 163, 184, 0.26);
      background: rgba(15, 23, 42, 0.6);
      padding: 1.1rem 1.25rem;
      display: grid;
      gap: 0.65rem;
    }
    .match-poll__login p { margin: 0; font-size: 0.9rem; color: rgba(226, 232, 240, 0.8); }
    .match-poll__login button {
      justify-self: flex-start;
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.45rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: linear-gradient(135deg, rgba(129, 140, 248, 0.95), rgba(56, 189, 248, 0.95));
      color: #020617;
      cursor: pointer;
      transition: transform 0.2s ease;
      box-shadow: 0 18px 40px -25px rgba(56, 189, 248, 0.8);
    }
    .match-poll__login button:hover { transform: translateY(-1px); }
    .match-poll__footer { display: flex; flex-direction: column; gap: 0.6rem; }
    @media (max-width: 1280px) {
      .hero { grid-template-columns: 1fr; }
      .control-streams { grid-template-columns: 1fr; }
      nav#global-header { padding: 0.85rem 1.5rem; }
    }
    @media (max-width: 1024px) {
      .control-panel { position: static; }
      main { padding: 1.5rem 1.35rem 4rem; }
      .match-poll { margin: 2rem auto 2.75rem; }
    }
    @media (max-width: 860px) {
      nav#global-header .header-shell { flex-direction: column; align-items: flex-start; }
      .header-actions { width: 100%; justify-content: space-between; }
      #stream-grid { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    }
    @media (max-width: 640px) {
      .hero-actions button { flex: 1 1 45%; text-align: center; }
      .control-panel { padding: 1.2rem; }
      nav#global-header { padding: 0.75rem 1rem; }
      main { padding: 1.2rem 1rem 4rem; }
      .match-poll { padding: 0 0.85rem; }
      .match-poll__option { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
      .match-poll__option-count { align-self: flex-start; }
    }
  </style>
</head>
<body>
  <div id="support-effect-layer"></div>
  <div id="live-team-backdrop"></div>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <div id="live-announcement-banner" class="live-announcement-banner" aria-live="polite" role="status"></div>
  <nav id="global-header">
    <div class="header-shell">
      <div class="header-brand">
        <img src="Tribes Professional League.png" alt="Tribes Professional League logo" onerror="this.style.display='none'">
        <div>
          <p class="brand-title">Tribes Professional League</p>
          <p class="brand-subtitle">Live Hub</p>
        </div>
      </div>
      <div class="header-actions">
        <button type="button" class="hero-link" data-role="live-only-toggle">Show Only Live</button>
        <div class="live-teams-wrapper">
          <button type="button" id="live-teams-toggle" class="hero-link">Team Streams</button>
          <div id="live-teams-panel" class="hidden"></div>
        </div>
        <div class="auth-group">
          <span id="twitch-user"></span>
          <button type="button" id="twitch-login-btn" class="hero-cta">Sign in with Twitch</button>
        </div>
      </div>
    </div>
  </nav>
  <main>
    <section class="match-poll" data-role="match-poll" data-match-id="current">
      <div class="match-poll__card" id="match-poll-card">
        <div class="match-poll__body">
          <header class="match-poll__header">
            <div class="match-poll__heading">
              <p class="match-poll__eyebrow">Featured Match</p>

              <h2 class="match-poll__title">Who will win?</h2>
              <div class="match-poll__subhead" id="match-poll-subhead">
                <span class="match-poll__subhead-text">Loading featured matchup…</span>
              </div>

              <p class="match-poll__meta is-hidden" id="match-poll-meta"></p>
            </div>
            <p class="match-poll__status" id="match-poll-status">Loading votes…</p>
          </header>
          <div class="match-poll__loading" id="match-poll-loading">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div class="match-poll__content is-hidden" id="match-poll-content">
            <div class="match-poll__login" id="match-poll-login">
              <p>Log in with Twitch to choose your winner.</p>
              <button type="button" id="match-poll-login-btn">Sign in to vote</button>
            </div>
            <div class="match-poll__options" id="match-poll-options">
              <button type="button" class="match-poll__option" id="match-poll-option-a" data-team="A">
                <span class="match-poll__option-label">
                  <span>Team A</span>
                  <strong id="match-poll-team-a-name">Team A</strong>
                </span>
                <span class="match-poll__option-count" id="match-poll-team-a-count">0 votes</span>
              </button>
              <button type="button" class="match-poll__option" id="match-poll-option-b" data-team="B">
                <span class="match-poll__option-label">
                  <span>Team B</span>
                  <strong id="match-poll-team-b-name">Team B</strong>
                </span>
                <span class="match-poll__option-count" id="match-poll-team-b-count">0 votes</span>
              </button>
            </div>
            <div class="match-poll__progress">
              <div class="match-poll__progress-row">
                <div class="match-poll__progress-meta">
                  <span id="match-poll-team-a-label">Team A</span>
                  <span id="match-poll-team-a-percent">0%</span>
                </div>
                <div class="match-poll__progress-track">
                  <div class="match-poll__progress-fill" data-team="A" id="match-poll-team-a-bar"></div>
                </div>
              </div>
              <div class="match-poll__progress-row">
                <div class="match-poll__progress-meta">
                  <span id="match-poll-team-b-label">Team B</span>
                  <span id="match-poll-team-b-percent">0%</span>
                </div>
                <div class="match-poll__progress-track">
                  <div class="match-poll__progress-fill" data-team="B" id="match-poll-team-b-bar"></div>
                </div>
              </div>
            </div>
            <div class="match-poll__footer">
              <p class="match-poll__empty is-hidden" id="match-poll-empty">No votes yet — be the first to choose a winner!</p>
              <p class="match-poll__error is-hidden" id="match-poll-error"></p>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section class="hero">
      <article class="hero-card">
        <h1>All Your Tribes Streams, One Wall.</h1>
        <p>Build a watch party that rivals Twitch itself. Track every roster, stack chats, and surface stats without leaving this page.</p>
        <div class="hero-metrics">
          <div class="metric">
            <span>Total Streams</span>
            <strong id="metric-total-streams">0</strong>
          </div>
          <div class="metric">
            <span>Live Right Now</span>
            <strong id="metric-live-streams">0</strong>
          </div>
          <div class="metric">
            <span>Hidden Slots</span>
            <strong id="metric-hidden-streams">0</strong>
          </div>
        </div>
        <div class="hero-actions">
          <button type="button" id="open-add-streamer">Add Streamer</button>
          <button type="button" id="open-manager">Manage List</button>
          <button type="button" id="scroll-to-grid">Jump to Streams</button>
        </div>
      </article>
      <article class="support-card" id="support-card">
        <h2>Boost the League</h2>
        <p>Cheer on the players, unlock page-wide hype effects, and keep the Tribes Professional League thriving.</p>
        <div class="support-actions">
          <button type="button" class="primary" data-support-type="bits" data-channel="tribesprofessionalleague">Send Bits to the League</button>
          <a href="https://www.paypal.com/ncp/payment/BC4EF2QC9T5GA" target="_blank" rel="noopener" data-support-type="paypal" data-url="https://www.paypal.com/ncp/payment/BC4EF2QC9T5GA">Donate via PayPal</a>
          <button type="button" class="secondary" data-support-type="effect" data-effect="donation">I Just Supported!</button>
        </div>
        <p class="support-note">Wire up your alert system to call <code>SupportEffects.trigger()</code> for automated hype.</p>
      </article>
    </section>

    <section class="control-streams">
      <aside class="control-panel" id="control-panel">
        <header>
          <h3>Stream List</h3>
          <p>Add, hide, or reorder the channels that render in the wall.</p>
        </header>
        <form id="add-channel-form">
          <label for="add-channel-input">Add a Twitch channel</label>
          <div class="input-row">
            <input type="text" id="add-channel-input" placeholder="twitch handle" autocomplete="off">
            <button type="submit" class="submit">Add</button>
          </div>
        </form>
        <div class="inline-actions">
          <button type="button" data-role="live-only-toggle">Show Only Live</button>
          <button type="button" id="show-all-streams">Show All</button>
          <button type="button" id="reset-defaults">Reset to League Defaults</button>
        </div>
        <div class="channel-manager" id="channel-manager"></div>
      </aside>

      <div class="streams-area" id="streams-area">
        <div class="section-head">
          <h2>Multi-Stream Wall</h2>
          <p>Spot every base, every chase, every clutch — live and archived.</p>
        </div>
        <div id="live-channel-banner"></div>
        <div id="stream-grid"></div>
      </div>
    </section>
  </main>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";

    import { getFirestore, collection, getDocs, query, where, doc, getDoc, onSnapshot, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { createVsImage } from "./src/components/VsImage.js";


    const firebaseConfig = {
      apiKey: "AIzaSyB_ksHlcP2P9cT5jbo2IAGxbQ4zgEODkyM",
      authDomain: "team-sign-up-b5646.firebaseapp.com",
      projectId: "team-sign-up-b5646",
      storageBucket: "team-sign-up-b5646.firebasestorage.app",
      messagingSenderId: "951471144681",
      appId: "1:951471144681:web:a2458675ce73ce9ad9ba78"
    };

    const firebaseApp = initializeApp(firebaseConfig);
    const db = getFirestore(firebaseApp);

    const defaultChannels = [
      "2xevil","apcizzle","bakatoma1","beldarkk","blu2th1000","bschrift","cheezecaek","cloutac","cryofzshooter","dreadtitan","eltimablo",
      "eviskz0rr","freefoodd","ggglygy","ghost_loot","gnome827","heavenlyjive","howsya","iamyougaming","isoitiro","jpwai","karolk10","kenxai",
      "lordbuschguy","makasuro","mastinmusic","mikeax2","mikesters17","more_horchata","o0oo_live","oo0oo_live","operationcats","pandoracast",
      "playb0x","prizzo4real","prj_tv","seansguitarworldbang","shroud","simmons572","skrooner","slowpok3","splitsecondta","storksoofly",
      "sulliedsoc","ta_vorpalkitty","tritiumjones","twitch","tylermarket","vaxitylol","visisgaming","wholuvsdean","wrigglespk","xry_tv","z4t01"
    ];

    const supportConfig = {
      leagueChannel: "tribesprofessionalleague",
      paypalUrl: "https://www.paypal.com/ncp/payment/BC4EF2QC9T5GA"
    };

    const TEAM_LOGOS = {
      Avalanche: "TribesLeagueLogo's/aV!.png",
      ePidemic: "TribesLeagueLogo's/ePi.png",
      DPRK: "TribesLeagueLogo's/TeamDPRKLogo3.png",
      Zen: "TribesLeagueLogo's/Zenlogo.png",
      TXM: "TribesLeagueLogo's/TXM.png",
      FPS: "TribesLeagueLogo's/FPSlogo.png",
      FT: "TribesLeagueLogo's/FTlogo.png",
      HoE: "TribesLeagueLogo's/HoE.png",
      Magic: "TribesLeagueLogo's/Magic.png",
      DeadStop: "DeadStopLogo.png",
      UE: "TribesLeagueLogo's/UE.png",
      KTL: "TribesLeagueLogo's/KTLlogo.png",
      Null: "TribesLeagueLogo's/NullLogo.png",
      ToxicAimers: "TribesLeagueLogo's/ToxicAimersLogo.png"
    };

    const STORAGE = {
      CHANNELS: "twitchChannels",
      HIDDEN: "hiddenChannels",
      SHOW_LIVE: "showOnlyLive"
    };

    const els = {
      streamGrid: document.getElementById("stream-grid"),
      liveBanner: document.getElementById("live-channel-banner"),
      channelManager: document.getElementById("channel-manager"),
      addChannelForm: document.getElementById("add-channel-form"),
      addChannelInput: document.getElementById("add-channel-input"),
      liveToggleButtons: Array.from(document.querySelectorAll('[data-role="live-only-toggle"]')),
      showAllButton: document.getElementById("show-all-streams"),
      resetButton: document.getElementById("reset-defaults"),
      toast: document.getElementById("toast"),
      effectLayer: document.getElementById("support-effect-layer"),
      addOpenBtn: document.getElementById("open-add-streamer"),
      manageOpenBtn: document.getElementById("open-manager"),
      scrollToGridBtn: document.getElementById("scroll-to-grid"),
      controlPanel: document.getElementById("control-panel"),
      streamsArea: document.getElementById("streams-area"),
      supportActions: document.querySelector(".support-actions"),
      heroMetrics: {
        total: document.getElementById("metric-total-streams"),
        live: document.getElementById("metric-live-streams"),
        hidden: document.getElementById("metric-hidden-streams")
      },
      matchPoll: {
        container: document.querySelector('[data-role="match-poll"]'),
        card: document.getElementById("match-poll-card"),
        loading: document.getElementById("match-poll-loading"),
        content: document.getElementById("match-poll-content"),
        status: document.getElementById("match-poll-status"),

        title: document.getElementById("match-poll-title"),

        subhead: document.getElementById("match-poll-subhead"),
        meta: document.getElementById("match-poll-meta"),
        login: document.getElementById("match-poll-login"),
        loginBtn: document.getElementById("match-poll-login-btn"),
        options: document.getElementById("match-poll-options"),
        empty: document.getElementById("match-poll-empty"),
        error: document.getElementById("match-poll-error"),
        optionButtons: {
          A: document.getElementById("match-poll-option-a"),
          B: document.getElementById("match-poll-option-b")
        },
        teamNames: {
          A: document.getElementById("match-poll-team-a-name"),
          B: document.getElementById("match-poll-team-b-name")
        },
        teamCounts: {
          A: document.getElementById("match-poll-team-a-count"),
          B: document.getElementById("match-poll-team-b-count")
        },
        percentLabels: {
          A: document.getElementById("match-poll-team-a-percent"),
          B: document.getElementById("match-poll-team-b-percent")
        },
        progressLabels: {
          A: document.getElementById("match-poll-team-a-label"),
          B: document.getElementById("match-poll-team-b-label")
        },
        progressBars: {
          A: document.getElementById("match-poll-team-a-bar"),
          B: document.getElementById("match-poll-team-b-bar")
        }
      }
    };

    const state = {
      channels: [],
      hiddenChannels: [],
      showOnlyLive: false,
      liveSet: new Set(),
      lastLiveStreams: [],
      hasFetchedLiveStreams: false,
      streamerDirectory: new Map(),
      liveInterval: null,
      backdropSignature: "",
      backdropChecked: false
    };

    const teamIndex = new Map();
    const teamMetaCache = new Map();
    const slugPersistAttempts = new Set();
    const missingSlugWarnings = new Set();
    const VS_IMAGE_BASE_PATH = "TribesLeagueLogo's/TeamMatchUps";
    const VS_IMAGE_FALLBACK_SRC = "";
    const MATCH_POLL_LOADING_TEXT = "Loading featured matchup…";

    const pollEls = els.matchPoll || {};
    const pollState = {

      pollDocId: null,

      matchId: null,
      matchLoaded: false,
      teams: { A: "Team A", B: "Team B" },
      counts: { A: 0, B: 0 },
      user: null,
      userVote: null,
      saving: false,
      unsubscribe: null,

      voteSubscriptionId: null,
      activePollUnsubscribe: null,

      hasError: false,
      cleanupBound: false
    };

    function sanitizeSlug(value) {
      if (!value) return "";
      return String(value)
        .normalize("NFKD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^A-Za-z0-9]/g, "")
        .toUpperCase();
    }

    function pickSlug(...values) {
      for (const value of values) {
        const slug = sanitizeSlug(value);
        if (slug) return slug;
      }
      return "";
    }

    function toTeamDocRef(value) {
      if (!value) return null;
      if (typeof value === "string") {
        const trimmed = value.trim();
        return trimmed ? doc(db, "teams", trimmed) : null;
      }
      if (typeof value === "object") {
        if (value?.path && value?.id && typeof value.path === "string") {
          return value;
        }
        if (value?.id && typeof value.id === "string") {
          return doc(db, "teams", value.id);
        }
      }
      return null;
    }

    async function fetchTeamRecord(rawValue) {
      const docRef = toTeamDocRef(rawValue);
      if (!docRef) return null;
      const cacheKey = docRef.path || docRef.id;
      if (teamMetaCache.has(cacheKey)) {
        return teamMetaCache.get(cacheKey);
      }
      try {
        const snap = await getDoc(docRef);
        if (!snap.exists()) {
          teamMetaCache.set(cacheKey, null);
          return null;
        }
        const data = snap.data() || {};
        const teamName = data.teamName || data.name || data.displayName || data.team || docRef.id;
        let slug = sanitizeSlug(data.slug);
        if (!slug) {
          slug = pickSlug(
            data.teamTag,
            data.tag,
            data.abbreviation,
            data.abbrev,
            teamName,
            docRef.id
          );
          if (slug && !data.slug && !slugPersistAttempts.has(cacheKey)) {
            slugPersistAttempts.add(cacheKey);
            setDoc(docRef, { slug }, { merge: true }).catch(() => {});
          }
        }
        const record = { id: docRef.id, name: teamName, slug, data };
        teamMetaCache.set(cacheKey, record);
        return record;
      } catch (err) {
        console.warn("Failed to fetch team metadata", rawValue, err);
        teamMetaCache.set(cacheKey, null);
        return null;
      }
    }

    function setMatchSubheadContent(content) {
      if (!pollEls.subhead) return;
      pollEls.subhead.replaceChildren();
      if (typeof content === "string") {
        const span = document.createElement("span");
        span.className = "match-poll__subhead-text";
        span.textContent = content;
        pollEls.subhead.appendChild(span);
        pollEls.subhead.dataset.state = "text";
        return;
      }
      if (content instanceof Node) {
        pollEls.subhead.appendChild(content);
        pollEls.subhead.dataset.state = content.dataset?.state || "custom";
      }
    }

    function setMatchSubheadText(message) {
      setMatchSubheadContent(message);
    }

    function warnMissingSlug(contextKey, details = {}) {
      const {
        teamAName,
        teamBName,
        teamASlug,
        teamBSlug,
        reason,
        attemptedSrc,
        teamAId,
        teamBId
      } = details;
      const key = `${contextKey}:${teamASlug || "?"}-${teamBSlug || "?"}:${reason || "unknown"}`;
      if (missingSlugWarnings.has(key)) return;
      missingSlugWarnings.add(key);
      const payload = {
        teamA: teamAName || "Team A",
        teamB: teamBName || "Team B",
        teamAId: teamAId || null,
        teamBId: teamBId || null,
        teamASlug: teamASlug || null,
        teamBSlug: teamBSlug || null
      };
      if (attemptedSrc) {
        payload.asset = attemptedSrc;
      }
      console.warn(`[VSImage] Falling back for ${payload.teamA} vs ${payload.teamB} (${contextKey}) due to ${reason || "unknown"}.`, payload);
    }

    function renderMatchSubheadVs({ teamAName, teamBName, teamASlug, teamBSlug, teamAId, teamBId }) {
      if (!pollEls.subhead) return;
      if (!teamASlug || !teamBSlug) {
        warnMissingSlug("match-poll", { teamAName, teamBName, teamASlug, teamBSlug, teamAId, teamBId, reason: "missing-slug" });
      }
      const element = createVsImage({
        teamAName,
        teamBName,
        teamASlug,
        teamBSlug,
        basePath: VS_IMAGE_BASE_PATH,
        fallbackSrc: VS_IMAGE_FALLBACK_SRC,
        className: "vs-image",
        fallbackClass: "match-poll__subhead-text",
        onImageError: ({ attemptedSrc }) => {
          warnMissingSlug("match-poll", {
            teamAName,
            teamBName,
            teamASlug,
            teamBSlug,
            teamAId,
            teamBId,
            reason: "image-error",
            attemptedSrc
          });
        }
      });
      setMatchSubheadContent(element);
    }

    function extractTeamReference(matchData, side) {
      if (!matchData) return null;
      const prefix = (side || "A").toUpperCase() === "B" ? "B" : "A";
      const altKeys = prefix === "A" ? ["home", "blue"] : ["away", "red"];
      const candidates = [
        matchData[`team${prefix}Id`],
        matchData[`team${prefix}ID`],
        matchData[`team${prefix}`]?.id,
        matchData[`team${prefix}`]?.teamId,
        matchData[`team${prefix}`]?.ref,
        matchData[`team${prefix}`]?.doc,
        matchData[`team${prefix}Ref`],
        matchData[`team${prefix}Doc`],
        matchData[`${prefix.toLowerCase()}TeamId`],
        matchData[`${altKeys[0]}Id`],
        matchData[`${altKeys[0]}ID`],
        matchData[`${altKeys[0]}TeamId`],
        matchData[`${altKeys[0]}TeamID`],
        matchData[`${altKeys[0]}Team`]?.id,
        matchData[`${altKeys[0]}Team`]?.teamId,
        matchData[`${altKeys[1]}Id`],
        matchData[`${altKeys[1]}ID`],
        matchData[`${altKeys[1]}TeamId`],
        matchData[`${altKeys[1]}Team`]?.id,
        matchData[`${altKeys[1]}Team`]?.teamId
      ];
      for (const candidate of candidates) {
        if (candidate) return candidate;
      }
      return null;
    }

    function pollEnabled() {
      return Boolean(pollEls?.container);
    }

    function setPollStatus(message) {
      if (pollEls.status) {
        pollEls.status.textContent = message;
      }
    }

    function setPollLoading(isLoading) {
      if (!pollEnabled()) return;
      if (pollEls.loading) {
        pollEls.loading.classList.toggle("is-hidden", !isLoading);
      }
      if (pollEls.content) {
        pollEls.content.classList.toggle("is-hidden", isLoading);
      }
    }

    function setPollError(message) {
      if (!pollEnabled() || !pollEls.error) return;
      pollState.hasError = Boolean(message);
      pollEls.error.textContent = message || "";
      pollEls.error.classList.toggle("is-hidden", !message);
      updatePollInteractivity();
    }

    function clearPollError() {
      setPollError("");
    }

    function formatVoteCount(value) {
      const count = Number(value) || 0;
      return `${count} vote${count === 1 ? "" : "s"}`;
    }

    function coerceDate(value) {
      if (!value) return null;
      if (value instanceof Date) return value;
      if (typeof value?.toDate === "function") {
        try {
          return value.toDate();
        } catch {
          return null;
        }
      }
      if (typeof value === "number") {
        const numericDate = new Date(value);
        return Number.isNaN(numericDate.getTime()) ? null : numericDate;
      }
      if (typeof value === "string") {
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      }
      return null;
    }

    function formatMatchDate(value) {
      const date = coerceDate(value);
      if (!date) return "";
      try {
        return date.toLocaleString(undefined, {
          month: "short",
          day: "numeric",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit"
        });
      } catch (err) {
        console.error("Failed to format match date", err);
        return "";
      }
    }

    function updatePollOptionStyles() {
      if (!pollEnabled() || !pollEls.optionButtons) return;
      Object.entries(pollEls.optionButtons).forEach(([teamKey, button]) => {
        if (!button) return;
        button.classList.toggle("is-selected", pollState.userVote === teamKey);
      });
    }

    function updatePollInteractivity() {
      if (!pollEnabled()) return;
      const allowVoting = pollState.matchLoaded && !pollState.hasError && pollState.user && !pollState.saving;
      if (pollEls.options) {
        pollEls.options.classList.toggle("is-disabled", !allowVoting);
      }
      if (pollEls.optionButtons) {
        Object.values(pollEls.optionButtons).forEach(button => {
          if (!button) return;
          button.disabled = !allowVoting;
        });
      }
    }

    function updatePollUI() {
      if (!pollEnabled()) return;
      const totalVotes = (pollState.counts.A || 0) + (pollState.counts.B || 0);
      const percentA = totalVotes ? Math.round((pollState.counts.A / totalVotes) * 100) : 0;
      const percentB = totalVotes ? 100 - percentA : 0;

      if (pollEls.percentLabels) {
        if (pollEls.percentLabels.A) pollEls.percentLabels.A.textContent = `${percentA}%`;
        if (pollEls.percentLabels.B) pollEls.percentLabels.B.textContent = `${percentB}%`;
      }
      if (pollEls.progressBars) {
        if (pollEls.progressBars.A) pollEls.progressBars.A.style.width = `${percentA}%`;
        if (pollEls.progressBars.B) pollEls.progressBars.B.style.width = `${percentB}%`;
      }
      if (pollEls.teamCounts) {
        if (pollEls.teamCounts.A) pollEls.teamCounts.A.textContent = formatVoteCount(pollState.counts.A);
        if (pollEls.teamCounts.B) pollEls.teamCounts.B.textContent = formatVoteCount(pollState.counts.B);
      }
      if (pollEls.empty) {
        pollEls.empty.classList.toggle("is-hidden", totalVotes !== 0);
      }
      updatePollOptionStyles();


      if (!pollState.matchLoaded) {
        setPollStatus("No featured poll is active right now.");
        return;
      }


      let statusText = totalVotes ? `Live votes: ${totalVotes}` : "No votes cast yet.";
      if (!pollState.user) {
        statusText = totalVotes
          ? `Live votes: ${totalVotes} — log in to vote.`
          : "Log in to vote and be the first!";
      }
      setPollStatus(statusText);
    }

    function setPollAuthUI(isAuthenticated) {
      if (!pollEnabled()) return;
      if (pollEls.login) {

        const shouldShowLogin = !isAuthenticated && pollState.matchLoaded;
        pollEls.login.classList.toggle("is-hidden", !shouldShowLogin);

      }
      if (!isAuthenticated) {
        pollState.userVote = null;
        updatePollOptionStyles();
      }
      updatePollInteractivity();
    }

    function setPollSaving(isSaving) {
      pollState.saving = Boolean(isSaving);
      if (pollState.saving) {
        setPollStatus("Submitting your vote…");
      }
      updatePollInteractivity();
    }

    async function refreshPollUserVote() {
      if (!pollEnabled() || !pollState.user || !pollState.matchId) return;
      try {
        const voteSnap = await getDoc(doc(db, "matchVotes", pollState.matchId, "votes", pollState.user.id));
        if (voteSnap.exists()) {
          pollState.userVote = voteSnap.data()?.team ?? null;
        } else {
          pollState.userVote = null;
        }
        updatePollUI();
      } catch (err) {
        console.error("Failed to refresh poll vote", err);
      }
    }

    async function ensurePollUser() {
      if (!pollEnabled()) return null;
      if (!window.twitchOAuth || !window.twitchOAuth.getToken()) {
        pollState.user = null;
        setPollAuthUI(false);
        updatePollUI();
        return null;
      }

      try {
        pollState.user = await window.twitchOAuth.fetchUser();
      } catch (err) {
        console.error("Failed to fetch Twitch user", err);
        pollState.user = null;
      }

      setPollAuthUI(Boolean(pollState.user));
      if (pollState.user) {
        await refreshPollUserVote();
      }
      return pollState.user;
    }

    function subscribeToPollVotes() {
      if (!pollEnabled() || !pollState.matchId) return;

      if (pollState.unsubscribe && pollState.voteSubscriptionId === pollState.matchId) {
        return;
      }
      if (pollState.unsubscribe) {
        pollState.unsubscribe();
        pollState.unsubscribe = null;
        pollState.voteSubscriptionId = null;

      }
      const votesRef = collection(db, "matchVotes", pollState.matchId, "votes");
      pollState.unsubscribe = onSnapshot(votesRef, snapshot => {
        clearPollError();
        const counts = { A: 0, B: 0 };
        let userVote = pollState.userVote;
        snapshot.forEach(docSnap => {
          const data = docSnap.data();
          if (data?.team === "A") counts.A += 1;
          if (data?.team === "B") counts.B += 1;
          if (pollState.user && docSnap.id === pollState.user.id) {
            userVote = data?.team ?? null;
          }
        });
        pollState.counts = counts;
        pollState.userVote = userVote ?? (pollState.user ? null : pollState.userVote);
        updatePollUI();
      }, err => {
        console.error("Failed to subscribe to poll votes", err);
        setPollError("Live vote updates are unavailable right now.");
      });

      pollState.voteSubscriptionId = pollState.matchId;
    }


    async function loadPollMatch() {
      setMatchSubheadText(MATCH_POLL_LOADING_TEXT);
      if (!pollEnabled() || !pollState.matchId) {
        setPollLoading(false);
        setPollStatus("No match selected.");
        setMatchSubheadText("No match selected.");
        pollState.matchLoaded = false;
        updatePollInteractivity();
        return false;
      }
      try {
        setPollStatus("Loading votes…");
        setPollLoading(true);
        clearPollError();
        const matchRef = doc(db, "matches", pollState.matchId);
        const snap = await getDoc(matchRef);
        if (!snap.exists()) {
          pollState.matchLoaded = false;
          pollState.counts = { A: 0, B: 0 };
          updatePollUI();
          setPollLoading(false);
          setPollStatus("Match not found.");
          setMatchSubheadText("Match not found.");
          setPollError("We couldn't find that match. Update the featured match ID to continue.");
          if (pollState.unsubscribe) {
            pollState.unsubscribe();
            pollState.unsubscribe = null;
          }
          updatePollInteractivity();
          return false;
        }


      const data = docSnap.data() || {};
      const voteIdCandidate = (data.voteId || docSnap.id || "").trim();
      const nextVoteId = voteIdCandidate || docSnap.id;
      const voteIdChanged = pollState.matchId !== nextVoteId;


        if (pollEls.teamNames) {
          if (pollEls.teamNames.A) pollEls.teamNames.A.textContent = pollState.teams.A;
          if (pollEls.teamNames.B) pollEls.teamNames.B.textContent = pollState.teams.B;
        }
        if (pollEls.progressLabels) {
          if (pollEls.progressLabels.A) pollEls.progressLabels.A.textContent = pollState.teams.A;
          if (pollEls.progressLabels.B) pollEls.progressLabels.B.textContent = pollState.teams.B;
        }
        const teamARef = extractTeamReference(data, "A");
        const teamBRef = extractTeamReference(data, "B");
        const [teamAMeta, teamBMeta] = await Promise.all([
          fetchTeamRecord(teamARef),
          fetchTeamRecord(teamBRef)
        ]);
        const teamASlug = pickSlug(
          teamAMeta?.slug,
          data.teamASlug,
          data.teamA_slug,
          data.teamATag,
          data.team1Tag,
          data.team1Slug,
          data.homeTag,
          data.homeSlug,
          data.blueTag,
          data.blueSlug,
          pollState.teams.A
        );
        const teamBSlug = pickSlug(
          teamBMeta?.slug,
          data.teamBSlug,
          data.teamB_slug,
          data.teamBTag,
          data.team2Tag,
          data.team2Slug,
          data.awayTag,
          data.awaySlug,
          data.redTag,
          data.redSlug,
          pollState.teams.B
        );
        const teamAId = teamAMeta?.id || (typeof teamARef === "string" ? teamARef : teamARef?.id);
        const teamBId = teamBMeta?.id || (typeof teamBRef === "string" ? teamBRef : teamBRef?.id);
        renderMatchSubheadVs({
          teamAName: pollState.teams.A,
          teamBName: pollState.teams.B,
          teamASlug,
          teamBSlug,
          teamAId,
          teamBId
        });


      if (pollEls.title) {
        pollEls.title.textContent = (data.title || "Who will win?").trim() || "Who will win?";
      }
      if (pollEls.teamNames) {
        if (pollEls.teamNames.A) pollEls.teamNames.A.textContent = pollState.teams.A;
        if (pollEls.teamNames.B) pollEls.teamNames.B.textContent = pollState.teams.B;
      }
      if (pollEls.progressLabels) {
        if (pollEls.progressLabels.A) pollEls.progressLabels.A.textContent = pollState.teams.A;
        if (pollEls.progressLabels.B) pollEls.progressLabels.B.textContent = pollState.teams.B;
      }
      if (pollEls.subhead) {
        pollEls.subhead.textContent = `${pollState.teams.A} vs ${pollState.teams.B}`;
      }


        pollState.matchLoaded = true;
        setPollLoading(false);
        updatePollInteractivity();
        updatePollUI();
        return true;
      } catch (err) {
        console.error("Failed to load featured match", err);
        pollState.matchLoaded = false;
        pollState.counts = { A: 0, B: 0 };
        updatePollUI();
        setPollLoading(false);
        setPollStatus("Match unavailable.");
        setMatchSubheadText("Unable to load matchup.");
        setPollError("Unable to load match details. Please refresh and try again.");
        updatePollInteractivity();
        return false;

      }

      clearPollError();
      setPollLoading(false);
      updatePollInteractivity();
      updatePollUI();
      setPollAuthUI(Boolean(pollState.user));

      if (voteIdChanged && pollState.unsubscribe) {
        pollState.unsubscribe();
        pollState.unsubscribe = null;
        pollState.voteSubscriptionId = null;
      }
      subscribeToPollVotes();
      if (pollState.user) {
        refreshPollUserVote();
      }
    }

    function subscribeToActivePoll() {
      if (!pollEnabled()) return;
      if (pollState.activePollUnsubscribe) {
        pollState.activePollUnsubscribe();
        pollState.activePollUnsubscribe = null;
      }
      const pollsRef = collection(db, "matchPolls");
      const activeQuery = query(pollsRef, where("isActive", "==", true), limit(1));
      pollState.activePollUnsubscribe = onSnapshot(activeQuery, snapshot => {
        clearPollError();
        if (snapshot.empty) {
          applyActivePollDoc(null);
        } else {
          applyActivePollDoc(snapshot.docs[0]);
        }
      }, err => {
        console.error("Failed to subscribe to featured poll", err);
        setPollError("Unable to load the featured poll right now.");
        applyActivePollDoc(null);
        setPollLoading(false);
      });

    }

    async function submitPollVote(teamKey) {
      if (!pollEnabled() || !pollState.matchLoaded || !pollState.matchId) return;
      if (!pollState.user) {
        setPollAuthUI(false);
        return;
      }
      if (pollState.saving || teamKey === pollState.userVote) {
        return;
      }

      clearPollError();
      setPollSaving(true);
      try {
        const voteRef = doc(db, "matchVotes", pollState.matchId, "votes", pollState.user.id);
        const payload = { team: teamKey };
        if (pollState.userVote) {
          payload.updatedAt = serverTimestamp();
        } else {
          payload.createdAt = serverTimestamp();
        }
        await setDoc(voteRef, payload, { merge: true });
        pollState.userVote = teamKey;
        updatePollOptionStyles();
        setPollStatus("Vote saved!");
      } catch (err) {
        console.error("Failed to submit poll vote", err);
        setPollError("Unable to save your vote. Please try again.");
      } finally {
        setPollSaving(false);
      }
    }

    function bindPollEvents() {
      if (!pollEnabled()) return;
      if (pollEls.optionButtons?.A) {
        pollEls.optionButtons.A.addEventListener("click", () => submitPollVote("A"));
      }
      if (pollEls.optionButtons?.B) {
        pollEls.optionButtons.B.addEventListener("click", () => submitPollVote("B"));
      }
      if (pollEls.loginBtn) {
        pollEls.loginBtn.addEventListener("click", () => {
          if (window.twitchOAuth) {
            window.twitchOAuth.login();
          }
        });
      }
      if (!pollState.cleanupBound) {
        window.addEventListener("beforeunload", () => {
          if (pollState.unsubscribe) {
            pollState.unsubscribe();
            pollState.unsubscribe = null;
          }

          if (pollState.activePollUnsubscribe) {
            pollState.activePollUnsubscribe();
            pollState.activePollUnsubscribe = null;
          }

        });
        pollState.cleanupBound = true;
      }
    }

    async function initializeMatchPoll() {
      if (!pollEnabled()) return;

      bindPollEvents();
      setPollLoading(true);
      setPollStatus("Loading featured poll…");
      await ensurePollUser();
      subscribeToActivePoll();

      window.addEventListener("storage", event => {
        if (event.key === "twitch_token") {
          ensurePollUser();
        }
      });
    }

    const parentHosts = new Set([
      window.location.hostname,
      "www.tribesprofessionalleague.online",
      "tribesprofessionalleague.online",
      "t24085.github.io",
      "localhost",
      "127.0.0.1"
    ].filter(Boolean));
    if (!parentHosts.size) {
      parentHosts.add("www.tribesprofessionalleague.online");
    }
    const parentQuery = Array.from(parentHosts).map(host => `parent=${encodeURIComponent(host)}`).join("&");
    function normalizeChannel(value = "") {
      return String(value || "").trim().toLowerCase();
    }
    function sortAndDedup(list = []) {
      return Array.from(new Set(list.map(normalizeChannel))).sort((a, b) => a.localeCompare(b));
    }
    function isValidChannel(channel) {
      return /^[a-z0-9_]{4,25}$/.test(channel);
    }
    function escapeHtml(value = "") {
      return String(value).replace(/[&<>"']/g, ch => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      })[ch] || ch);
    }
    function formatNumber(value, decimals = 0) {
      const num = Number(value);
      if (!Number.isFinite(num)) {
        return (0).toFixed(decimals);
      }
      return num.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }
function toNumber(value, fallback = 0) {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    }
        function buildPlayerUrl(channel) {
      return `https://player.twitch.tv/?channel=${encodeURIComponent(channel)}&${parentQuery}&autoplay=false`;
    }
    function buildChatUrl(channel) {
      return `https://www.twitch.tv/embed/${encodeURIComponent(channel)}/chat?${parentQuery}`;
    }
    function buildBitsUrl(channel) {
      return `https://www.twitch.tv/products/${encodeURIComponent(channel)}/bits?ref=tpl_hub`;
    }
    function persistChannels() {
      localStorage.setItem(STORAGE.CHANNELS, JSON.stringify(state.channels));
    }
    function persistHidden() {
      localStorage.setItem(STORAGE.HIDDEN, JSON.stringify(state.hiddenChannels));
    }
    function persistShowOnlyLive() {
      localStorage.setItem(STORAGE.SHOW_LIVE, JSON.stringify(state.showOnlyLive));
    }
    function loadList(key, fallback = []) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return [...fallback];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [...fallback];
        return parsed.map(normalizeChannel);
      } catch {
        return [...fallback];
      }
    }
    function loadBool(key, fallback = false) {
      try {
        const raw = localStorage.getItem(key);
        if (raw === null) return fallback;
        return Boolean(JSON.parse(raw));
      } catch {
        return fallback;
      }
    }
    function initializeState() {
      state.channels = sortAndDedup(loadList(STORAGE.CHANNELS, defaultChannels));
      state.hiddenChannels = sortAndDedup(loadList(STORAGE.HIDDEN, [])).filter(channel => state.channels.includes(channel));
      state.showOnlyLive = loadBool(STORAGE.SHOW_LIVE, false);
    }
    function hydrateTeamIndex() {
      teamIndex.clear();
      const roster = window.twitchOAuth?.TEAM_STREAMS || {};
      Object.entries(roster).forEach(([teamName, players]) => {
        (players || []).forEach(player => {
          if (!player?.url) return;
          const match = player.url.match(/twitch\.tv\/([^/?]+)/i);
          if (!match) return;
          const handle = normalizeChannel(match[1]);
          teamIndex.set(handle, {
            team: teamName,
            displayName: player.name || handle
          });
        });
      });
    }
    function getStreamerMeta(channel) {
      const key = normalizeChannel(channel);
      const directoryEntry = state.streamerDirectory.get(key);
      const teamEntry = teamIndex.get(key);
      const displayName = directoryEntry?.displayName || teamEntry?.displayName || key;
      const teamName = directoryEntry?.team || teamEntry?.team || "";
      const avatar = directoryEntry?.avatar && directoryEntry.avatar.trim()
        ? directoryEntry.avatar.trim()
        : `https://decapi.me/twitch/avatar/${encodeURIComponent(key)}`;
      const bio = directoryEntry?.bio || "";
      return { channel: key, displayName, team: teamName, avatar, bio };
    }
    function computeVisibleChannels() {
      return state.channels.filter(channel => !state.hiddenChannels.includes(channel) && (!state.showOnlyLive || state.liveSet.has(channel)));
    }
    function updateMetrics() {
      if (els.heroMetrics.total) {
        els.heroMetrics.total.textContent = state.channels.length;
      }
      if (els.heroMetrics.live) {
        const liveCount = state.channels.filter(channel => state.liveSet.has(channel)).length;
        els.heroMetrics.live.textContent = liveCount;
      }
      if (els.heroMetrics.hidden) {
        els.heroMetrics.hidden.textContent = state.hiddenChannels.length;
      }
    }
    function updateLiveToggleButtons() {
      const label = state.showOnlyLive ? "Show All Streams" : "Show Only Live";
      els.liveToggleButtons.forEach(btn => {
        if (!btn) return;
        btn.textContent = label;
        btn.dataset.mode = state.showOnlyLive ? "live" : "all";
      });
    }
    function renderLiveBanner() {
      if (!els.liveBanner) return;
      els.liveBanner.innerHTML = "";
      if (!state.lastLiveStreams.length) {
        if (window.twitchOAuth?.getToken()) {
          const span = document.createElement("span");
          span.style.fontSize = "0.8rem";
          span.style.color = "rgba(226,232,240,0.66)";
          span.textContent = "No tracked channels live right now.";
          els.liveBanner.appendChild(span);
        }
        return;
      }
      state.lastLiveStreams.forEach(stream => {
        const div = document.createElement("div");
        div.className = "live-box";
        const viewers = stream.viewer_count ? `<span class="viewers">${stream.viewer_count.toLocaleString()} viewers</span>` : "";
        div.innerHTML =
          `<span class="live-dot">●</span>` +
          `<span class="live-name">${escapeHtml(stream.user_name)}</span>` +
          viewers;
        els.liveBanner.appendChild(div);
      });
    }
    function updateLiveBackdrop() {
      if (state.backdropChecked || !state.hasFetchedLiveStreams) {
        return;
      }
      state.backdropChecked = true;
      const container = document.getElementById("live-team-backdrop");
      if (!container) return;
      const teams = [];
      (state.lastLiveStreams || []).forEach(stream => {
        const login = (stream?.user_login || stream?.user_name || "").toLowerCase();
        if (!login) return;
        const mapping = teamIndex.get(login);
        const teamName = mapping?.team;
        if (teamName && !teams.includes(teamName)) {
          teams.push(teamName);
        }
      });
      if (!teams.length) {
        container.innerHTML = "";
        container.classList.remove("is-visible");
        container.dataset.count = "0";
        document.body.classList.remove("has-live-backdrop");
        state.backdropSignature = "";
        return;
      }
      const limited = teams.slice(0, 4);
      const signature = `${limited.length}:${limited.join("|")}`;
      container.dataset.count = String(limited.length);
      if (signature === state.backdropSignature) {
        document.body.classList.add("has-live-backdrop");
        container.classList.add("is-visible");
        return;
      }
      const fragment = document.createDocumentFragment();
      limited.forEach(teamName => {
        const panel = document.createElement("div");
        panel.className = "live-team-panel";
        const logoCandidate = TEAM_LOGOS[teamName] || TEAM_LOGOS[teamName?.replace(/\s+/g, "")] || "Tribes Professional League.png";
        let logoUrl = logoCandidate;
        if (!/^https?:/i.test(logoCandidate)) {
          logoUrl = encodeURI(logoCandidate).replace(/'/g, '%27');
        }
        panel.style.backgroundImage = `url(${logoUrl})`;
        panel.dataset.team = teamName;
        fragment.appendChild(panel);
      });
      container.innerHTML = "";
      container.appendChild(fragment);
      document.body.classList.add("has-live-backdrop");
      container.classList.add("is-visible");
      state.backdropSignature = signature;
    }

    function renderStreamGrid() {
      if (!els.streamGrid) return;
      const visibleChannels = computeVisibleChannels();
      if (!visibleChannels.length) {
        els.streamGrid.innerHTML = "";
        const empty = document.createElement("div");
        empty.className = "empty-state";
        empty.innerHTML = "No streams to display right now.<br>Use the controls to add streamers or show hidden entries." +
          (state.hiddenChannels.length ? '<br><button type="button" id="empty-show-all">Show Hidden Streams</button>' : "");
        els.streamGrid.appendChild(empty);
        const showAllBtn = document.getElementById("empty-show-all");
        if (showAllBtn) {
          showAllBtn.addEventListener("click", showAllChannels);
        }
        return;
      }
      const fragment = document.createDocumentFragment();
      visibleChannels.forEach(channel => {
        const meta = getStreamerMeta(channel);
        const isLive = state.liveSet.has(channel);
        const card = document.createElement("article");
        card.className = "stream-card";
        card.dataset.channel = channel;
        card.dataset.live = isLive ? "true" : "false";
        card.classList.toggle("is-live", isLive);
        card.innerHTML = `
          <div class="stream-card__head">
            <div class="stream-card__identity">
              <span class="stream-card__avatar">
                <img src="${escapeHtml(meta.avatar)}" alt="${escapeHtml(meta.displayName)} avatar" onerror="this.src='https://static-cdn.jtvnw.net/jtv_user_pictures/xarth/404_user_70x70.png'">
              </span>
              <div>
                <p class="stream-card__name">${escapeHtml(meta.displayName)}</p>
                ${meta.team ? `<p class="stream-card__team">${escapeHtml(meta.team)}</p>` : `<p class="stream-card__team">@${escapeHtml(meta.channel)}</p>`}
              </div>
            </div>
            <div class="stream-card__status">
              ${isLive ? '<span class="live-pill">Live</span>' : '<span class="offline-pill">Offline</span>'}
            </div>
          </div>
          <div class="stream-card__player">
            <div class="player-frame">
              <iframe src="${buildPlayerUrl(channel)}" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen loading="lazy" title="${escapeHtml(meta.displayName)} stream"></iframe>
            </div>
          </div>
          <div class="stream-card__actions">
            <button type="button" class="card-action" data-action="stats">View Stats</button>
            <button type="button" class="card-action" data-action="chat">See Chat</button>
            <button type="button" class="card-action support" data-action="support">Send Bits</button>
          </div>
          <div class="stream-card__extras" data-role="extras">
            <div class="stream-card__stats" data-role="stats-panel" hidden></div>
            <div class="stream-card__chat" data-role="chat-panel" hidden>
              <iframe title="${escapeHtml(meta.displayName)} chat" src="about:blank" data-src="${buildChatUrl(channel)}" sandbox="allow-storage-access-by-user-activation allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-modals"></iframe>
            </div>
          </div>
        `;
        fragment.appendChild(card);
      });
      els.streamGrid.innerHTML = "";
      els.streamGrid.appendChild(fragment);
    }
    function reorderStreamGrid() {
      if (!els.streamGrid) return;
      const existingCards = els.streamGrid.querySelectorAll(".stream-card");
      if (!existingCards.length) return;
      const fragment = document.createDocumentFragment();
      state.channels.forEach(channel => {
        const card = els.streamGrid.querySelector('[data-channel="' + channel + '"]');
        if (card) {
          fragment.appendChild(card);
        }
      });
      if (fragment.childNodes.length) {
        els.streamGrid.appendChild(fragment);
      }
    }
    function updateStreamCardStatuses() {
      if (!els.streamGrid) return;
      const cards = els.streamGrid.querySelectorAll(".stream-card");
      cards.forEach(card => {
        const channel = card.dataset.channel;
        if (!channel) return;
        const isLive = state.liveSet.has(channel);
        card.classList.toggle("is-live", isLive);
        card.dataset.live = isLive ? "true" : "false";
        const status = card.querySelector(".stream-card__status");
        if (!status) return;
        let badge = status.querySelector(".live-pill, .offline-pill");
        if (!badge) {
          badge = document.createElement("span");
          status.innerHTML = "";
          status.appendChild(badge);
        }
        if (isLive) {
          badge.className = "live-pill";
          badge.textContent = "Live";
        } else {
          badge.className = "offline-pill";
          badge.textContent = "Offline";
        }
      });

    }
    function renderChannelManager() {
      if (!els.channelManager) return;
      const fragment = document.createDocumentFragment();
      state.channels.forEach(channel => {
        const meta = getStreamerMeta(channel);
        const isHidden = state.hiddenChannels.includes(channel);
        const isLive = state.liveSet.has(channel);
        const row = document.createElement("div");
        row.className = "channel-row";
        row.dataset.channel = channel;
        row.innerHTML = `
          <div class="channel-row__top">
            <div class="channel-row__meta">
              <span class="channel-row__name">${escapeHtml(meta.displayName)}</span>
              <span class="channel-row__handle">@${escapeHtml(meta.channel)}</span>
              ${meta.team ? `<span class="channel-row__team">${escapeHtml(meta.team)}</span>` : ""}
            </div>
            <div class="channel-row__badges">
              ${isLive ? '<span class="badge badge-live">Live</span>' : ""}
              ${isHidden ? '<span class="badge badge-muted">Hidden</span>' : ""}
            </div>
          </div>
          <div class="channel-row__actions">
            <button type="button" class="pill-btn secondary" data-action="stats">Stats</button>
            <button type="button" class="pill-btn secondary" data-action="chat">Chat</button>
            <button type="button" class="pill-btn" data-action="toggle-hidden">${isHidden ? "Show" : "Hide"}</button>
            <button type="button" class="pill-btn danger" data-action="remove">Remove</button>
          </div>
        `;
        fragment.appendChild(row);
      });
      els.channelManager.innerHTML = "";
      els.channelManager.appendChild(fragment);
    }
    function renderAll(options = {}) {
      const { skipStreamGrid = false } = options;
      if (!skipStreamGrid) {
        renderStreamGrid();
      }
      renderChannelManager();
      updateLiveToggleButtons();
      renderLiveBanner();
      updateMetrics();
      updateLiveBackdrop();

      updateStreamCardStatuses();

    }
    function findStreamCard(channel) {
      if (!els.streamGrid) return null;
      return els.streamGrid.querySelector('[data-channel="' + channel + '"]');
    }
    function updateCardExtrasState(card) {
      if (!card) return;
      const extras = card.querySelector('[data-role="extras"]');
      if (!extras) return;
      const hasVisible = Array.from(extras.children || []).some(section => !section.hasAttribute("hidden"));
      extras.classList.toggle("is-visible", hasVisible);
    }
    function syncCardActionLabels(card) {
      if (!card) return;
      const statsBtn = card.querySelector('[data-action="stats"]');
      const statsPanel = card.querySelector('[data-role="stats-panel"]');
      if (statsBtn && statsPanel) {
        statsBtn.textContent = statsPanel.hasAttribute("hidden") ? "View Stats" : "Hide Stats";
      }
      const chatBtn = card.querySelector('[data-action="chat"]');
      const chatPanel = card.querySelector('[data-role="chat-panel"]');
      if (chatBtn && chatPanel) {
        chatBtn.textContent = chatPanel.hasAttribute("hidden") ? "See Chat" : "Hide Chat";
      }
    }
    async function toggleChannelStats(channel, options = {}) {
      const normalized = normalizeChannel(channel);
      const card = options.card || findStreamCard(normalized);
      if (!card) {
        showToast(`Add ${normalized} to the grid first.`);
        return;
      }
      const panel = card.querySelector('[data-role="stats-panel"]');
      if (!panel) return;
      const meta = getStreamerMeta(normalized);
      const shouldShow = options.desiredState !== undefined ? options.desiredState : panel.hasAttribute("hidden");
      if (!shouldShow) {
        panel.setAttribute("hidden", "");
        updateCardExtrasState(card);
        syncCardActionLabels(card);
        showToast(`Hiding stats for ${meta.displayName || meta.channel}`);
        return;
      }

      panel.removeAttribute("hidden");
      updateCardExtrasState(card);
      syncCardActionLabels(card);
      if (!panel.dataset.loaded) {
        panel.innerHTML = '<div class="stats-body"><p class="stream-card__placeholder">Loading stats…</p></div>';
        try {
          const bundle = await loadPlayerStats();
          const stats = resolvePlayerStats(bundle, meta);
          panel.innerHTML = buildStatsMarkup(meta, stats);
          const supportButton = panel.querySelector('[data-stats-action="support"]');
          if (supportButton) {
            supportButton.addEventListener("click", () => handleSupportForChannel(meta.channel));
          }
          panel.dataset.loaded = "true";
          showToast(`Showing stats for ${meta.displayName || meta.channel}`);
        } catch (err) {
          console.error("Unable to load stats", err);
          panel.innerHTML = '<div class="stats-body"><p class="stream-card__placeholder">Unable to load stats right now.</p></div>';
          showToast(`Unable to load stats for ${meta.displayName || meta.channel}`);
        }
      } else {
        showToast(`Showing stats for ${meta.displayName || meta.channel}`);
      }
      updateCardExtrasState(card);
      syncCardActionLabels(card);
      if (options.scrollIntoView) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }
    function toggleChannelChat(channel, options = {}) {
      const normalized = normalizeChannel(channel);
      const card = options.card || findStreamCard(normalized);
      if (!card) {
        showToast(`Add ${normalized} to the grid first.`);
        return;
      }
      const panel = card.querySelector('[data-role="chat-panel"]');
      if (!panel) return;
      const meta = getStreamerMeta(normalized);
      const shouldShow = options.desiredState !== undefined ? options.desiredState : panel.hasAttribute("hidden");
      if (!shouldShow) {
        panel.setAttribute("hidden", "");
        updateCardExtrasState(card);
        syncCardActionLabels(card);
        showToast(`Hiding chat for ${meta.displayName || normalized}`);
        return;

      }
      panel.removeAttribute("hidden");
      const iframe = panel.querySelector("iframe");
      if (iframe && !iframe.dataset.loaded) {
        const src = iframe.dataset.src || buildChatUrl(normalized);
        iframe.src = src;
        iframe.dataset.loaded = "true";
      }
      updateCardExtrasState(card);
      syncCardActionLabels(card);
      if (options.scrollIntoView) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }

      showToast(`Showing chat for ${meta.displayName || normalized}`);
    }
    function toggleLiveMode() {
      state.showOnlyLive = !state.showOnlyLive;
      persistShowOnlyLive();
      renderAll();
      showToast(state.showOnlyLive ? "Showing live channels only" : "Showing all channels");
    }
    function showAllChannels() {
      state.hiddenChannels = [];
      persistHidden();
      renderAll();
      showToast("All streams visible");
    }
    function resetToDefaults() {
      if (!window.confirm("Reset the stream list to the league defaults?")) {
        return;
      }
      state.channels = sortAndDedup(defaultChannels);
      state.hiddenChannels = [];
      persistChannels();
      persistHidden();
      renderAll();
      showToast("Stream roster reset to defaults");
    }
    function handleAddChannel(event) {
      event.preventDefault();
      const value = normalizeChannel(els.addChannelInput?.value);
      if (!value) {
        showToast("Enter a Twitch channel name");
        return;
      }
      if (!isValidChannel(value)) {
        showToast("Channel names use 4-25 letters, numbers, or underscores.");
        return;
      }
      if (state.channels.includes(value)) {
        showToast(`${value} is already tracked`);
        return;
      }
      state.channels.push(value);
      state.channels = sortAndDedup(state.channels);
      state.hiddenChannels = state.hiddenChannels.filter(channel => channel !== value);
      persistChannels();
      persistHidden();
      if (els.addChannelInput) {
        els.addChannelInput.value = "";
      }
      renderAll();
      showToast(`Added ${value} to the wall`);
    }
    function toggleChannelHidden(channel) {
      const normalized = normalizeChannel(channel);
      const index = state.hiddenChannels.indexOf(normalized);
      if (index >= 0) {
        state.hiddenChannels.splice(index, 1);
        showToast(`Showing ${normalized}`);
      } else {
        state.hiddenChannels.push(normalized);
        showToast(`Hiding ${normalized}`);
      }
      persistHidden();
      renderAll();
    }
    function removeChannel(channel) {
      const normalized = normalizeChannel(channel);
      const index = state.channels.indexOf(normalized);
      if (index === -1) return;
      state.channels.splice(index, 1);
      state.hiddenChannels = state.hiddenChannels.filter(value => value !== normalized);
      persistChannels();
      persistHidden();
      renderAll();
      showToast(`Removed ${normalized}`);
    }
    function handleStreamGridClick(event) {
      const card = event.target.closest(".stream-card");
      if (!card) return;
      const channel = card.dataset.channel;
      const actionBtn = event.target.closest("[data-action]");
      if (actionBtn) {
        const action = actionBtn.dataset.action;
        if (action === "stats") {
          toggleChannelStats(channel, { card });
        } else if (action === "chat") {
          toggleChannelChat(channel, { card });
        } else if (action === "support") {
          handleSupportForChannel(channel);
        }
        return;
      }
      if (event.target.closest(".stream-card__identity")) {
        toggleChannelStats(channel, { card, desiredState: true });
      }
    }
    function handleManagerClick(event) {
      const row = event.target.closest(".channel-row");
      if (!row) return;
      const channel = row.dataset.channel;
      const actionBtn = event.target.closest("[data-action]");
      if (!actionBtn) return;
      const action = actionBtn.dataset.action;
      if (action === "toggle-hidden") {
        toggleChannelHidden(channel);
      } else if (action === "remove") {
        removeChannel(channel);
      } else if (action === "chat") {
        toggleChannelChat(channel, { desiredState: true, scrollIntoView: true });
      } else if (action === "stats") {
        toggleChannelStats(channel, { desiredState: true, scrollIntoView: true });
      }
    }
    let toastTimer = null;
    function triggerSupportEffect(type = "bits", channel) {
      if (!els.effectLayer) return;
      const palette = {
        bits: ["#a855f7", "#6366f1", "#22d3ee"],
        donation: ["#fb7185", "#facc15", "#34d399"],
        follow: ["#38bdf8", "#8b5cf6", "#f472b6"]
      };
      const colors = palette[type] || palette.bits;
      const sparks = type === "donation" ? 45 : 32;
      for (let i = 0; i < sparks; i += 1) {
        const spark = document.createElement("span");
        spark.className = "support-spark";
        spark.style.background = colors[i % colors.length];
        const left = Math.random() * 100;
        const horizontal = (Math.random() * 2 - 1) * 22;
        spark.style.left = left + "vw";
        spark.style.bottom = "-12vh";
        spark.style.setProperty("--spark-x", horizontal + "vw");
        spark.style.animationDelay = (Math.random() * 0.35) + "s";
        els.effectLayer.appendChild(spark);
        spark.addEventListener("animationend", () => spark.remove());
      }
      const messageMap = {
        bits: channel ? `Bits sent to ${channel}!` : "Bits hype activated!",
        donation: "Donation hype deployed!",
        follow: "New follower! Welcome aboard!"
      };
      showToast(messageMap[type] || "Support hype!");
    }
    function showToast(message) {
      if (!els.toast) return;
      els.toast.textContent = message;
      els.toast.classList.add("visible");
      clearTimeout(toastTimer);
      toastTimer = window.setTimeout(() => {
        els.toast.classList.remove("visible");
      }, 3200);
    }
    function handleSupportAction(event) {
      const target = event.target.closest("[data-support-type]");
      if (!target) return;
      event.preventDefault();
      const type = target.dataset.supportType;
      if (type === "bits") {
        const channel = normalizeChannel(target.dataset.channel) || supportConfig.leagueChannel;
        handleSupportForChannel(channel);
      } else if (type === "paypal") {
        const url = target.dataset.url || supportConfig.paypalUrl;
        triggerSupportEffect("donation");
        window.open(url, "_blank", "noopener");
      } else if (type === "effect") {
        triggerSupportEffect(target.dataset.effect || "bits");
      }
    }
    function handleSupportForChannel(channel) {
      const normalized = normalizeChannel(channel);
      triggerSupportEffect("bits", normalized);
      window.open(buildBitsUrl(normalized), "_blank", "noopener");
    }
    async function loadStreamerDirectory() {
      try {
        const q = query(collection(db, "streamers"), where("approved", "==", true));
        const snap = await getDocs(q);
        snap.forEach(docSnap => {
          const data = docSnap.data();
          if (!data || !data.twitchHandle) return;
          const handle = normalizeChannel(data.twitchHandle);
          state.streamerDirectory.set(handle, {
            displayName: data.displayName || data.twitchHandle,
            team: data.team || "",
            bio: data.bio || "",
            avatar: data.avatarUrl && data.avatarUrl.trim() ? data.avatarUrl.trim() : ""
          });
        });
        renderStreamGrid();
        renderChannelManager();
      } catch (err) {
        console.error("Unable to load approved streamers", err);
      }
    }
    let playerStatsPromise = null;
    async function loadPlayerStats() {
      if (!playerStatsPromise) {
        playerStatsPromise = (async () => {
          try {
            const ref = doc(db, "publicStats", "aggregates");
            const snap = await getDoc(ref);
            if (!snap.exists()) return null;
            const data = snap.data() || {};
            const map = new Map();
            (data.playerTotals || []).forEach(entry => {
              if (!entry || !entry.name) return;
              map.set(String(entry.name).toLowerCase(), entry);
              map.set(String(entry.name).replace(/\s+/g, "").toLowerCase(), entry);
            });
            return { map, raw: data };
          } catch (err) {
            console.error("Failed to load player stats", err);
            return null;
          }
        })();
      }
      return playerStatsPromise;
    }
    function resolvePlayerStats(bundle, meta) {
      if (!bundle?.map) return null;
      const candidates = new Set();
      if (meta.displayName) {
        candidates.add(meta.displayName.toLowerCase());
        candidates.add(meta.displayName.replace(/\s+/g, "").toLowerCase());
      }
      candidates.add(meta.channel);
      const teamEntry = teamIndex.get(meta.channel);
      if (teamEntry?.displayName) {
        candidates.add(teamEntry.displayName.toLowerCase());
        candidates.add(teamEntry.displayName.replace(/\s+/g, "").toLowerCase());
      }
      for (const key of candidates) {
        if (bundle.map.has(key)) {
          return bundle.map.get(key);
        }
      }
      return null;
    }
    function buildStatsMarkup(meta, stats) {
      const fragments = [];
      fragments.push('<div class="stats-body">');
      fragments.push(`
        <div class="meta">
          <img src="${escapeHtml(meta.avatar)}" alt="${escapeHtml(meta.displayName)} avatar" onerror="this.src='https://static-cdn.jtvnw.net/jtv_user_pictures/xarth/404_user_70x70.png'">
          <div class="details">
            <strong>${escapeHtml(meta.displayName)}</strong>
            <p>@${escapeHtml(meta.channel)}</p>
            ${meta.team ? `<p>Team: ${escapeHtml(meta.team)}</p>` : ""}
          </div>
        </div>
      `);
      if (meta.bio) {
        fragments.push(`<p class="bio">${escapeHtml(meta.bio)}</p>`);
      }
      if (stats) {
        const totalsConfig = [
          { label: "Matches", key: "matches", decimals: 0 },
          { label: "Minutes Played", key: "time", decimals: 2 },
          { label: "Kills", key: "kills", decimals: 0 },
          { label: "Assists", key: "assists", decimals: 0 },
          { label: "Score", key: "score", decimals: 0 },
          { label: "Captures", key: "captures", decimals: 0 },
          { label: "Returns", key: "returns", decimals: 0 }
        ];
        const totalsValues = {
          matches: toNumber(stats.matches),
          time: toNumber(stats.time),
          kills: toNumber(stats.kills),
          assists: toNumber(stats.assists),
          score: toNumber(stats.score),
          captures: toNumber(stats.captures),
          returns: toNumber(stats.returns)
        };
        const minutesPlayed = totalsValues.time > 0 ? totalsValues.time : 0;
        const perMinuteValues = {
          kpm: minutesPlayed > 0 ? totalsValues.kills / minutesPlayed : 0,
          apm: minutesPlayed > 0 ? totalsValues.assists / minutesPlayed : 0,
          spm: minutesPlayed > 0 ? totalsValues.score / minutesPlayed : 0,
          cpm: minutesPlayed > 0 ? totalsValues.captures / minutesPlayed : 0,
          rpm: minutesPlayed > 0 ? totalsValues.returns / minutesPlayed : 0
        };
        fragments.push('<div class="stats-summary">');
        totalsConfig.forEach(metric => {
          const value = formatNumber(totalsValues[metric.key] ?? 0, metric.decimals);
          fragments.push(`
            <div class="stat">
              <span class="label">${metric.label}</span>
              <span class="value">${value}</span>
            </div>
          `);
        });
        fragments.push('</div>');
        const perMinuteConfig = [
          { label: "Kills / min", key: "kpm" },
          { label: "Assists / min", key: "apm" },
          { label: "Score / min", key: "spm" },
          { label: "Caps / min", key: "cpm" },
          { label: "Returns / min", key: "rpm" }
        ];
        fragments.push('<div class="stats-summary">');
        perMinuteConfig.forEach(metric => {
          const value = formatNumber(perMinuteValues[metric.key] ?? 0, 2);
          fragments.push(`
            <div class="stat">
              <span class="label">${metric.label}</span>
              <span class="value">${value}</span>
            </div>
          `);
        });
        fragments.push('</div>');
      } else {
        fragments.push('<p class="bio">No aggregated stats published for this player yet. Check back after match data is saved.</p>');
      }
      fragments.push(`
        <div class="cta-row">
          <button type="button" data-stats-action="support">Send Support</button>
          <a href="PlayerStats.html" target="_blank" rel="noopener">Full Stats Dashboard</a>
        </div>
      `);
      fragments.push('</div>');
      return fragments.join("");
    }
    function scheduleLiveRefresh() {
      if (state.liveInterval) {
        clearInterval(state.liveInterval);
      }
      state.liveInterval = window.setInterval(() => {
        updateLiveChannels();
      }, 60 * 1000);
    }
    async function updateLiveChannels() {
      state.hasFetchedLiveStreams = true;
      if (!window.twitchOAuth || !window.twitchOAuth.getToken()) {
        state.liveSet = new Set();
        state.lastLiveStreams = [];
        const canSkip = !state.showOnlyLive && Boolean(els.streamGrid?.querySelector(".stream-card"));
        if (canSkip) {
          renderAll({ skipStreamGrid: true });
        } else {
          renderAll();
        }
        return;
      }
      try {
        const streams = await window.twitchOAuth.fetchLiveStreams(state.channels);
        state.lastLiveStreams = streams || [];
        state.liveSet = new Set((streams || []).map(stream => stream.user_login.toLowerCase()));
        state.channels.sort((a, b) => {
          const aLive = state.liveSet.has(a);
          const bLive = state.liveSet.has(b);
          if (aLive === bLive) return a.localeCompare(b);
          return aLive ? -1 : 1;
        });
        persistChannels();
      } catch (err) {
        console.error("Unable to fetch live stream data", err);
      }
      const canSkip = !state.showOnlyLive && Boolean(els.streamGrid?.querySelector(".stream-card"));
      if (canSkip) {
        reorderStreamGrid();
        renderAll({ skipStreamGrid: true });
      } else {
        renderAll();
      }
    }
    function bindEvents() {
      if (els.addChannelForm) {
        els.addChannelForm.addEventListener("submit", handleAddChannel);
      }
      if (els.streamGrid) {
        els.streamGrid.addEventListener("click", handleStreamGridClick);
      }
      if (els.channelManager) {
        els.channelManager.addEventListener("click", handleManagerClick);
      }
      els.liveToggleButtons.forEach(btn => {
        btn.addEventListener("click", toggleLiveMode);
      });
      if (els.showAllButton) {
        els.showAllButton.addEventListener("click", showAllChannels);
      }
      if (els.resetButton) {
        els.resetButton.addEventListener("click", resetToDefaults);
      }
      if (els.addOpenBtn) {
        els.addOpenBtn.addEventListener("click", () => {
          if (els.addChannelInput) {
            els.addChannelInput.focus({ preventScroll: false });
          }
          if (els.controlPanel) {
            els.controlPanel.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        });
      }
      if (els.manageOpenBtn) {
        els.manageOpenBtn.addEventListener("click", () => {
          if (els.controlPanel) {
            els.controlPanel.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        });
      }
      if (els.scrollToGridBtn) {
        els.scrollToGridBtn.addEventListener("click", () => {
          if (els.streamsArea) {
            els.streamsArea.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        });
      }
      if (els.supportActions) {
        els.supportActions.addEventListener("click", handleSupportAction);
      }
      document.addEventListener("keydown", event => {
        if (event.key === "Escape") {
          const openStats = els.streamGrid?.querySelector('[data-role="stats-panel"]:not([hidden])');
          if (openStats) {
            const card = openStats.closest(".stream-card");
            if (card?.dataset.channel) {
              toggleChannelStats(card.dataset.channel, { card, desiredState: false });
              return;
            }
          }
          const openChat = els.streamGrid?.querySelector('[data-role="chat-panel"]:not([hidden])');
          if (openChat) {
            const card = openChat.closest(".stream-card");
            if (card?.dataset.channel) {
              toggleChannelChat(card.dataset.channel, { card, desiredState: false });
            }
          }
        }
      });
      window.addEventListener("resize", updateLiveBackdrop);
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          updateLiveChannels();
        }
      });
    }
    async function init() {
      hydrateTeamIndex();
      initializeState();
      bindEvents();
      await initializeMatchPoll();
      renderAll();
      loadStreamerDirectory();
      updateLiveChannels();
      scheduleLiveRefresh();
      if (window.twitchOAuth) {
        window.twitchOAuth.updateNav();
        if (window.twitchOAuth.initLiveTeamsMenu) {
          window.twitchOAuth.initLiveTeamsMenu();
        }
        if (window.twitchOAuth.initLiveAnnouncementBanner) {
          window.twitchOAuth.initLiveAnnouncementBanner();
        }
      }
    }
    init();

    window.SupportEffects = {
      trigger(type, detail = {}) {
        triggerSupportEffect(type, detail.channel);
        if (detail.message) {
          showToast(detail.message);
        }
      }
    };
    window.addEventListener("tpl:support", event => {
      const detail = event.detail || {};
      triggerSupportEffect(detail.type || "bits", detail.channel);
    });
  </script>
</body>
</html>
