<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tribes Professional League | Spectating Platform</title>
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" href="Tribes Professional League.png" type="image/png">
  <style>
    :root {
      --bg-color: #030712;
      --bg-gradient: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 55%), radial-gradient(circle at 80% 30%, rgba(129, 140, 248, 0.12), transparent 60%), linear-gradient(220deg, rgba(15, 23, 42, 0.88), rgba(2, 6, 23, 0.94));
      --panel-bg: rgba(15, 23, 42, 0.82);
      --surface-glass: rgba(17, 24, 39, 0.65);
      --card-bg: rgba(13, 19, 33, 0.84);
      --text-primary: #e2e8f0;
      --text-muted: #94a3b8;
      --accent: #8b5cf6;
      --accent-strong: #38bdf8;
      --success: #22c55e;
      --danger: #f87171;
      --transition-snappy: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --shadow-xl: 0 32px 65px -25px rgba(46, 78, 155, 0.48);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', 'Segoe UI', sans-serif;
      background: var(--bg-gradient), var(--bg-color);
      color: var(--text-primary);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }

    /* Team Logo Background Pattern */
    #bg-left, #bg-right {
      position: fixed;
      top: 0;
      bottom: 0;
      width: 50%;
      opacity: 0.08;
      background-size: 150px;
      background-repeat: repeat;
      pointer-events: none;
      z-index: -1;
      transition: opacity 0.3s ease;
    }
    #bg-left { left: 0; }
    #bg-right { right: 0; }

    /* Header */
    nav#global-header {
      position: sticky;
      top: 0;
      z-index: 40;
      background: rgba(8, 11, 26, 0.85);
      border-bottom: 1px solid rgba(148, 163, 184, 0.16);
      backdrop-filter: blur(16px);
      padding: 1rem 2rem;
    }

    .header-container {
      max-width: 1440px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 2rem;
    }

    .header-brand {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-brand img {
      height: 46px;
      width: auto;
      border-radius: 0.75rem;
      background: rgba(30, 41, 59, 0.65);
      padding: 0.35rem 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .brand-title {
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      margin: 0;
    }

    .brand-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
      letter-spacing: 0.24em;
      text-transform: uppercase;
      margin: 0;
    }

    .header-nav {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .nav-link {
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      transition: background var(--transition-snappy);
    }

    .nav-link:hover {
      background: rgba(129, 140, 248, 0.2);
    }

    .auth-buttons {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      transition: all var(--transition-snappy);
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(129, 140, 248, 0.3);
      border-color: rgba(129, 140, 248, 0.5);
    }

    .btn-primary {
      background: linear-gradient(135deg, rgba(129, 140, 248, 0.9), rgba(56, 189, 248, 0.9));
      border: none;
      color: #020617;
      font-weight: 700;
    }

    /* Main Container */
    .main-container {
      max-width: 1440px;
      margin: 0 auto;
      padding: 2rem;
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 2rem;
      min-height: calc(100vh - 100px);
    }

    .main-content {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    /* Spectating Section */
    .spectating-section {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }

    .spectating-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .spectating-label {
      background: var(--danger);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .team-select-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .team-select-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
    }

    /* Team Selection Modal */
    .team-selection-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .team-selection-modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 2rem;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .modal-header h3 {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
    }

    .team-selection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .team-option {
      background: var(--surface-glass);
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .team-option:hover {
      border-color: rgba(129, 140, 248, 0.5);
      transform: translateY(-2px);
    }

    .team-option.selected {
      border-color: var(--accent);
      background: rgba(139, 92, 246, 0.2);
    }

    .team-option-logo {
      width: 60px;
      height: 60px;
      margin: 0 auto 0.5rem;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .team-option-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .team-option-name {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }

    .btn-secondary {
      background: rgba(148, 163, 184, 0.2);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Match Display */
    .match-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2rem;
      margin: 1rem 0;
      position: relative;
      min-height: 200px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 12px;
      overflow: hidden;
    }

    .match-display::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.1);
      z-index: 1;
    }

    .match-display.has-background::before {
      background: rgba(0, 0, 0, 0.3);
    }

    .match-display > * {
      position: relative;
      z-index: 2;
    }

    .team-score {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .team-logo {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      overflow: hidden;
      border: 3px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .team-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .team-name {
      font-size: 1.4rem;
      font-weight: 700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      text-align: center;
      color: white;
    }

    .vs-text {
      font-size: 2rem;
      font-weight: 700;
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.3);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    /* Player Tabs */
    .player-tabs {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .team-roster-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .team-roster-header {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
      padding: 0.5rem 1rem;
      background: rgba(139, 92, 246, 0.1);
      border-radius: 6px;
      border-left: 4px solid var(--accent);
    }

    .team-roster-tabs {
      display: flex;
      gap: 0.5rem;
      overflow-x: auto;
      padding-bottom: 0.5rem;
    }

    .team-roster-tabs::-webkit-scrollbar {
      height: 4px;
    }

    .team-roster-tabs::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
    }

    .team-roster-tabs::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 2px;
    }

    .player-tab {
      padding: 0.75rem 1rem;
      background: var(--surface-glass);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text-muted);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-snappy);
      flex-shrink: 0;
      white-space: nowrap;
    }

    .player-tab.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .player-tab:hover:not(.active) {
      background: rgba(129, 140, 248, 0.2);
      border-color: rgba(129, 140, 248, 0.3);
    }

    /* Active Stream */
    .active-stream {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      overflow: hidden;
      aspect-ratio: 16/9;
    }

    .stream-frame {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Sidebar */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .sidebar-section {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .sidebar-section h3 {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--text-primary);
    }

    /* Voting Section */
    .voting-section {
      text-align: center;
    }

    .vote-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    .vote-btn {
      flex: 1;
      padding: 0.75rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: var(--surface-glass);
      color: var(--text-primary);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .vote-btn:hover {
      border-color: var(--accent);
      background: rgba(139, 92, 246, 0.2);
    }

    .vote-btn.voted {
      border-color: var(--success);
      background: rgba(34, 197, 94, 0.2);
      color: var(--success);
    }

    /* Chat Section */
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .streamer-dropdown {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.25rem;
      color: var(--text-primary);
      padding: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
    }

    .streamer-dropdown:focus {
      outline: none;
      border-color: var(--accent);
    }



    /* Match Cards */
    .recent-matches-section {
      margin-top: 2rem;
    }

    .section-title {
      color: var(--accent);
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
      text-align: center;
    }

    .recent-matches-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
    }

    .recent-match-card {
      background: var(--card-bg);
      border-radius: 0.5rem;
      padding: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid rgba(148, 163, 184, 0.1);
      min-height: 60px;
    }

    .match-teams {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .team-info {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      min-width: 0;
    }

    .team-logo-small {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .team-name {
      font-weight: bold;
      color: var(--text-primary);
      font-size: 0.875rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .match-score {
      font-size: 1rem;
      font-weight: bold;
      color: var(--accent);
      white-space: nowrap;
      margin: 0 0.5rem;
    }

    .match-date {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
      flex-shrink: 0;
    }

    /* Twitch Chat Section */
    .twitch-chat-section {
      margin-top: 1rem;
    }

    .twitch-chat-container {
      background: var(--card-bg);
      border-radius: 0.5rem;
      overflow: hidden;
    }

    /* Player Stats Styles */
    .player-stats-section {
      margin-bottom: 1.5rem;
    }

    .player-stats-display {
      padding: 1rem;
    }

    .player-stats-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: var(--surface-glass);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      transition: all var(--transition-snappy);
    }

    .stat-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .stat-rate {
      font-size: 0.9rem;
      color: var(--accent);
      font-weight: 600;
    }

    .stats-chart-container {
      background: var(--surface-glass);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .stats-chart-container canvas {
      max-height: 300px;
    }

    .stats-loading {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
    }

    /* Team Stats Styles */
    .team-stats-section {
      margin-bottom: 1.5rem;
    }

    .team-stats-display {
      background: var(--card-bg);
      border-radius: 1rem;
      padding: 2rem;
      max-width: 900px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .team-stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .team-stats-card {
      background: var(--surface-glass);
      padding: 1.5rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
    }

    .team-stats-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .team-stats-header img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
    }

    .team-stats-header h3 {
      color: var(--text-primary);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .team-metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
    }

    .team-metric {
      text-align: center;
      padding: 1rem;
      background: rgba(148, 163, 184, 0.05);
      border-radius: 0.5rem;
    }

    .team-metric-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--accent-strong);
      margin-bottom: 0.25rem;
    }

    .team-metric-label {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .team-comparison {
      background: var(--surface-glass);
      padding: 1.5rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
      margin-top: 1.5rem;
    }

    .comparison-header {
      text-align: center;
      margin-bottom: 1.5rem;
      color: var(--text-primary);
      font-size: 1.125rem;
      font-weight: 600;
    }

    .comparison-grid {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 1rem;
      align-items: center;
    }

    .comparison-team {
      text-align: center;
    }

    .comparison-vs {
      color: var(--text-muted);
      font-weight: 600;
      font-size: 1.125rem;
    }

    .comparison-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
    }

    .comparison-metric:last-child {
      border-bottom: none;
    }

    .comparison-metric-label {
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .comparison-metric-values {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .comparison-value {
      font-weight: 600;
      min-width: 40px;
      text-align: center;
    }

    .comparison-value.winner {
      color: var(--success);
    }

    .comparison-value.loser {
      color: var(--danger);
    }

    /* Admin Login Form Styles */
    .login-form {
      max-width: 400px;
      margin: 0 auto;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      color: var(--text-primary);
      font-weight: 500;
      margin-bottom: 0.5rem;
    }

    .form-group input[type="email"],
    .form-group input[type="password"] {
      width: 100%;
      padding: 0.75rem;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
    }

    .form-group input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .error-message {
      text-align: center;
      font-size: 0.875rem;
    }

    /* Admin Panel Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .modal-content {
      background: var(--card-bg);
      border-radius: 1rem;
      padding: 0;
      max-width: 600px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .modal-header h2 {
      color: var(--text-primary);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .modal-body {
      padding: 1.5rem;
    }

    .admin-section {
      margin-bottom: 2rem;
    }

    .admin-section h3 {
      color: var(--text-primary);
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .current-match {
      background: var(--surface-glass);
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
      color: var(--text-primary);
    }

    .match-selector {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .team-selector {
      flex: 1;
    }

    .team-selector label {
      display: block;
      color: var(--text-primary);
      font-weight: 500;
      margin-bottom: 0.5rem;
    }

    .form-select {
      width: 100%;
      padding: 0.75rem;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .vs-divider {
      color: var(--text-muted);
      font-weight: 600;
      font-size: 1.125rem;
    }

    .admin-actions {
      display: flex;
      gap: 1rem;
    }

    .live-status {
      background: var(--surface-glass);
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
      color: var(--text-primary);
    }

    /* Live Player Indicators */
    .player-tab.live {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1));
      border: 2px solid rgba(34, 197, 94, 0.6);
      color: #22c55e;
      box-shadow: 0 0 15px rgba(34, 197, 94, 0.4), 0 0 30px rgba(34, 197, 94, 0.2);
      animation: livePulse 2s ease-in-out infinite;
      position: relative;
    }

    .player-tab.live:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.2));
      border-color: rgba(34, 197, 94, 0.8);
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.4);
    }

    .player-tab.live::before {
      content: "🔴";
      margin-right: 0.5rem;
      font-size: 0.75rem;
      animation: liveBlink 1.5s ease-in-out infinite;
    }

    @keyframes livePulse {
      0%, 100% {
        box-shadow: 0 0 15px rgba(34, 197, 94, 0.4), 0 0 30px rgba(34, 197, 94, 0.2);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.4);
        transform: scale(1.02);
      }
    }

    @keyframes liveBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .live-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
      margin-right: 0.5rem;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Poll Management Styles */
    .poll-management {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }
    .current-poll {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      padding: 1rem;
    }
    .current-poll h4 {
      color: var(--text-primary);
      margin-bottom: 1rem;
      font-size: 1rem;
    }
    .poll-actions {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      padding: 1rem;
    }
    .poll-actions h4 {
      color: var(--text-primary);
      margin-bottom: 1rem;
      font-size: 1rem;
    }
    .poll-actions .form-group {
      margin-bottom: 1rem;
    }
    .poll-actions .form-group label {
      display: block;
      color: var(--text-primary);
      font-weight: 500;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
    }
    .poll-actions .form-group input {
      width: 100%;
      padding: 0.75rem;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
    }
    .poll-actions .form-group input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }
    
    .current-poll-content h5 {
      color: var(--text-primary);
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }
    .poll-options {
      margin-bottom: 1rem;
    }
    .poll-option {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      background: rgba(148, 163, 184, 0.1);
      border-radius: 0.25rem;
    }
    .option-number {
      font-weight: 600;
      margin-right: 0.5rem;
      color: var(--accent);
    }
    .option-text {
      color: var(--text-primary);
    }
    .poll-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 1rem;
    }

    /* Footer */
    footer {
      background: var(--card-bg);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding: 2rem;
      text-align: center;
      color: var(--text-muted);
      margin-top: 2rem;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .main-container {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      .sidebar {
        order: -1;
      }
    }

    @media (max-width: 768px) {
      .main-container {
        padding: 1rem;
      }

      .header-container {
        flex-direction: column;
        gap: 1rem;
      }

      .header-nav {
        flex-wrap: wrap;
        justify-content: center;
      }

      .match-display {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }

      .vs-text {
        order: -1;
      }
    }
  </style>
</head>
<body>
  <!-- Team Logo Background Pattern -->
  <div id="bg-left"></div>
  <div id="bg-right"></div>
  
  <!-- Header -->
  <nav id="global-header">
    <div class="header-container">
      <div class="header-brand">
        <img src="Tribes Professional League.png" alt="Tribes Professional League logo" onerror="this.style.display='none'">
        <div>
          <h1 class="brand-title">Tribes Professional League</h1>
          <p class="brand-subtitle">Spectating Platform</p>
        </div>
      </div>
      <div class="header-nav">
        <a href="#" class="nav-link">Main</a>
        <a href="#" class="nav-link">Matches</a>
        <a href="#" class="nav-link">Statistics</a>
        <a href="#" class="nav-link">News</a>
      </div>
      <div class="auth-buttons">
        <button id="admin-login-btn" class="btn btn-secondary" style="display: none;">Admin Login</button>
        <button id="admin-panel-btn" class="btn btn-secondary" style="display: none;">Admin Panel</button>
        <button id="admin-logout-btn" class="btn btn-danger" style="display: none;">Logout</button>
        <button id="twitch-login-btn" class="btn btn-primary">Sign in with Twitch</button>
        <span id="twitch-user" style="display: none; color: var(--text-muted); font-size: 0.9rem;"></span>
      </div>
    </div>
  </nav>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">
      <!-- Spectating Section -->
      <div class="spectating-section">
        <div class="spectating-header">
          <div class="spectating-label">Spectating</div>
        </div>
        

        <div class="match-display" id="match-display">
          <div class="team-score" id="team-a-display">
            <div class="team-logo" id="team-a-logo">
              <img src="images/TeamDPRKLogo3.png" alt="Team A" onerror="this.style.display='none'">
            </div>
            <div class="team-name" id="team-a-name">Team A</div>
          </div>
          <div class="vs-text">VS</div>
          <div class="team-score" id="team-b-display">
            <div class="team-logo" id="team-b-logo">
              <img src="images/TeamDPRKLogo3.png" alt="Team B" onerror="this.style.display='none'">
            </div>
            <div class="team-name" id="team-b-name">Team B</div>
          </div>
        </div>
        
        <div class="match-actions" style="text-align: center; margin-top: 1rem;">
          <button id="show-team-stats-btn" class="btn btn-secondary">View Team Stats</button>
        </div>
      </div>

      <!-- Player Tabs -->
      <div class="player-tabs" id="player-tabs">
        <!-- Player tabs will be populated here -->
      </div>

      <!-- Active Stream -->
      <div class="active-stream">
        <iframe class="stream-frame" id="stream-frame" src="https://player.twitch.tv/?channel=tribesprofessionalleague&autoplay=false" allowfullscreen></iframe>
      </div>

      <!-- Player Stats Section -->
      <div class="player-stats-section" id="player-stats-section" style="display: none;">
        <div class="spectating-section">
          <div class="spectating-header">
            <div class="spectating-label">Player Statistics</div>
            <button class="team-select-btn" id="close-stats-btn">Close Stats</button>
        </div>
          <div id="player-stats-content">
            <div class="stats-loading">Loading player statistics...</div>
          </div>
        </div>
      </div>

      <!-- Team Stats Section -->
      <div class="team-stats-section" id="team-stats-section" style="display: none;">
        <div class="spectating-section">
          <div class="spectating-header">
            <div class="spectating-label">Team Statistics</div>
            <button class="team-select-btn" id="close-team-stats-btn">Close Stats</button>
          </div>
          <div id="team-stats-content">
            <div class="stats-loading">Loading team statistics...</div>
          </div>
        </div>
      </div>

      <!-- Admin Login Modal -->
      <div id="admin-login-modal" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Admin Login</h2>
            <button id="close-admin-login-modal" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            <div class="admin-section">
              <div class="login-form">
                <div class="form-group">
                  <label for="admin-email">Email:</label>
                  <input id="admin-email" type="email" class="form-select" placeholder="Enter admin email">
                </div>
                <div class="form-group">
                  <label for="admin-password">Password:</label>
                  <input id="admin-password" type="password" class="form-select" placeholder="Enter password">
                </div>
                <div class="admin-actions">
                  <button id="admin-login-submit" class="btn btn-primary">Login</button>
                  <button id="cancel-admin-login" class="btn btn-secondary">Cancel</button>
                </div>
                <div id="admin-login-error" class="error-message" style="display: none; color: var(--danger); margin-top: 1rem;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Admin Panel Modal -->
      <div id="admin-modal" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Admin Panel - Set Active Match</h2>
            <button id="close-admin-modal" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            <div class="admin-section">
              <h3>Current Active Match</h3>
              <div id="current-match-display" class="current-match">
                <p>No active match set</p>
              </div>
            </div>
            
            <div class="admin-section">
              <h3>Set New Active Match</h3>
              <div class="match-selector">
                <div class="team-selector">
                  <label for="admin-team-a">Team A:</label>
                  <select id="admin-team-a" class="form-select">
                    <option value="">Select Team A</option>
                  </select>
                </div>
                <div class="vs-divider">VS</div>
                <div class="team-selector">
                  <label for="admin-team-b">Team B:</label>
                  <select id="admin-team-b" class="form-select">
                    <option value="">Select Team B</option>
                  </select>
                </div>
              </div>
              <div class="admin-actions">
                <button id="set-active-match" class="btn btn-primary">Set Active Match</button>
                <button id="clear-active-match" class="btn btn-danger">Clear Match</button>
              </div>
            </div>
            
            <div class="admin-section">
              <h3>Live Player Status</h3>
              <div id="live-players-status" class="live-status">
                <p>Checking live status...</p>
              </div>
            </div>
            
            <div class="admin-section">
              <h3>Vote Polls</h3>
              <div class="poll-management">
                <div class="current-poll">
                  <h4>Current Poll</h4>
                  <div id="current-poll-display">
                    <p>No active poll</p>
                  </div>
                </div>
                
                <div class="poll-actions">
                  <h4>Create/Edit Poll</h4>
                  <div class="form-group">
                    <label for="poll-question">Poll Question:</label>
                    <input id="poll-question" type="text" class="form-select" placeholder="Enter poll question">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-1">Option 1:</label>
                    <input id="poll-option-1" type="text" class="form-select" placeholder="First option">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-2">Option 2:</label>
                    <input id="poll-option-2" type="text" class="form-select" placeholder="Second option">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-3">Option 3 (optional):</label>
                    <input id="poll-option-3" type="text" class="form-select" placeholder="Third option">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-4">Option 4 (optional):</label>
                    <input id="poll-option-4" type="text" class="form-select" placeholder="Fourth option">
                  </div>
                  <div class="admin-actions">
                    <button id="save-poll" class="btn btn-primary">Save Poll</button>
                    <button id="clear-poll" class="btn btn-danger">Clear Poll</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Recent Matches -->
      <div class="recent-matches-section">
        <h3 class="section-title">Recent Matches</h3>
        <div class="recent-matches-grid" id="recent-matches-grid">
          <!-- Recent matches will be populated here -->
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Voting Section -->
      <div class="sidebar-section voting-section">
        <h3>Vote for Winner</h3>
        <div class="vote-buttons">
          <button class="vote-btn" id="vote-team-a">Team A</button>
          <button class="vote-btn" id="vote-team-b">Team B</button>
        </div>
      </div>

      <!-- Twitch Chat Section -->
      <div class="sidebar-section chat-section">
        <div class="chat-header">
          <h3>Live Chat</h3>
          <select id="streamer-select" class="streamer-dropdown">
            <option value="tribesprofessionalleague">TPL Main Chat</option>
          </select>
        </div>
        <div class="twitch-chat-container">
          <div class="chat-loading" style="display: flex; align-items: center; justify-content: center; height: 500px; background: var(--surface-glass); border-radius: 0.5rem; color: var(--text-muted);">
            <div class="text-center">
              <div class="animate-spin inline-block w-6 h-6 border-2 border-blue-600 border-t-transparent rounded-full mb-2"></div>
              <div>Connecting to Chat...</div>
            </div>
          </div>
          <iframe id="twitch-chat-iframe" src="about:blank" style="width: 100%; height: 500px; border: none; border-radius: 0.5rem; display: none;"></iframe>
        </div>
      </div>

    </div>
  </div>

  <!-- Footer -->
  <footer>
    <p>&copy; 2024 Tribes Professional League. All rights reserved.</p>
  </footer>

  <!-- Load OAuth functionality -->
  <script src="oauth.js"></script>
  <!-- Load Chart.js for player stats -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  
  <!-- Confetti.js for vote celebrations -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, getDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB_ksHlcP2P9cT5jbo2IAGxbQ4zgEODkyM",
      authDomain: "team-sign-up-b5646.firebaseapp.com",
      projectId: "team-sign-up-b5646",
      storageBucket: "team-sign-up-b5646.firebasestorage.app",
      messagingSenderId: "951471144681",
      appId: "1:951471144681:web:a2458675ce73ce9ad9ba78"
    };

    const firebaseApp = initializeApp(firebaseConfig);
    const db = getFirestore(firebaseApp);
    const auth = getAuth();
    
    // Admin UIDs from LeagueManager.html
    const ADMIN_UIDS = [
      'DkBHsCzLK5a9KiX50g0pHJrEqGq2',
      'A2ZV8vziNsXqZkyqHzAB266B9pP2'
    ];

    const TEAM_DATA = {
      'Avalanche': { logo: 'https://github.com/T24085/Team-Avalanche/blob/main/aV!.png?raw=true', name: 'Avalanche', folder: 'AV!' },
      'ePidemic': { logo: 'https://github.com/T24085/Team-ePi/blob/main/ePi.png?raw=true', name: 'ePidemic', folder: 'EPI' },
      'DPRK': { logo: 'https://github.com/T24085/TeamDPRK/blob/main/TeamDPRKLogo3.png?raw=true', name: 'DPRK', folder: 'DPRK' },
      'Zen': { logo: 'https://github.com/T24085/Team-Zen/blob/main/Zenlogo.png?raw=true', name: 'Zen', folder: 'ZEN' },
      'TXM': { logo: 'https://github.com/T24085/Team-TXM/blob/main/TXM.png?raw=true', name: 'TXM', folder: 'TXM' },
      'FPS': { logo: 'https://github.com/T24085/Team-FPS/blob/main/FPSlogo.png?raw=true', name: 'Flag Pole Smokers', folder: 'FPS' },
      'FT': { logo: 'https://github.com/T24085/Team-FT/blob/main/FTlogo.png?raw=true', name: 'Flying Tractors', folder: 'FT' },
      'HoE': { logo: 'https://github.com/T24085/Team-HOE/blob/main/HoE.png?raw=true', name: 'Hegemony of Euros', folder: 'HOE' },
      'Magic': { logo: 'https://github.com/T24085/Team-Magic/blob/main/Magic.png?raw=true', name: 'Magic', folder: 'WIZ' },
      'DeadStop': { logo: 'DeadStopLogo.png', name: 'DeadStop', folder: 'DS' },
      'UE': { logo: 'https://github.com/T24085/Team-UE/blob/main/UE.png?raw=true', name: 'Unhandled Exception', folder: 'UE' },
      'KTL': { logo: 'https://github.com/T24085/Team-KTL/blob/main/KTLlogo.png?raw=true', name: 'KTL', folder: 'KTL' },
      'Null': { logo: 'https://github.com/T24085/Team-Null/blob/main/NullLogo.png?raw=true', name: 'null', folder: 'Null' },
      'ToxicAimers': { logo: 'https://github.com/T24085/Team-Toxic-Aimers/blob/main/ToxicAimersLogo.png?raw=true', name: 'Toxic Aimers', folder: 'TA' }
    };

    let selectedTeams = { teamA: null, teamB: null };
    let teamRosters = {};

    document.addEventListener('DOMContentLoaded', function() {
      initializePollManagement();
      initializeVoting();
      
      // Load active match first, then team rosters
      loadActiveMatch().then(() => {
      loadTeamRosters();
    });
      
      // Load current poll for main page
      loadCurrentPollForMainPage();
      
      // Set up real-time poll updates
      setInterval(loadCurrentPollForMainPage, 5000); // Update every 5 seconds
      
      initializeTwitchPlayer();
      initializePlayerStats();
      initializeTeamStats();
      loadRecentMatches();
      initializeTwitchChat();
      
      // Initialize Twitch OAuth functionality
      if (window.twitchOAuth) {
        window.twitchOAuth.updateNav();
      } else {
        // Handle non-authenticated users
        console.log('Twitch OAuth not available - showing guest experience');
        // Delay to ensure page is fully loaded
        setTimeout(showGuestExperience, 1000);
      }
      
      // Set up admin system
      setupAdminSystem();
      
      // Set up Firebase Auth state listener
      onAuthStateChanged(auth, (user) => {
        if (user && ADMIN_UIDS.includes(user.uid)) {
          isAdmin = true;
          console.log('Admin user logged in:', user.email);
        } else {
          isAdmin = false;
          if (user) {
            console.log('Non-admin user logged in:', user.email);
            signOut(auth); // Sign out non-admin users
          }
        }
        checkAdminStatus();
      });
      
      // Set up periodic live player checks
      setInterval(() => {
        updateLivePlayerIndicators();
      }, 30000); // Check every 30 seconds
    });

    // Set up admin system event listeners
    function setupAdminSystem() {
      // Admin login button
      document.getElementById('admin-login-btn').addEventListener('click', showAdminLogin);

      // Admin panel button
      document.getElementById('admin-panel-btn').addEventListener('click', showAdminPanel);

      // Admin logout button
      document.getElementById('admin-logout-btn').addEventListener('click', () => {
        signOut(auth);
      });

      // Admin login form
      document.getElementById('admin-login-submit').addEventListener('click', handleAdminLogin);
      document.getElementById('cancel-admin-login').addEventListener('click', hideAdminLogin);

      // Close admin login modal
      document.getElementById('close-admin-login-modal').addEventListener('click', hideAdminLogin);

      // Close admin panel modal
      document.getElementById('close-admin-modal').addEventListener('click', hideAdminPanel);

      // Close modals when clicking outside
      document.getElementById('admin-login-modal').addEventListener('click', (e) => {
        if (e.target.id === 'admin-login-modal') {
          hideAdminLogin();
        }
      });

      document.getElementById('admin-modal').addEventListener('click', (e) => {
        if (e.target.id === 'admin-modal') {
          hideAdminPanel();
        }
      });

      // Handle Enter key in login form
      document.getElementById('admin-password').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          handleAdminLogin();
        }
      });
    }

    // Show admin login modal
    function showAdminLogin() {
      document.getElementById('admin-login-modal').style.display = 'flex';
      document.getElementById('admin-email').focus();
    }

    // Hide admin login modal
    function hideAdminLogin() {
      document.getElementById('admin-login-modal').style.display = 'none';
      document.getElementById('admin-email').value = '';
      document.getElementById('admin-password').value = '';
      document.getElementById('admin-login-error').style.display = 'none';
    }

    // Handle admin login
    async function handleAdminLogin() {
      const email = document.getElementById('admin-email').value;
      const password = document.getElementById('admin-password').value;
      const errorDiv = document.getElementById('admin-login-error');

      if (!email || !password) {
        errorDiv.textContent = 'Please enter both email and password';
        errorDiv.style.display = 'block';
        return;
      }

      try {
        await signInWithEmailAndPassword(auth, email, password);
        hideAdminLogin();
      } catch (error) {
        console.error('Admin login error:', error);
        errorDiv.textContent = error.message;
        errorDiv.style.display = 'block';
      }
    }

    async function loadTeamRosters() {
      try {
        const teamsRef = collection(db, 'teams');
        const teamsSnapshot = await getDocs(teamsRef);
        
        teamsSnapshot.forEach(doc => {
          const teamData = doc.data();
          if (teamData.teamName) {
            // Load complete roster including all players and bench players
            const completeRoster = [];
            
            // Add main roster players
            if (teamData.players && Array.isArray(teamData.players)) {
              completeRoster.push(...teamData.players);
            }
            
            // Add bench players if they exist
            if (teamData.benchPlayers && Array.isArray(teamData.benchPlayers)) {
              completeRoster.push(...teamData.benchPlayers);
            }
            
            // Add any additional roster data
            if (teamData.roster && Array.isArray(teamData.roster)) {
              completeRoster.push(...teamData.roster);
            }
            
            teamRosters[teamData.teamName] = completeRoster;
          }
        });
        
        console.log('Loaded complete team rosters:', teamRosters);
        
        // Update player tabs if teams are selected
        if (selectedTeams.teamA && selectedTeams.teamB) {
          updatePlayerTabs();
        }
      } catch (error) {
        console.error('Error loading team rosters:', error);
      }
    }

    // Poll Management functionality
    let currentPoll = null;

    async function loadCurrentPoll() {
      try {
        const docRef = doc(db, 'admin', 'currentPoll');
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
          currentPoll = docSnap.data();
          updateCurrentPollDisplay();
          populatePollForm();
        } else {
          currentPoll = null;
          updateCurrentPollDisplay();
        }
      } catch (error) {
        console.error('Error loading current poll:', error);
      }
    }

    function updateCurrentPollDisplay() {
      const display = document.getElementById('current-poll-display');
      if (!display) return;

      if (currentPoll) {
        display.innerHTML = `
          <div class="current-poll-content">
            <h5>${currentPoll.question}</h5>
            <div class="poll-options">
              ${currentPoll.options.map((option, index) => `
                <div class="poll-option">
                  <span class="option-number">${index + 1}.</span>
                  <span class="option-text">${option}</span>
          </div>
              `).join('')}
            </div>
            <p class="poll-meta">Created: ${new Date(currentPoll.createdAt?.toDate?.() || currentPoll.createdAt).toLocaleString()}</p>
          </div>
        `;
      } else {
        display.innerHTML = '<p>No active poll</p>';
      }
    }

    function populatePollForm() {
      if (currentPoll) {
        document.getElementById('poll-question').value = currentPoll.question || '';
        document.getElementById('poll-option-1').value = currentPoll.options?.[0] || '';
        document.getElementById('poll-option-2').value = currentPoll.options?.[1] || '';
        document.getElementById('poll-option-3').value = currentPoll.options?.[2] || '';
        document.getElementById('poll-option-4').value = currentPoll.options?.[3] || '';
      }
    }

    async function savePoll() {
      try {
        const question = document.getElementById('poll-question').value.trim();
        const option1 = document.getElementById('poll-option-1').value.trim();
        const option2 = document.getElementById('poll-option-2').value.trim();
        const option3 = document.getElementById('poll-option-3').value.trim();
        const option4 = document.getElementById('poll-option-4').value.trim();

        if (!question || !option1 || !option2) {
          alert('Please fill in the question and at least two options.');
          return;
        }

        const options = [option1, option2];
        if (option3) options.push(option3);
        if (option4) options.push(option4);

        const pollData = {
          question,
          options,
          createdAt: serverTimestamp(),
          votes: {} // Initialize empty votes object
        };

        console.log('Attempting to save poll:', pollData);
        console.log('Current user:', auth.currentUser);
        console.log('Is admin:', isAdmin);

        await setDoc(doc(db, 'admin', 'currentPoll'), pollData);
        
        currentPoll = pollData;
        updateCurrentPollDisplay();
        // Also update the main page poll display
        updateMainPagePollDisplay(pollData);
        alert('Poll saved successfully!');
      } catch (error) {
        console.error('Error saving poll:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        alert(`Failed to save poll: ${error.message}`);
      }
    }

    async function clearPoll() {
      try {
        await setDoc(doc(db, 'admin', 'currentPoll'), {});
        currentPoll = null;
        updateCurrentPollDisplay();
        // Also update the main page poll display
        updateMainPagePollDisplay(null);
        
        // Clear form
        document.getElementById('poll-question').value = '';
        document.getElementById('poll-option-1').value = '';
        document.getElementById('poll-option-2').value = '';
        document.getElementById('poll-option-3').value = '';
        document.getElementById('poll-option-4').value = '';
        
        alert('Poll cleared successfully!');
      } catch (error) {
        console.error('Error clearing poll:', error);
        alert('Failed to clear poll. Please try again.');
      }
    }

    function initializePollManagement() {
      // Load current poll
      loadCurrentPoll();

      // Set up event listeners
      const saveBtn = document.getElementById('save-poll');
      const clearBtn = document.getElementById('clear-poll');

      if (saveBtn) {
        saveBtn.addEventListener('click', savePoll);
      }

      if (clearBtn) {
        clearBtn.addEventListener('click', clearPoll);
      }
    }

    // Load current poll for main page display
    async function loadCurrentPollForMainPage() {
      try {
        const docRef = doc(db, 'admin', 'currentPoll');
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
          const pollData = docSnap.data();
          updateMainPagePollDisplay(pollData);
          } else {
          updateMainPagePollDisplay(null);
        }
      } catch (error) {
        console.error('Error loading current poll for main page:', error);
        updateMainPagePollDisplay(null);
      }
    }

    // Update the main page poll display
    function updateMainPagePollDisplay(pollData) {
      const pollSection = document.querySelector('.voting-section');
      if (!pollSection) return;

      if (pollData && pollData.question && pollData.options) {
        // Update the poll question
        const pollTitle = pollSection.querySelector('h3');
        if (pollTitle) {
          pollTitle.textContent = pollData.question;
        }

        // Update the voting buttons with results
        const voteButtons = pollSection.querySelectorAll('.vote-btn');
        const votes = pollData.votes || {};
        const totalVotes = Object.keys(votes).length;

        console.log('Poll data:', pollData);
        console.log('Votes object:', votes);
        console.log('Total votes:', totalVotes);

        pollData.options.forEach((option, index) => {
          if (voteButtons[index]) {
            // Count votes for this option - votes object has userId as key, optionIndex as value
            const optionVotes = Object.values(votes).filter(vote => {
              // Handle both string and number vote values
              const voteValue = typeof vote === 'string' ? parseInt(vote) : vote;
              return voteValue === index;
            }).length;
            
            const percentage = totalVotes > 0 ? Math.round((optionVotes / totalVotes) * 100) : 0;
            
            console.log(`Option ${index} (${option}): ${optionVotes} votes (${percentage}%)`);
            
            voteButtons[index].textContent = `${option} (${optionVotes} votes - ${percentage}%)`;
            voteButtons[index].style.display = 'block';
            
            // Add visual indicator for vote percentage
            voteButtons[index].style.background = `linear-gradient(90deg, var(--accent) ${percentage}%, rgba(148, 163, 184, 0.2) ${percentage}%)`;
          }
        });

        // Hide unused buttons
        for (let i = pollData.options.length; i < voteButtons.length; i++) {
          if (voteButtons[i]) {
            voteButtons[i].style.display = 'none';
          }
        }

        // Add total votes display
        let totalVotesDisplay = pollSection.querySelector('.total-votes');
        if (!totalVotesDisplay) {
          totalVotesDisplay = document.createElement('div');
          totalVotesDisplay.className = 'total-votes';
          totalVotesDisplay.style.cssText = 'text-align: center; margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted);';
          pollSection.appendChild(totalVotesDisplay);
        }
        totalVotesDisplay.textContent = `Total Votes: ${totalVotes}`;

        console.log('Updated main page poll display:', pollData);
      } else {
        // Show default voting
        const pollTitle = pollSection.querySelector('h3');
        if (pollTitle) {
          pollTitle.textContent = 'Vote for Winner';
        }

        const voteButtons = pollSection.querySelectorAll('.vote-btn');
        if (voteButtons[0]) voteButtons[0].textContent = 'Team A';
        if (voteButtons[1]) voteButtons[1].textContent = 'Team B';
        if (voteButtons[0]) voteButtons[0].style.display = 'block';
        if (voteButtons[1]) voteButtons[1].style.display = 'block';
        
        // Reset button styles
        voteButtons.forEach(btn => {
          btn.style.background = '';
        });

        // Hide additional buttons
        for (let i = 2; i < voteButtons.length; i++) {
          if (voteButtons[i]) {
            voteButtons[i].style.display = 'none';
          }
        }

        // Remove total votes display
        const totalVotesDisplay = pollSection.querySelector('.total-votes');
        if (totalVotesDisplay) {
          totalVotesDisplay.remove();
        }
      }
    }

    function updateMatchDisplay() {
      const teamA = TEAM_DATA[selectedTeams.teamA];
      const teamB = TEAM_DATA[selectedTeams.teamB];
      const matchDisplay = document.getElementById('match-display');
      
      if (teamA) {
        document.getElementById('team-a-name').textContent = teamA.name;
        document.getElementById('team-a-logo').innerHTML = `<img src="${teamA.logo}" alt="${teamA.name}" onerror="this.style.display='none'">`;
      }
      
      if (teamB) {
        document.getElementById('team-b-name').textContent = teamB.name;
        document.getElementById('team-b-logo').innerHTML = `<img src="${teamB.logo}" alt="${teamB.name}" onerror="this.style.display='none'">`;
      }
      
      // Set background image based on team matchup
      if (teamA && teamB) {
        loadMatchupImageWithFallbacks(teamA.folder, teamB.folder, matchDisplay);
        
        // Set team logo background pattern like in ScrimWatcher
      console.log('Setting background images:', teamA.logo, teamB.logo);
        document.getElementById('bg-left').style.backgroundImage = `url(${teamA.logo})`;
        document.getElementById('bg-right').style.backgroundImage = `url(${teamB.logo})`;
      console.log('Background images set successfully');
      } else {
        // Clear background patterns if no teams selected
        document.getElementById('bg-left').style.backgroundImage = '';
        document.getElementById('bg-right').style.backgroundImage = '';
      }
    }
    
    function loadMatchupImageWithFallbacks(teamAFolder, teamBFolder, matchDisplay) {
      console.log('Loading matchup image for:', teamAFolder, 'vs', teamBFolder);
      
      // Try different naming conventions with GitHub raw links
      const possiblePaths = [
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamAFolder}/${teamAFolder}vs${teamBFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamBFolder}/${teamBFolder}vs${teamAFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamAFolder}/${teamAFolder}Vs${teamBFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamBFolder}/${teamBFolder}Vs${teamAFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamAFolder}/${teamAFolder}VS${teamBFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamBFolder}/${teamBFolder}VS${teamAFolder}.png`,
        // Try with exact case matching for known files
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/DPRK/DPRKvsZen.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/ZEN/DPRKvsZen.png`
      ];
      
      console.log('All possible paths:', possiblePaths);
      
      let currentIndex = 0;
      
      function tryNextPath() {
        if (currentIndex >= possiblePaths.length) {
          console.log('All matchup image paths failed, removing background');
          matchDisplay.style.backgroundImage = 'none';
          return;
        }
        
        const currentPath = possiblePaths[currentIndex];
        console.log(`Trying matchup image path ${currentIndex + 1}/${possiblePaths.length}:`, currentPath);
        
        const testImage = new Image();
        
        testImage.onload = function() {
          console.log('✅ Matchup image loaded successfully:', currentPath);
          matchDisplay.style.backgroundImage = `url(${currentPath})`;
          matchDisplay.style.backgroundSize = 'cover';
          matchDisplay.style.backgroundPosition = 'center';
          matchDisplay.style.backgroundRepeat = 'no-repeat';
          matchDisplay.classList.add('has-background');
        };
        
        testImage.onerror = function() {
          console.log('❌ Failed to load:', currentPath);
          currentIndex++;
          tryNextPath();
        };
        
        testImage.src = currentPath;
      }
      
      tryNextPath();
    }

    function updatePlayerTabs() {
      const playerTabs = document.querySelector('.player-tabs');
      const teamA = selectedTeams.teamA;
      const teamB = selectedTeams.teamB;
      
      if (!teamA || !teamB) return;
      
      const teamARoster = teamRosters[teamA] || [];
      const teamBRoster = teamRosters[teamB] || [];
      
      // Filter out unnamed players (those with generic names like "Player 8")
      const filterValidPlayers = (roster) => {
        return roster.filter(player => {
          const name = player.name || player.displayName || '';
          // Filter out generic player names and empty names
          return name && 
                 !name.toLowerCase().includes('player') && 
                 name.trim() !== '' &&
                 !name.match(/^player\s*\d+$/i);
        });
      };
      
      const validTeamARoster = filterValidPlayers(teamARoster);
      const validTeamBRoster = filterValidPlayers(teamBRoster);
      
      // Clear existing tabs
      playerTabs.innerHTML = '';
      
      // Add Team A section
      if (validTeamARoster.length > 0) {
        const teamASection = document.createElement('div');
        teamASection.className = 'team-roster-section';
        
        const teamAHeader = document.createElement('div');
        teamAHeader.className = 'team-roster-header';
        teamAHeader.textContent = `${TEAM_DATA[teamA].name} Players`;
        teamASection.appendChild(teamAHeader);
        
        const teamATabs = document.createElement('div');
        teamATabs.className = 'team-roster-tabs';
        
        validTeamARoster.forEach((player, index) => {
          const tab = document.createElement('button');
          tab.className = `player-tab ${index === 0 ? 'active' : ''}`;
          tab.textContent = player.name || player.displayName;
          tab.dataset.team = 'A';
          tab.dataset.playerIndex = teamARoster.indexOf(player);
          teamATabs.appendChild(tab);
        });
        
        teamASection.appendChild(teamATabs);
        playerTabs.appendChild(teamASection);
      }
      
      // Add Team B section
      if (validTeamBRoster.length > 0) {
        const teamBSection = document.createElement('div');
        teamBSection.className = 'team-roster-section';
        
        const teamBHeader = document.createElement('div');
        teamBHeader.className = 'team-roster-header';
        teamBHeader.textContent = `${TEAM_DATA[teamB].name} Players`;
        teamBSection.appendChild(teamBHeader);
        
        const teamBTabs = document.createElement('div');
        teamBTabs.className = 'team-roster-tabs';
        
        validTeamBRoster.forEach((player, index) => {
          const tab = document.createElement('button');
          tab.className = 'player-tab';
          tab.textContent = player.name || player.displayName;
          tab.dataset.team = 'B';
          tab.dataset.playerIndex = teamBRoster.indexOf(player);
          teamBTabs.appendChild(tab);
        });
        
        teamBSection.appendChild(teamBTabs);
        playerTabs.appendChild(teamBSection);
      }
      
      // Add match stats tab
      const statsSection = document.createElement('div');
      statsSection.className = 'team-roster-section';
      
      const statsHeader = document.createElement('div');
      statsHeader.className = 'team-roster-header';
      statsHeader.textContent = 'Match Information';
      statsSection.appendChild(statsHeader);
      
      // Match Stats button removed as requested
      
      // Re-initialize tab functionality
      initializePlayerTabs();
      
      // Update live indicators after teams are loaded
      setTimeout(() => {
        updateLivePlayerIndicators();
      }, 2000); // Give time for Twitch data to load
    }

    function initializePlayerTabs() {
      const playerTabs = document.querySelectorAll('.player-tab');
      playerTabs.forEach(tab => {
        tab.addEventListener('click', function() {
          // Remove active class from all tabs
          playerTabs.forEach(t => t.classList.remove('active'));
          // Add active class to clicked tab
          this.classList.add('active');
          
          // Update stream and show stats if it's a player tab
          if (this.dataset.team && this.dataset.playerIndex !== undefined) {
            updateStreamForPlayer(this);
            showPlayerStatsForTab(this);
          }
        });
      });
    }

    function showPlayerStatsForTab(tab) {
      const team = tab.dataset.team;
      const playerIndex = tab.dataset.playerIndex;
      const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
      const roster = teamRosters[teamKey] || [];
      const player = roster[playerIndex];
      
      if (player) {
        const playerName = player.name || player.displayName;
        if (playerName) {
          console.log('Showing stats for player:', playerName);
          showPlayerStats(playerName);
        }
      }
    }

    // Name mapping for players where database name doesn't match oauth.js name
    const PLAYER_NAME_MAPPING = {
      'Panda': 'Pandora',
      'Glem': 'Glem',
      'CheezeCaek': 'CheezeCaek',
      'Nemesis': 'Nemesis',
      'Jive': 'Jive',
      'Howsya': 'Howsya',
      'Prizzo': 'Prizzo',
      'Rhino': 'Rhino',
      'LightningMcMeme': 'LightningMcMeme',
      'Radishblue': 'Radishblue'
    };

    function getTwitchHandleForPlayer(player) {
      // First try to get the handle from the player object
      let twitchHandle = player.twitchHandle || player.twitch || player.twitchChannel || player.channel;
      
      // If no handle found, try to map the name and look it up in oauth.js
      if (!twitchHandle && player.name) {
        const mappedName = PLAYER_NAME_MAPPING[player.name] || player.name;
        
        // Look up in oauth.js TEAM_STREAMS data
        if (window.twitchOAuth && window.twitchOAuth.TEAM_STREAMS) {
          for (const [teamName, streams] of Object.entries(window.twitchOAuth.TEAM_STREAMS)) {
            const streamer = streams.find(s => s.name === mappedName);
            if (streamer) {
              // Extract Twitch handle from URL
              const match = streamer.url.match(/twitch\.tv\/([^/?]+)/i);
              if (match) {
                twitchHandle = match[1];
                console.log(`Found Twitch handle for ${player.name} (mapped to ${mappedName}): ${twitchHandle}`);
                break;
              }
            }
          }
        }
      }
      
      return twitchHandle;
    }

    function updateStreamForPlayer(selectedTab) {
      const team = selectedTab.dataset.team;
      const playerIndex = selectedTab.dataset.playerIndex;
      
      if (team && playerIndex !== undefined) {
        const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
        const roster = teamRosters[teamKey] || [];
        const player = roster[playerIndex];
        
        if (player) {
          // Use the new function to get Twitch handle
          const twitchHandle = getTwitchHandleForPlayer(player);
          
          if (twitchHandle) {
            const streamFrame = document.getElementById('stream-frame');
            if (streamFrame && streamFrame.tagName === 'IFRAME') {
              const parentDomain = window.location.hostname;
              // Use the same format as TribesScrimWatcher
              streamFrame.src = `https://player.twitch.tv/?channel=${encodeURIComponent(twitchHandle)}&parent=${parentDomain}&autoplay=false`;
              console.log(`Loading stream for ${player.name}: ${twitchHandle}`);
            } else {
              console.error('Stream frame element not found or was replaced! Attempting to restore...');
              // Try to restore the iframe if it was replaced
              restoreStreamFrame();
              // Try again after a short delay
              setTimeout(() => {
                const newStreamFrame = document.getElementById('stream-frame');
                if (newStreamFrame && newStreamFrame.tagName === 'IFRAME') {
                  const parentDomain = window.location.hostname;
                  newStreamFrame.src = `https://player.twitch.tv/?channel=${encodeURIComponent(twitchHandle)}&parent=${parentDomain}&autoplay=false`;
                  console.log(`Loading stream for ${player.name} after restore: ${twitchHandle}`);
                }
              }, 200);
            }
          } else {
            console.log('No Twitch handle found for player:', player);
          }
        }
      }

      // Update live indicators and streamer chat after a short delay to allow Twitch data to load
      setTimeout(() => {
        updateLivePlayerIndicators();
        updateStreamerChat();
        updateStreamerDropdown();
      }, 1000);
    }

    function initializeChat() {
      const chatInput = document.querySelector('.chat-input');
      const chatSend = document.querySelector('.chat-send');
      const chatMessages = document.querySelector('.chat-messages');
      // Note: streamer chat now uses iframe instead of messages div
      const chatTabs = document.querySelectorAll('.chat-tab');
      const chatContainers = document.querySelectorAll('.chat-container');

      // Chat tab switching
      chatTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabType = tab.dataset.tab;
          
          // Update active tab
          chatTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Update active container
          chatContainers.forEach(container => container.classList.remove('active'));
          document.getElementById(`${tabType}-chat`).classList.add('active');
        });
      });

      function addMessage(message, isUser = false, chatType = 'main') {
        // Only handle main chat messages, streamer chat uses iframe
        if (chatType === 'main') {
        const messageDiv = document.createElement('div');
        messageDiv.style.marginBottom = '0.5rem';
        messageDiv.style.padding = '0.5rem';
        messageDiv.style.borderRadius = '4px';
        messageDiv.style.backgroundColor = isUser ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255, 255, 255, 0.05)';
        messageDiv.textContent = message;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }

      // Main chat functionality
      chatSend.addEventListener('click', () => {
        const message = chatInput.value.trim();
        if (message) {
          addMessage(`You: ${message}`, true, 'main');
          chatInput.value = '';
          
          // Simulate response
          setTimeout(() => {
            addMessage('ChatBot: Thanks for the message!', false, 'main');
          }, 1000);
        }
      });

      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          chatSend.click();
        }
      });

      // Streamer chat functionality
      const streamerChatInput = document.getElementById('streamer-chat-input');
      const streamerChatSend = document.getElementById('streamer-chat-send');
      
      if (streamerChatSend) {
        streamerChatSend.addEventListener('click', () => {
          const message = streamerChatInput.value.trim();
          if (message) {
            // In a real implementation, this would send the message to Twitch chat
            // For now, we'll just show a confirmation
            alert(`Message sent to streamer chat: "${message}"`);
            streamerChatInput.value = '';
          }
        });
      }

      if (streamerChatInput) {
        streamerChatInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            streamerChatSend.click();
          }
        });
      }

      // Simulate some initial messages
      setTimeout(() => {
        addMessage('Welcome to the chat!', false, 'main');
        addMessage('Match starting soon!', false, 'main');
      }, 1000);

      // Streamer chat functionality
      function updateStreamerChat() {
        // Check if any players are live and update streamer chat
        if (window.twitchOAuth && window.twitchOAuth.liveStreams) {
          const liveStreams = window.twitchOAuth.liveStreams;
          if (liveStreams.length > 0) {
            const currentStreamer = liveStreams[0].user_name;
            document.getElementById('current-streamer').textContent = currentStreamer;
            document.getElementById('streamer-info').style.display = 'block';
            
            // Show the chat iframe and hide fallback
            document.getElementById('streamer-chat-iframe-container').style.display = 'block';
            document.getElementById('streamer-chat-fallback').style.display = 'none';
            
            // Load the actual Twitch chat
            const chatIframe = document.getElementById('streamer-chat-iframe');
            const parentDomain = window.location.hostname;
            chatIframe.src = `https://www.twitch.tv/embed/${encodeURIComponent(currentStreamer)}/chat?parent=${parentDomain}`;
            
            console.log(`Loading Twitch chat for: ${currentStreamer}`);
          } else {
            // No live streams, show fallback
            document.getElementById('streamer-chat-iframe-container').style.display = 'none';
            document.getElementById('streamer-chat-fallback').style.display = 'block';
            document.getElementById('streamer-info').style.display = 'none';
          }
        } else {
          // No Twitch OAuth data, show fallback
          document.getElementById('streamer-chat-iframe-container').style.display = 'none';
          document.getElementById('streamer-chat-fallback').style.display = 'block';
          document.getElementById('streamer-info').style.display = 'none';
        }
      }

      // Update streamer chat periodically
      setInterval(updateStreamerChat, 10000);
      updateStreamerChat();
    }

    function initializeVoting() {
      const voteButtons = document.querySelectorAll('.vote-btn');
      
      voteButtons.forEach((button, index) => {
        button.addEventListener('click', function() {
          // Remove voted class from all buttons
          voteButtons.forEach(btn => btn.classList.remove('voted'));
          // Add voted class to clicked button
          this.classList.add('voted');
          
          // Trigger confetti celebration
          triggerVoteCelebration();
          
          // Save vote to Firebase
          saveVote(index);
          
          // Show confirmation
          const teamName = this.textContent;
          alert(`You voted for ${teamName}!`);
        });
      });
    }

    async function saveVote(optionIndex) {
      try {
        // Generate a unique user ID for this session
        let userId = localStorage.getItem('voteUserId');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('voteUserId', userId);
        }

        // Get current poll data
        const pollDoc = await getDoc(doc(db, 'admin', 'currentPoll'));
        if (pollDoc.exists()) {
          const pollData = pollDoc.data();
          const votes = pollData.votes || {};
          
          // Update the vote
          votes[userId] = optionIndex;
          
          // Save back to Firebase
          await setDoc(doc(db, 'admin', 'currentPoll'), {
            ...pollData,
            votes: votes
          }, { merge: true });
          
          console.log('Vote saved successfully:', { userId, optionIndex });
          
          // Refresh the poll display
          setTimeout(() => {
            loadCurrentPollForMainPage();
          }, 500);
        }
      } catch (error) {
        console.error('Error saving vote:', error);
        alert('Failed to save vote. Please try again.');
      }
    }

    function triggerVoteCelebration() {
      // Create multiple confetti bursts
      const duration = 3000;
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      const interval = setInterval(function() {
        const timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
          return clearInterval(interval);
        }

        const particleCount = 50 * (timeLeft / duration);
        
        // Fire from left edge
        confetti({
          ...defaults,
          particleCount,
          origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
        });
        
        // Fire from right edge
        confetti({
          ...defaults,
          particleCount,
          origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
        });
      }, 250);
    }

    function initializeTwitchPlayer() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        // Get the current hostname - same as TribesScrimWatcher
        const parentDomain = window.location.hostname;
        
        // Update the iframe src with the correct parent parameter
        const currentSrc = streamFrame.src;
        const newSrc = currentSrc.includes('parent=') 
          ? currentSrc.replace(/parent=[^&]*/, `parent=${parentDomain}`)
          : `${currentSrc}&parent=${parentDomain}`;
        
        streamFrame.src = newSrc;
        console.log('Twitch player initialized with parent:', parentDomain);
        
        // Add error handling for the iframe
        streamFrame.onerror = function() {
          console.error('Failed to load Twitch player');
          // Show a fallback message or try alternative loading
          showPlayerFallback();
        };
        
        // Add load event listener
        streamFrame.onload = function() {
          console.log('Twitch player loaded successfully');
        };

        // Note: Removed iframe content check as it's unreliable for Twitch embeds
        // Cross-origin restrictions prevent checking iframe content even when working properly

        // Also listen for console errors that might indicate content blocking
        const originalConsoleError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          if (message.includes('PlaybackAccessToken') && message.includes('server error') ||
              message.includes('Failed to determine content classification')) {
            console.log('Detected Twitch content blocking error - showing fallback');
            setTimeout(() => showContentBlockedFallback(), 1000);
          }
          originalConsoleError.apply(console, args);
        };
      }
    }

    function showPlayerFallback() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        // Create a fallback div with instructions
        const fallbackDiv = document.createElement('div');
        fallbackDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        fallbackDiv.innerHTML = `
          <h3>Stream Loading...</h3>
          <p>If the stream doesn't load, try refreshing the page or check if the streamer is live.</p>
          <button onclick="location.reload()" style="
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
          ">Refresh Page</button>
        `;
        
        // Replace the iframe with fallback content
        streamFrame.parentNode.replaceChild(fallbackDiv, streamFrame);
      }
    }

    // Handle content blocked by browser (like Brave's privacy features)
    function showContentBlockedFallback() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        const blockedDiv = document.createElement('div');
        blockedDiv.id = 'content-blocked-fallback';
        blockedDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        blockedDiv.innerHTML = `
          <h3>🚫 Content Blocked by Browser</h3>
          <p>Your browser's privacy settings are blocking Twitch content.</p>
          <p><strong>To fix this:</strong></p>
          <ul style="text-align: left; margin: 1rem 0;">
            <li><strong>Brave:</strong> Click the shield icon → Turn off "Trackers & ads blocked" for this site</li>
            <li><strong>Chrome:</strong> Click the shield icon → Allow "Insecure content"</li>
            <li><strong>Firefox:</strong> Click the shield icon → Turn off "Enhanced Tracking Protection"</li>
          </ul>
          <p>Or try refreshing the page after adjusting settings.</p>
          <div style="margin-top: 1rem;">
            <button onclick="restoreStreamFrame()" style="
              background: var(--success);
              color: white;
              border: none;
              padding: 0.75rem 1.5rem;
              border-radius: 0.5rem;
              cursor: pointer;
              font-size: 1rem;
              margin-right: 0.5rem;
            ">Try Again</button>
            <button onclick="location.reload()" style="
              background: var(--accent);
              color: white;
              border: none;
              padding: 0.75rem 1.5rem;
              border-radius: 0.5rem;
              cursor: pointer;
              font-size: 1rem;
              margin-right: 0.5rem;
            ">Refresh Page</button>
            <button onclick="showAlternativeContent()" style="
              background: var(--surface-glass);
              color: var(--text-primary);
              border: 1px solid var(--accent);
              padding: 0.75rem 1.5rem;
              border-radius: 0.5rem;
              cursor: pointer;
              font-size: 1rem;
            ">Show Alternative Content</button>
          </div>
          <p style="margin-top: 1rem; font-size: 0.875rem; color: var(--text-muted);">
            If you're using Edge and logged into Twitch, try clicking "Try Again" first.
          </p>
        `;
        
        // Replace the iframe with the blocked content message
        streamFrame.parentNode.replaceChild(blockedDiv, streamFrame);
      }
    }

    function restoreStreamFrame() {
      const fallbackDiv = document.getElementById('content-blocked-fallback');
      if (fallbackDiv) {
        const newIframe = document.createElement('iframe');
        newIframe.className = 'stream-frame';
        newIframe.id = 'stream-frame';
        newIframe.src = 'https://player.twitch.tv/?channel=tribesprofessionalleague&autoplay=false';
        newIframe.allowFullscreen = true;
        
        // Replace the fallback div with the new iframe
        fallbackDiv.parentNode.replaceChild(newIframe, fallbackDiv);
        
        // Re-initialize the Twitch player
        setTimeout(() => {
          initializeTwitchPlayer();
        }, 100);
      }
    }

    // Show alternative content when Twitch is blocked
    function showAlternativeContent() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        const altDiv = document.createElement('div');
        altDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        altDiv.innerHTML = `
          <h3>📺 Content Temporarily Unavailable</h3>
          <p>Twitch streaming is currently blocked by your browser settings.</p>
          <p>You can still enjoy all other features:</p>
          <ul style="text-align: left; margin: 1rem 0;">
            <li>View match information and team statistics</li>
            <li>Vote in polls and see real-time results</li>
            <li>Chat with other viewers</li>
            <li>Access player information and stats</li>
          </ul>
          <p>To enable streaming, please adjust your browser's privacy settings.</p>
          <button onclick="showContentBlockedFallback()" style="
            background: var(--surface-glass);
            color: var(--text-primary);
            border: 1px solid var(--accent);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
            font-size: 0.9rem;
          ">Back to Fix Instructions</button>
        `;
        
        // Replace the current content with alternative options
        streamFrame.parentNode.replaceChild(altDiv, streamFrame);
      }
    }

    // Handle guest experience for non-authenticated users
    function showGuestExperience() {
      // Show a message in the stream area for guests
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        const guestDiv = document.createElement('div');
        guestDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        guestDiv.innerHTML = `
          <h3>Welcome to Tribes Professional League</h3>
          <p>Sign in with Twitch to watch live streams and access all features.</p>
          <p>You can still view match information, team stats, and vote in polls!</p>
          <button onclick="document.getElementById('twitch-login-btn').click()" style="
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
            font-size: 1rem;
          ">Sign in with Twitch</button>
        `;
        
        // Replace the iframe with the guest message
        streamFrame.parentNode.replaceChild(guestDiv, streamFrame);
      }

      // Disable player tab functionality for guests
      const playerTabs = document.querySelectorAll('.player-tab');
      playerTabs.forEach(tab => {
        tab.style.opacity = '0.6';
        tab.style.cursor = 'not-allowed';
        tab.title = 'Sign in with Twitch to watch player streams';
      });
    }

    // Restore authenticated experience when user signs in
    function restoreAuthenticatedExperience() {
      // Restore player tab functionality
      const playerTabs = document.querySelectorAll('.player-tab');
      playerTabs.forEach(tab => {
        tab.style.opacity = '1';
        tab.style.cursor = 'pointer';
        tab.title = '';
      });

      // Restore the Twitch player
      const streamContainer = document.querySelector('.stream-container');
      if (streamContainer) {
        const guestDiv = streamContainer.querySelector('div');
        if (guestDiv && guestDiv.innerHTML.includes('Welcome to Tribes Professional League')) {
          // Restore the original iframe
          const iframe = document.createElement('iframe');
          iframe.className = 'stream-frame';
          iframe.id = 'stream-frame';
          iframe.src = 'https://player.twitch.tv/?channel=tribesprofessionalleague&autoplay=false';
          iframe.allowFullscreen = true;
          
          streamContainer.replaceChild(iframe, guestDiv);
          
          // Re-initialize the Twitch player
          setTimeout(() => {
            initializeTwitchPlayer();
          }, 500);
        }
      }
    }

    // Test function to manually load DPRK vs Zen image
    function testDPRKvsZen() {
      const matchDisplay = document.getElementById('match-display');
      const testPath = "https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/DPRK/DPRKvsZen.png";
      console.log('Testing direct path:', testPath);
      
      const testImage = new Image();
      testImage.onload = function() {
        console.log('✅ Direct test successful!');
        matchDisplay.style.backgroundImage = `url(${testPath})`;
        matchDisplay.style.backgroundSize = 'cover';
        matchDisplay.style.backgroundPosition = 'center';
        matchDisplay.style.backgroundRepeat = 'no-repeat';
        matchDisplay.classList.add('has-background');
      };
      testImage.onerror = function() {
        console.log('❌ Direct test failed!');
      };
      testImage.src = testPath;
    }
    
    // Test function to manually set background images
    function testBackgroundImages() {
      console.log('Testing background images...');
      const testLogo = 'https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo\'s/TeamDPRKLogo3.png';
      
      document.getElementById('bg-left').style.backgroundImage = `url(${testLogo})`;
      document.getElementById('bg-right').style.backgroundImage = `url(${testLogo})`;
      
      console.log('Background images set to:', testLogo);
      console.log('Left background:', document.getElementById('bg-left').style.backgroundImage);
      console.log('Right background:', document.getElementById('bg-right').style.backgroundImage);
    }

    // Test function to check player name mapping
    function testPlayerMapping() {
      console.log('Testing player name mapping...');
      
      // Test Panda -> Pandora mapping
      const testPlayer = { name: 'Panda', twitch: '' };
      const handle = getTwitchHandleForPlayer(testPlayer);
      console.log(`Panda mapping result: ${handle}`);
      
      // Test Glem mapping
      const testPlayer2 = { name: 'Glem', twitch: '' };
      const handle2 = getTwitchHandleForPlayer(testPlayer2);
      console.log(`Glem mapping result: ${handle2}`);
      
      // Show all available mappings
      console.log('Available name mappings:', PLAYER_NAME_MAPPING);
    }

    // Test function to verify Twitch player URL format
    function testTwitchPlayerFormat() {
      console.log('Testing Twitch player URL format...');
      const parentDomain = window.location.hostname;
      const testChannel = 'pandoracast';
      
      const testUrl = `https://player.twitch.tv/?channel=${encodeURIComponent(testChannel)}&parent=${parentDomain}&autoplay=false`;
      console.log('Test URL format:', testUrl);
      
      // Test if this matches TribesScrimWatcher format
      const streamFrame = document.querySelector('.stream-frame');
      if (streamFrame) {
        streamFrame.src = testUrl;
        console.log('Applied test URL to player');
      }
    }

    // Test function to verify team logo URLs are working
    function testTeamLogos() {
      console.log('Testing team logo URLs...');
      
      // Test DPRK and Zen logos specifically
      const dprkLogo = TEAM_DATA['DPRK'].logo;
      const zenLogo = TEAM_DATA['Zen'].logo;
      
      console.log('DPRK logo URL:', dprkLogo);
      console.log('Zen logo URL:', zenLogo);
      
      // Test loading the logos
      const testImage1 = new Image();
      testImage1.onload = function() {
        console.log('✅ DPRK logo loaded successfully');
        // Set as background to test
        document.getElementById('bg-left').style.backgroundImage = `url(${dprkLogo})`;
      };
      testImage1.onerror = function() {
        console.log('❌ DPRK logo failed to load');
      };
      testImage1.src = dprkLogo;
      
      const testImage2 = new Image();
      testImage2.onload = function() {
        console.log('✅ Zen logo loaded successfully');
        // Set as background to test
        document.getElementById('bg-right').style.backgroundImage = `url(${zenLogo})`;
      };
      testImage2.onerror = function() {
        console.log('❌ Zen logo failed to load');
      };
      testImage2.src = zenLogo;
    }

    // Function to adjust background logo opacity for better readability
    function adjustBackgroundOpacity(opacity) {
      const bgLeft = document.getElementById('bg-left');
      const bgRight = document.getElementById('bg-right');
      
      if (bgLeft && bgRight) {
        bgLeft.style.opacity = opacity;
        bgRight.style.opacity = opacity;
        console.log(`Background opacity set to ${opacity}`);
      }
    }

    // Player Stats functionality
    let playerStatsData = null;
    let currentStatsChart = null;

    async function loadPlayerStats() {
      try {
        const docRef = doc(db, 'publicStats', 'aggregates');
        const docSnap = await getDoc(docRef);

        if (!docSnap.exists()) {
          console.log('No published stats found');
          return null;
        }

        const data = docSnap.data() || {};
        
        // Hydrate the data like PlayerStats.html does
        const hydratePlayers = (entries = []) => {
          const map = new Map();
          entries.forEach(entry => {
            const teams = Array.isArray(entry.teams) ? new Set(entry.teams) : new Set(entry.team ? [entry.team] : []);
            map.set(entry.name, { ...entry, teams });
          });
          return map;
        };

        const hydratePlayerMaps = (entries = []) => {
          const map = new Map();
          entries.forEach(entry => {
            const teams = Array.isArray(entry.teams) ? new Set(entry.teams) : new Set();
            map.set(`${entry.player}__${entry.map}`, { ...entry, teams });
          });
          return map;
        };

        const hydrateTeams = (entries = []) => {
          const map = new Map();
          entries.forEach(entry => {
            map.set(entry.name, { ...entry });
          });
          return map;
        };

        playerStatsData = {
          playerTotals: hydratePlayers(data.playerTotals || []),
          playerMapStats: hydratePlayerMaps(data.playerMapStats || []),
          teamTotals: hydrateTeams(data.teamTotals || []),
          totalMatches: data.totalMatches || 0,
          generatedAt: data.generatedAt
        };

        console.log('Player stats loaded:', playerStatsData);
        console.log('Available players:', Array.from(playerStatsData.playerTotals.keys()));
        return playerStatsData;
      } catch (error) {
        console.error('Error loading player stats:', error);
        return null;
      }
    }

    function showPlayerStats(playerName) {
      const statsSection = document.getElementById('player-stats-section');
      const statsContent = document.getElementById('player-stats-content');
      
      if (!statsSection || !statsContent) return;

      if (!playerStatsData) {
        statsContent.innerHTML = '<div class="text-center text-gray-400">No player statistics available</div>';
        statsSection.style.display = 'block';
        return;
      }

      console.log('Looking for player stats:', playerName);
      console.log('Available players in stats:', Array.from(playerStatsData.playerTotals.keys()));

      // Try exact match first
      let player = playerStatsData.playerTotals.get(playerName);
      
      // If no exact match, try case-insensitive search
      if (!player && playerName) {
        const playerNames = Array.from(playerStatsData.playerTotals.keys());
        const foundName = playerNames.find(name => 
          name && name.toLowerCase() === playerName.toLowerCase()
        );
        if (foundName) {
          player = playerStatsData.playerTotals.get(foundName);
          console.log('Found case-insensitive match:', foundName);
        }
      }

      // If still no match, try partial matching
      if (!player && playerName) {
        const playerNames = Array.from(playerStatsData.playerTotals.keys());
        const foundName = playerNames.find(name => 
          name && (
            name.toLowerCase().includes(playerName.toLowerCase()) ||
            playerName.toLowerCase().includes(name.toLowerCase())
          )
        );
        if (foundName) {
          player = playerStatsData.playerTotals.get(foundName);
          console.log('Found partial match:', foundName);
        }
      }

      if (!player) {
        statsContent.innerHTML = `
          <div class="text-center text-gray-400">
            <p>No statistics found for "${playerName}"</p>
            <p class="text-sm mt-2">Available players: ${Array.from(playerStatsData.playerTotals.keys()).slice(0, 10).join(', ')}${playerStatsData.playerTotals.size > 10 ? '...' : ''}</p>
          </div>
        `;
        statsSection.style.display = 'block';
        return;
      }

      // Calculate player metrics
      const time = parseFloat(player.time) || 0;
      const kills = parseFloat(player.kills) || 0;
      const assists = parseFloat(player.assists) || 0;
      const score = parseFloat(player.score) || 0;
      const captures = parseFloat(player.captures) || 0;
      const returns = parseFloat(player.returns) || 0;
      const matches = parseFloat(player.matches) || 0;

      const kpm = time > 0 ? kills / time : 0;
      const apm = time > 0 ? assists / time : 0;
      const spm = time > 0 ? score / time : 0;
      const cpm = time > 0 ? captures / time : 0;
      const rpm = time > 0 ? returns / time : 0;

      const teams = Array.from(player.teams || []).join(', ') || 'Unknown';

      // Create stats display
      statsContent.innerHTML = `
        <div class="player-stats-display">
          <div class="player-stats-header">
            <h3 class="text-2xl font-bold text-white mb-2">${playerName}</h3>
            <p class="text-gray-300 mb-4">Teams: ${teams} | Matches: ${matches} | Playtime: ${time.toFixed(1)} min</p>
          </div>
          
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-label">Score</div>
              <div class="stat-value">${score.toFixed(0)}</div>
              <div class="stat-rate">${spm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Kills</div>
              <div class="stat-value">${kills.toFixed(0)}</div>
              <div class="stat-rate">${kpm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Assists</div>
              <div class="stat-value">${assists.toFixed(0)}</div>
              <div class="stat-rate">${apm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Captures</div>
              <div class="stat-value">${captures.toFixed(0)}</div>
              <div class="stat-rate">${cpm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Returns</div>
              <div class="stat-value">${returns.toFixed(0)}</div>
              <div class="stat-rate">${rpm.toFixed(2)}/min</div>
            </div>
          </div>

          <div class="stats-chart-container">
            <h4 class="text-lg font-semibold text-white mb-4">Performance Metrics</h4>
            <canvas id="player-stats-chart" width="400" height="200"></canvas>
          </div>
        </div>
      `;

      // Create performance chart
      setTimeout(() => {
        createPlayerStatsChart(playerName, { kpm, apm, spm, cpm, rpm });
      }, 100);

      statsSection.style.display = 'block';
    }

    function createPlayerStatsChart(playerName, metrics) {
      const canvas = document.getElementById('player-stats-chart');
      if (!canvas) return;

      // Destroy existing chart
      if (currentStatsChart) {
        currentStatsChart.destroy();
      }

      const ctx = canvas.getContext('2d');
      // Use separate scaling for Score vs other metrics to make all bars visible
      const combatMax = Math.max(metrics.kpm, metrics.apm, metrics.cpm, metrics.rpm);
      const scoreMax = metrics.spm;
      
      // Scale combat stats to 0-100% based on their max
      const combatScale = combatMax > 0 ? 100 / combatMax : 1;
      
      // Scale score to 0-100% but use a smaller multiplier to make it less dominant
      const scoreScale = scoreMax > 0 ? 50 / scoreMax : 1; // Score gets 50% max height
      
      const normalizedData = [
        Math.min(metrics.spm * scoreScale, 100),     // Score/min (scaled to max 50% of chart)
        Math.min(metrics.kpm * combatScale, 100),    // Kills/min (scaled to combat max)
        Math.min(metrics.apm * combatScale, 100),    // Assists/min (scaled to combat max)
        Math.min(metrics.cpm * combatScale, 100),    // Captures/min (scaled to combat max)
        Math.min(metrics.rpm * combatScale, 100)     // Returns/min (scaled to combat max)
      ];

      currentStatsChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Score/min', 'Kills/min', 'Assists/min', 'Captures/min', 'Returns/min'],
          datasets: [{
            label: `${playerName} Performance (Normalized)`,
            data: normalizedData,
            backgroundColor: [
              'rgba(16, 185, 129, 0.8)',  // Green for score
              'rgba(239, 68, 68, 0.8)',   // Red for kills
              'rgba(59, 130, 246, 0.8)',  // Blue for assists
              'rgba(245, 158, 11, 0.8)',  // Yellow for captures
              'rgba(139, 92, 246, 0.8)'   // Purple for returns
            ],
            borderColor: [
              'rgba(16, 185, 129, 1)',
              'rgba(239, 68, 68, 1)',
              'rgba(59, 130, 246, 1)',
              'rgba(245, 158, 11, 1)',
              'rgba(139, 92, 246, 1)'
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: '#e2e8f0'
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const index = context.dataIndex;
                  const originalValues = [metrics.spm, metrics.kpm, metrics.apm, metrics.cpm, metrics.rpm];
                  const labels = ['Score/min', 'Kills/min', 'Assists/min', 'Captures/min', 'Returns/min'];
                  return `${labels[index]}: ${originalValues[index].toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                color: '#94a3b8',
                callback: function(value) {
                  return value + '%';
                }
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.1)'
              }
            },
            x: {
              ticks: {
                color: '#94a3b8'
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.1)'
              }
            }
          }
        }
      });
    }

    function hidePlayerStats() {
      const statsSection = document.getElementById('player-stats-section');
      if (statsSection) {
        statsSection.style.display = 'none';
      }
      if (currentStatsChart) {
        currentStatsChart.destroy();
        currentStatsChart = null;
      }
    }

    function initializePlayerStats() {
      // Load player stats data
      loadPlayerStats();
      
      // Add close button functionality
      const closeStatsBtn = document.getElementById('close-stats-btn');
      if (closeStatsBtn) {
        closeStatsBtn.addEventListener('click', hidePlayerStats);
      }
    }
    
    // Test function for player stats
    function testPlayerStats() {
      console.log('Testing player stats functionality...');
      if (playerStatsData) {
        console.log('Player stats data loaded:', playerStatsData);
        const playerNames = Array.from(playerStatsData.playerTotals.keys());
        console.log('Available players:', playerNames);
        if (playerNames.length > 0) {
          showPlayerStats(playerNames[0]);
        }
      } else {
        console.log('No player stats data available');
        loadPlayerStats().then(() => {
          console.log('Player stats loaded, try testPlayerStats() again');
        });
      }
    }

    // Debug function to compare roster names with stats names
    function debugPlayerNames() {
      console.log('=== Player Name Debug ===');
      console.log('Selected teams:', selectedTeams);
      
      if (selectedTeams.teamA && selectedTeams.teamB) {
        const teamARoster = teamRosters[selectedTeams.teamA] || [];
        const teamBRoster = teamRosters[selectedTeams.teamB] || [];
        
        console.log('Team A roster names:', teamARoster.map(p => p.name || p.displayName));
        console.log('Team B roster names:', teamBRoster.map(p => p.name || p.displayName));
      }
      
      if (playerStatsData) {
        const statsNames = Array.from(playerStatsData.playerTotals.keys());
        console.log('Stats database names:', statsNames);
        
        // Check for matches
        if (selectedTeams.teamA && selectedTeams.teamB) {
          const allRosterNames = [
            ...(teamRosters[selectedTeams.teamA] || []).map(p => p.name || p.displayName),
            ...(teamRosters[selectedTeams.teamB] || []).map(p => p.name || p.displayName)
          ];
          
          console.log('=== Name Matching Analysis ===');
          allRosterNames.forEach(rosterName => {
            const exactMatch = statsNames.includes(rosterName);
            const caseMatch = statsNames.find(s => s.toLowerCase() === rosterName.toLowerCase());
            const partialMatch = statsNames.find(s => 
              s.toLowerCase().includes(rosterName.toLowerCase()) ||
              rosterName.toLowerCase().includes(s.toLowerCase())
            );
            
            console.log(`"${rosterName}":`, {
              exact: exactMatch,
              caseInsensitive: caseMatch || 'none',
              partial: partialMatch || 'none'
            });
          });
        }
      } else {
        console.log('No player stats data loaded yet');
      }
    }

    // Admin System
    let activeMatch = null;
    let isAdmin = false;
    let livePlayers = new Set();

    // Check if user is admin using Firebase Auth
    function checkAdminStatus() {
      // This will be called by onAuthStateChanged
      if (isAdmin) {
        document.getElementById('admin-login-btn').style.display = 'none';
        document.getElementById('admin-panel-btn').style.display = 'inline-block';
        document.getElementById('admin-logout-btn').style.display = 'inline-block';
      } else {
        document.getElementById('admin-login-btn').style.display = 'inline-block';
        document.getElementById('admin-panel-btn').style.display = 'none';
        document.getElementById('admin-logout-btn').style.display = 'none';
      }
    }

    // Load active match from Firebase
    async function loadActiveMatch() {
      try {
        const docRef = doc(db, 'admin', 'activeMatch');
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
          activeMatch = docSnap.data();
          updateCurrentMatchDisplay();
          if (activeMatch.teamA && activeMatch.teamB) {
            selectedTeams.teamA = activeMatch.teamA;
            selectedTeams.teamB = activeMatch.teamB;
            console.log('Loaded active match:', selectedTeams);
            // Update the main page display
            updateMatchDisplay();
            loadTeamRosters().then(() => {
              // Player tabs will be updated in loadTeamRosters
            });
          }
        } else {
          // Set default match if none exists
          setDefaultMatch();
        }
      } catch (error) {
        console.error('Error loading active match:', error);
        setDefaultMatch();
      }
    }

    // Set default match (first two teams)
    function setDefaultMatch() {
      const teamKeys = Object.keys(TEAM_DATA);
      if (teamKeys.length >= 2) {
        selectedTeams.teamA = teamKeys[0];
        selectedTeams.teamB = teamKeys[1];
        loadTeamRosters();
      }
    }

    // Save active match to Firebase
    async function saveActiveMatch(teamA, teamB) {
      try {
        const matchData = {
          teamA: teamA,
          teamB: teamB,
          timestamp: serverTimestamp()
        };

        console.log('Attempting to save active match:', matchData);
        console.log('Current user:', auth.currentUser);
        console.log('Is admin:', isAdmin);

        const docRef = doc(db, 'admin', 'activeMatch');
        await setDoc(docRef, matchData);
        activeMatch = { teamA, teamB };
        updateCurrentMatchDisplay();
        
        // Update the main page display
        selectedTeams.teamA = teamA;
        selectedTeams.teamB = teamB;
        updateMatchDisplay();
        loadTeamRosters().then(() => {
          // Player tabs will be updated in loadTeamRosters
        });
        
        console.log('Active match saved:', teamA, 'vs', teamB);
      } catch (error) {
        console.error('Error saving active match:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        alert(`Failed to save active match: ${error.message}`);
      }
    }

    // Update current match display
    function updateCurrentMatchDisplay() {
      const display = document.getElementById('current-match-display');
      if (activeMatch && activeMatch.teamA && activeMatch.teamB) {
        const teamAData = TEAM_DATA[activeMatch.teamA];
        const teamBData = TEAM_DATA[activeMatch.teamB];
        display.innerHTML = `
          <div style="display: flex; align-items: center; gap: 1rem;">
            <img src="${teamAData.logo}" alt="${teamAData.name}" style="width: 40px; height: 40px; border-radius: 50%;">
            <span style="font-weight: 600;">${teamAData.name}</span>
            <span style="color: var(--text-muted);">VS</span>
            <span style="font-weight: 600;">${teamBData.name}</span>
            <img src="${teamBData.logo}" alt="${teamBData.name}" style="width: 40px; height: 40px; border-radius: 50%;">
          </div>
        `;
      } else {
        display.innerHTML = '<p>No active match set</p>';
      }
    }

    // Initialize admin panel
    function initializeAdminPanel() {
      // Populate team selectors
      const teamASelect = document.getElementById('admin-team-a');
      const teamBSelect = document.getElementById('admin-team-b');
      
      Object.keys(TEAM_DATA).forEach(teamKey => {
        const team = TEAM_DATA[teamKey];
        const optionA = new Option(team.name, teamKey);
        const optionB = new Option(team.name, teamKey);
        teamASelect.add(optionA);
        teamBSelect.add(optionB);
      });

      // Set current match if exists
      if (activeMatch && activeMatch.teamA && activeMatch.teamB) {
        teamASelect.value = activeMatch.teamA;
        teamBSelect.value = activeMatch.teamB;
      }

      // Event listeners
      document.getElementById('set-active-match').addEventListener('click', () => {
        const teamA = teamASelect.value;
        const teamB = teamBSelect.value;
        
        if (!teamA || !teamB) {
          alert('Please select both teams');
          return;
        }
        
        if (teamA === teamB) {
          alert('Teams must be different');
          return;
        }
        
        saveActiveMatch(teamA, teamB);
        // Update the main display
        selectedTeams.teamA = teamA;
        selectedTeams.teamB = teamB;
        loadTeamRosters();
        hideAdminPanel();
      });

      document.getElementById('clear-active-match').addEventListener('click', () => {
        if (confirm('Are you sure you want to clear the active match?')) {
          saveActiveMatch('', '');
          setDefaultMatch();
          hideAdminPanel();
        }
      });

      // Update live status
      updateLivePlayersStatus();
      
      // Load current poll
      loadCurrentPoll();
    }

    // Show admin panel
    function showAdminPanel() {
      if (!isAdmin) {
        alert('Admin access required');
        return;
      }
      document.getElementById('admin-modal').style.display = 'flex';
      initializeAdminPanel();
    }

    // Hide admin panel
    function hideAdminPanel() {
      document.getElementById('admin-modal').style.display = 'none';
    }

    // Update live players status
    function updateLivePlayersStatus() {
      const statusDiv = document.getElementById('live-players-status');
      if (livePlayers.size === 0) {
        statusDiv.innerHTML = '<p>No live players detected</p>';
      } else {
        const liveList = Array.from(livePlayers).map(player => `<span class="live-indicator"></span>${player}`).join('<br>');
        statusDiv.innerHTML = `<p><strong>Live Players (${livePlayers.size}):</strong></p><p>${liveList}</p>`;
      }
    }

    // Check for live players and update indicators
    function updateLivePlayerIndicators() {
      console.log('Checking live player indicators...');
      
      if (!window.twitchOAuth) {
        console.log('Twitch OAuth not available - skipping live indicators');
        return;
      }

      if (!window.twitchOAuth.liveStreams || !Array.isArray(window.twitchOAuth.liveStreams)) {
        console.log('No live streams data available');
        return;
      }

      const liveStreams = window.twitchOAuth.liveStreams;
      const playerTabs = document.querySelectorAll('.player-tab');
      
      console.log('Found live streams:', liveStreams.length);
      console.log('Found player tabs:', playerTabs.length);
      
      // Clear previous live indicators
      playerTabs.forEach(tab => tab.classList.remove('live'));
      livePlayers.clear();

      // Check each player tab
      playerTabs.forEach(tab => {
        if (tab.dataset.team && tab.dataset.playerIndex !== undefined) {
          const team = tab.dataset.team;
          const playerIndex = tab.dataset.playerIndex;
          const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
          const roster = teamRosters[teamKey] || [];
          const player = roster[playerIndex];
          
          if (player) {
            const playerName = player.name || player.displayName;
            const twitchHandle = getTwitchHandleForPlayer(player);
            
            console.log(`Checking player ${playerName} with Twitch handle: ${twitchHandle}`);
            
            // Check if this player is live
            const isLive = liveStreams.some(stream => {
              const streamLogin = stream.user_login ? stream.user_login.toLowerCase() : '';
              const handle = twitchHandle ? twitchHandle.toLowerCase() : '';
              const match = streamLogin === handle;
              if (match) {
                console.log(`Found live stream for ${playerName}: ${stream.user_name}`);
              }
              return match;
            });
            
            if (isLive) {
              tab.classList.add('live');
              livePlayers.add(playerName);
              console.log(`Marked ${playerName} as live`);
            }
          }
        }
      });

      console.log('Live players found:', Array.from(livePlayers));

      // Update admin panel if open
      if (document.getElementById('admin-modal').style.display === 'flex') {
        updateLivePlayersStatus();
      }
    }

    // Team Stats functionality
    function showTeamStats() {
      const statsSection = document.getElementById('team-stats-section');
      const statsContent = document.getElementById('team-stats-content');
      
      if (!statsSection || !statsContent) return;

      if (!playerStatsData || !selectedTeams.teamA || !selectedTeams.teamB) {
        statsContent.innerHTML = '<div class="text-center text-gray-400">No team statistics available</div>';
        statsSection.style.display = 'block';
        return;
      }

      const teamAData = TEAM_DATA[selectedTeams.teamA];
      const teamBData = TEAM_DATA[selectedTeams.teamB];
      const teamARoster = teamRosters[selectedTeams.teamA] || [];
      const teamBRoster = teamRosters[selectedTeams.teamB] || [];

      // Calculate team stats
      const teamAStats = calculateTeamStats(teamARoster);
      const teamBStats = calculateTeamStats(teamBRoster);

      // Generate HTML
      statsContent.innerHTML = `
        <div class="team-stats-grid">
          <div class="team-stats-card">
            <div class="team-stats-header">
              <img src="${teamAData.logo}" alt="${teamAData.name}">
              <h3>${teamAData.name}</h3>
            </div>
            <div class="team-metrics-grid">
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalKills}</div>
                <div class="team-metric-label">Total Kills</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalAssists}</div>
                <div class="team-metric-label">Total Assists</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalScore}</div>
                <div class="team-metric-label">Total Score</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalCaptures}</div>
                <div class="team-metric-label">Total Captures</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalReturns}</div>
                <div class="team-metric-label">Total Returns</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalTime.toFixed(1)}h</div>
                <div class="team-metric-label">Play Time</div>
              </div>
            </div>
          </div>
          
          <div class="team-stats-card">
            <div class="team-stats-header">
              <img src="${teamBData.logo}" alt="${teamBData.name}">
              <h3>${teamBData.name}</h3>
            </div>
            <div class="team-metrics-grid">
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalKills}</div>
                <div class="team-metric-label">Total Kills</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalAssists}</div>
                <div class="team-metric-label">Total Assists</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalScore}</div>
                <div class="team-metric-label">Total Score</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalCaptures}</div>
                <div class="team-metric-label">Total Captures</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalReturns}</div>
                <div class="team-metric-label">Total Returns</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalTime.toFixed(1)}h</div>
                <div class="team-metric-label">Play Time</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="team-comparison">
          <div class="comparison-header">Team Comparison</div>
          <div class="comparison-grid">
            <div class="comparison-team">
              <div style="font-weight: 600; margin-bottom: 1rem;">${teamAData.name}</div>
            </div>
            <div class="comparison-vs">VS</div>
            <div class="comparison-team">
              <div style="font-weight: 600; margin-bottom: 1rem;">${teamBData.name}</div>
            </div>
          </div>
          
          <div class="comparison-metric">
            <div class="comparison-metric-label">Total Kills</div>
            <div class="comparison-metric-values">
              <div class="comparison-value ${teamAStats.totalKills > teamBStats.totalKills ? 'winner' : teamAStats.totalKills < teamBStats.totalKills ? 'loser' : ''}">${teamAStats.totalKills}</div>
              <div class="comparison-value ${teamBStats.totalKills > teamAStats.totalKills ? 'winner' : teamBStats.totalKills < teamAStats.totalKills ? 'loser' : ''}">${teamBStats.totalKills}</div>
            </div>
          </div>
          
          <div class="comparison-metric">
            <div class="comparison-metric-label">Total Score</div>
            <div class="comparison-metric-values">
              <div class="comparison-value ${teamAStats.totalScore > teamBStats.totalScore ? 'winner' : teamAStats.totalScore < teamBStats.totalScore ? 'loser' : ''}">${teamAStats.totalScore}</div>
              <div class="comparison-value ${teamBStats.totalScore > teamAStats.totalScore ? 'winner' : teamBStats.totalScore < teamAStats.totalScore ? 'loser' : ''}">${teamBStats.totalScore}</div>
            </div>
          </div>
          
          <div class="comparison-metric">
            <div class="comparison-metric-label">Total Captures</div>
            <div class="comparison-metric-values">
              <div class="comparison-value ${teamAStats.totalCaptures > teamBStats.totalCaptures ? 'winner' : teamAStats.totalCaptures < teamBStats.totalCaptures ? 'loser' : ''}">${teamAStats.totalCaptures}</div>
              <div class="comparison-value ${teamBStats.totalCaptures > teamAStats.totalCaptures ? 'winner' : teamBStats.totalCaptures < teamAStats.totalCaptures ? 'loser' : ''}">${teamBStats.totalCaptures}</div>
            </div>
          </div>
        </div>
      `;

      statsSection.style.display = 'block';
    }

    function calculateTeamStats(roster) {
      let totalKills = 0;
      let totalAssists = 0;
      let totalScore = 0;
      let totalCaptures = 0;
      let totalReturns = 0;
      let totalTime = 0;

      roster.forEach(player => {
        const playerName = player.name || player.displayName;
        if (playerName && playerStatsData && playerStatsData.playerTotals) {
          // Try to find player stats with name matching
          let playerStats = playerStatsData.playerTotals.get(playerName);
          
          if (!playerStats) {
            // Try case-insensitive search
            const playerNames = Array.from(playerStatsData.playerTotals.keys());
            const foundName = playerNames.find(name => 
              name && name.toLowerCase() === playerName.toLowerCase()
            );
            if (foundName) {
              playerStats = playerStatsData.playerTotals.get(foundName);
            }
          }

          if (playerStats) {
            totalKills += parseFloat(playerStats.kills) || 0;
            totalAssists += parseFloat(playerStats.assists) || 0;
            totalScore += parseFloat(playerStats.score) || 0;
            totalCaptures += parseFloat(playerStats.captures) || 0;
            totalReturns += parseFloat(playerStats.returns) || 0;
            totalTime += parseFloat(playerStats.time) || 0;
          }
        }
      });

      const avgKillsPerMinute = totalTime > 0 ? (totalKills / (totalTime * 60)) : 0;
      const avgScorePerMinute = totalTime > 0 ? (totalScore / (totalTime * 60)) : 0;

      return {
        totalKills,
        totalAssists,
        totalScore,
        totalCaptures,
        totalReturns,
        totalTime,
        avgKillsPerMinute,
        avgScorePerMinute
      };
    }

    function hideTeamStats() {
      const statsSection = document.getElementById('team-stats-section');
      if (statsSection) {
        statsSection.style.display = 'none';
      }
    }

    function initializeTeamStats() {
      const closeBtn = document.getElementById('close-team-stats-btn');
      if (closeBtn) {
        closeBtn.addEventListener('click', hideTeamStats);
      }

      const showBtn = document.getElementById('show-team-stats-btn');
      if (showBtn) {
        showBtn.addEventListener('click', showTeamStats);
      }
    }

    // Make test functions available globally for debugging
    window.testDPRKvsZen = testDPRKvsZen;
    window.testBackgroundImages = testBackgroundImages;
    window.testPlayerMapping = testPlayerMapping;
    window.testTwitchPlayerFormat = testTwitchPlayerFormat;
    window.testTeamLogos = testTeamLogos;
    window.adjustBackgroundOpacity = adjustBackgroundOpacity;
    window.testPlayerStats = testPlayerStats;
    window.showPlayerStats = showPlayerStats;
    window.hidePlayerStats = hidePlayerStats;
    window.debugPlayerNames = debugPlayerNames;
    window.showAdminPanel = showAdminPanel;
    window.hideAdminPanel = hideAdminPanel;
    window.showTeamStats = showTeamStats;
    window.hideTeamStats = hideTeamStats;
    window.updateLivePlayerIndicators = updateLivePlayerIndicators;
    // Recent Matches functionality
    async function loadRecentMatches() {
      const recentMatchesGrid = document.getElementById('recent-matches-grid');
      if (!recentMatchesGrid) return;

      try {
        // Get the current active season
        const seasonsRef = collection(db, 'leagueSeasons');
        const seasonsSnapshot = await getDocs(seasonsRef);
        const seasons = seasonsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Find the active season
        const activeSeason = seasons.find(s => s.active === true);
        if (!activeSeason) {
          console.log('No active season found');
          recentMatchesGrid.innerHTML = '<div class="text-center text-gray-400 py-4">No active season</div>';
          return;
        }

        // Get TPL-O schedule data
        const scheduleRef = doc(db, 'leagueSchedules', `${activeSeason.season}-TPL-O`);
        const scheduleSnapshot = await getDoc(scheduleRef);
        
        if (!scheduleSnapshot.exists()) {
          console.log('No TPL-O schedule found');
          recentMatchesGrid.innerHTML = '<div class="text-center text-gray-400 py-4">No TPL-O schedule found</div>';
          return;
        }

        const scheduleData = scheduleSnapshot.data();
        const weeks = scheduleData.weeks || [];

        // Collect all completed matches with scores
        const completedMatches = [];
        weeks.forEach(week => {
          if (week.matches) {
            week.matches.forEach(match => {
              // Only include matches that have both scores (completed matches)
              if (match.homeScore !== null && match.awayScore !== null && 
                  match.homeScore !== undefined && match.awayScore !== undefined) {
                completedMatches.push({
                  teamA: match.away,
                  teamB: match.home,
                  scoreA: match.awayScore,
                  scoreB: match.homeScore,
                  date: match.date || 'Unknown Date',
                  week: week.week,
                  phase: week.phase || 'regular'
                });
              }
            });
          }
        });

        // Sort by date (most recent first) and take the last 6 matches
        const recentMatches = completedMatches
          .sort((a, b) => new Date(b.date) - new Date(a.date))
          .slice(0, 6);

        // Clear the grid
        recentMatchesGrid.innerHTML = '';

        if (recentMatches.length === 0) {
          recentMatchesGrid.innerHTML = '<div class="text-center text-gray-400 py-4">No recent matches found</div>';
          return;
        }

        // Render the matches
        recentMatches.forEach(match => {
          const matchCard = document.createElement('div');
          matchCard.className = 'recent-match-card';

          const teamA = TEAM_DATA[match.teamA];
          const teamB = TEAM_DATA[match.teamB];

          // Determine winner
          const winner = match.scoreA > match.scoreB ? match.teamA : match.teamB;

          // Format the date
          const formattedDate = match.date !== 'Unknown Date' ? 
            new Date(match.date).toLocaleDateString() : 
            `Week ${match.week}`;

          matchCard.innerHTML = `
            <div class="match-teams">
              <div class="team-info">
                <img src="${teamA?.logo || ''}" alt="${match.teamA}" class="team-logo-small" onerror="this.style.display='none'">
                <span class="team-name ${winner === match.teamA ? 'winner' : ''}">${match.teamA}</span>
              </div>
              <span class="match-score">${match.scoreA} - ${match.scoreB}</span>
              <div class="team-info">
                <span class="team-name ${winner === match.teamB ? 'winner' : ''}">${match.teamB}</span>
                <img src="${teamB?.logo || ''}" alt="${match.teamB}" class="team-logo-small" onerror="this.style.display='none'">
              </div>
            </div>
            <div class="match-date">${formattedDate}</div>
          `;

          recentMatchesGrid.appendChild(matchCard);
        });

        console.log(`Loaded ${recentMatches.length} recent matches from TPL-O schedule`);

      } catch (error) {
        console.error('Error loading recent matches:', error);
        recentMatchesGrid.innerHTML = '<div class="text-center text-red-400 py-4">Error loading recent matches</div>';
      }
    }

    window.showGuestExperience = showGuestExperience;
    window.restoreAuthenticatedExperience = restoreAuthenticatedExperience;
    window.showContentBlockedFallback = showContentBlockedFallback;
    window.showAlternativeContent = showAlternativeContent;
    window.restoreStreamFrame = restoreStreamFrame;
    window.updateStreamerChat = updateStreamerChat;
    window.loadRecentMatches = loadRecentMatches;
    window.initializeTwitchChat = initializeTwitchChat;
    window.updateStreamerDropdown = updateStreamerDropdown;

    // Twitch Chat functionality
    function initializeTwitchChat() {
      const twitchChatIframe = document.getElementById('twitch-chat-iframe');
      const streamerSelect = document.getElementById('streamer-select');
      
      if (!twitchChatIframe || !streamerSelect) return;

      // Load the main TPL Twitch chat initially
      const parentDomain = window.location.hostname;
      const chatUrl = `https://www.twitch.tv/embed/tribesprofessionalleague/chat?parent=${parentDomain}`;
      
      // Add load event listener to handle connection status
      twitchChatIframe.addEventListener('load', function() {
        console.log('Twitch chat loaded successfully');
        // Hide loading indicator and show iframe
        const loadingIndicator = document.querySelector('.chat-loading');
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }
        twitchChatIframe.style.display = 'block';
      });

      twitchChatIframe.addEventListener('error', function() {
        console.error('Twitch chat failed to load');
        // Show error message
        const chatContainer = document.querySelector('.twitch-chat-container');
        if (chatContainer) {
          chatContainer.innerHTML = `
            <div class="chat-error" style="display: flex; align-items: center; justify-content: center; height: 500px; background: var(--surface-glass); border-radius: 0.5rem; color: var(--text-muted);">
              <div class="text-center">
                <div class="text-lg mb-2">⚠️</div>
                <div>Chat temporarily unavailable</div>
                <button onclick="initializeTwitchChat()" class="mt-2 px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">Retry</button>
              </div>
            </div>
          `;
        }
      });

      // Set the source
      twitchChatIframe.src = chatUrl;
      
      // Set up dropdown change handler
      streamerSelect.addEventListener('change', function() {
        const selectedStreamer = this.value;
        const newChatUrl = `https://www.twitch.tv/embed/${selectedStreamer}/chat?parent=${parentDomain}`;
        twitchChatIframe.src = newChatUrl;
        console.log(`Switched to ${selectedStreamer} chat`);
      });
      
      // Update dropdown with live streamers
      updateStreamerDropdown();
      
      console.log('Twitch chat initialized with dropdown');
    }

    function updateStreamerDropdown() {
      const streamerSelect = document.getElementById('streamer-select');
      if (!streamerSelect) return;

      // Keep the TPL main chat option
      const tplOption = streamerSelect.querySelector('option[value="tribesprofessionalleague"]');
      
      // Clear other options
      streamerSelect.innerHTML = '';
      streamerSelect.appendChild(tplOption);

      // Add live streamers if available
      if (window.twitchOAuth && window.twitchOAuth.liveStreams) {
        const liveStreams = window.twitchOAuth.liveStreams;
        
        if (liveStreams.length > 0) {
          // Add separator
          const separator = document.createElement('option');
          separator.disabled = true;
          separator.textContent = '── Live Streamers ──';
          streamerSelect.appendChild(separator);
          
          // Add live streamers
          liveStreams.forEach(stream => {
            const option = document.createElement('option');
            option.value = stream.user_name.toLowerCase();
            option.textContent = `${stream.user_name} (LIVE)`;
            streamerSelect.appendChild(option);
          });
        }
      }
    }
    window.testLiveIndicators = function() {
      console.log('=== Live Indicators Test ===');
      console.log('Twitch OAuth available:', !!window.twitchOAuth);
      console.log('Live streams data:', window.twitchOAuth?.liveStreams);
      console.log('Selected teams:', selectedTeams);
      console.log('Team rosters:', teamRosters);
      updateLivePlayerIndicators();
    };
  </script>
</body>
</html>
