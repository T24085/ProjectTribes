<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tribes Professional League | Spectating Platform</title>
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" href="Tribes Professional League.png" type="image/png">
  <style>
    :root {
      --bg-color: #030712;
      --bg-gradient: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 55%), radial-gradient(circle at 80% 30%, rgba(129, 140, 248, 0.12), transparent 60%), linear-gradient(220deg, rgba(15, 23, 42, 0.88), rgba(2, 6, 23, 0.94));
      --panel-bg: rgba(15, 23, 42, 0.82);
      --surface-glass: rgba(17, 24, 39, 0.65);
      --card-bg: rgba(13, 19, 33, 0.84);
      --text-primary: #e2e8f0;
      --text-muted: #94a3b8;
      --accent: #8b5cf6;
      --accent-strong: #38bdf8;
      --success: #22c55e;
      --danger: #f87171;
      --transition-snappy: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --shadow-xl: 0 32px 65px -25px rgba(46, 78, 155, 0.48);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', 'Segoe UI', sans-serif;
      background: var(--bg-gradient), var(--bg-color);
      color: var(--text-primary);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }

    /* Team Logo Background Pattern */
    #bg-left, #bg-right {
      position: fixed;
      top: 0;
      bottom: 0;
      width: 50%;
      opacity: 0.08;
      background-size: 150px;
      background-repeat: repeat;
      pointer-events: none;
      z-index: -1;
      transition: opacity 0.3s ease;
    }
    #bg-left { left: 0; }
    #bg-right { right: 0; }

    /* Header */
    nav#global-header {
      position: sticky;
      top: 0;
      z-index: 40;
      background: rgba(8, 11, 26, 0.85);
      border-bottom: 1px solid rgba(148, 163, 184, 0.16);
      backdrop-filter: blur(16px);
      padding: 1rem 2rem;
    }

    .header-container {
      max-width: 1440px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 2rem;
    }

    .header-brand {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-brand img {
      height: 46px;
      width: auto;
      border-radius: 0.75rem;
      background: rgba(30, 41, 59, 0.65);
      padding: 0.35rem 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .brand-title {
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      margin: 0;
    }

    .brand-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
      letter-spacing: 0.24em;
      text-transform: uppercase;
      margin: 0;
    }

    .header-nav {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .nav-link {
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      transition: background var(--transition-snappy);
    }

    .nav-link:hover {
      background: rgba(129, 140, 248, 0.2);
    }

    /* Dropdown styles */
    .nav-dropdown {
      position: relative;
    }

    .nav-dropdown button {
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      transition: background var(--transition-snappy);
      background: none;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .nav-dropdown button:hover {
      background: rgba(129, 140, 248, 0.2);
    }

    .nav-dropdown-content {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 12rem;
      background: var(--card-bg);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.75rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      padding: 0.5rem;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s ease;
    }

    .nav-dropdown:hover .nav-dropdown-content {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .nav-dropdown-content a {
      display: block;
      padding: 0.5rem 0.75rem;
      color: var(--text-primary);
      text-decoration: none;
      border-radius: 0.5rem;
      transition: background var(--transition-snappy);
      font-size: 0.9rem;
    }

    .nav-dropdown-content a:hover {
      background: rgba(129, 140, 248, 0.2);
    }

    .auth-buttons {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      transition: all var(--transition-snappy);
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(129, 140, 248, 0.3);
      border-color: rgba(129, 140, 248, 0.5);
    }

    .btn-primary {
      background: linear-gradient(135deg, rgba(129, 140, 248, 0.9), rgba(56, 189, 248, 0.9));
      border: none;
      color: #020617;
      font-weight: 700;
    }

    /* Main Container */
    .main-container {
      max-width: 1440px;
      margin: 0 auto;
      padding: 2rem;
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 2rem;
      min-height: calc(100vh - 100px);
    }

    .main-content {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    /* Spectating Section */
    .spectating-section {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }

    .spectating-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .spectating-label {
      background: var(--danger);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .team-select-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .team-select-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
    }

    /* Team Selection Modal */
    .team-selection-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .team-selection-modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 2rem;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .modal-header h3 {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
    }

    .team-selection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .team-option {
      background: var(--surface-glass);
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .team-option:hover {
      border-color: rgba(129, 140, 248, 0.5);
      transform: translateY(-2px);
    }

    .team-option.selected {
      border-color: var(--accent);
      background: rgba(139, 92, 246, 0.2);
    }

    .team-option-logo {
      width: 60px;
      height: 60px;
      margin: 0 auto 0.5rem;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .team-option-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .team-option-name {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }

    .btn-secondary {
      background: rgba(148, 163, 184, 0.2);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Match Display */
    .match-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2rem;
      margin: 1rem 0;
      position: relative;
      min-height: 200px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 12px;
      overflow: hidden;
    }

    .match-display::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.1);
      z-index: 1;
    }

    .match-display.has-background::before {
      background: rgba(0, 0, 0, 0.3);
    }

    .match-display > * {
      position: relative;
      z-index: 2;
    }

    .team-score {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .team-logo {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      overflow: hidden;
      border: 3px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .team-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .team-name {
      font-size: 1.4rem;
      font-weight: 700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      text-align: center;
      color: white;
    }

    .vs-text {
      font-size: 2rem;
      font-weight: 700;
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.3);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    /* Compact Match Display */
    .match-display-compact {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
      position: relative;
      min-height: 60px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 8px;
      overflow: hidden;
      padding: 0.5rem;
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .match-display-compact::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.1);
      z-index: 1;
    }

    .match-display-compact.has-background::before {
      background: rgba(0, 0, 0, 0.3);
    }

    .match-display-compact > * {
      position: relative;
      z-index: 2;
    }

    .team-compact {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .team-logo-compact {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .team-logo-compact img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .team-name-compact {
      font-size: 1rem;
      font-weight: 600;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      color: white;
      white-space: nowrap;
    }

    .vs-text-compact {
      font-size: 1.2rem;
      font-weight: 700;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.3);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Header Actions */
    .header-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }


    /* Responsive adjustments for compact layout */
    @media (max-width: 768px) {
      .header-actions {
        flex-direction: column;
        gap: 0.25rem;
      }
      
      .header-actions .team-select-btn,
      .header-actions .btn {
        font-size: 0.8rem;
        padding: 0.4rem 0.8rem;
      }
      
      .stream-controls {
        top: 5px;
        right: 5px;
        gap: 0.25rem;
      }
      
      .stream-controls .team-select-btn,
      .stream-controls .btn {
        font-size: 0.7rem;
        padding: 0.4rem 0.6rem;
      }
      
      .match-display-compact {
        gap: 0.5rem;
        padding: 0.25rem;
      }
      
      .team-logo-compact {
        width: 32px;
        height: 32px;
      }
      
      .team-name-compact {
        font-size: 0.9rem;
      }
      
      .vs-text-compact {
        font-size: 1rem;
        padding: 0.2rem 0.4rem;
      }
    }

    /* Player Tabs */
    .player-tabs {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .team-roster-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .team-roster-header {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
      padding: 0.5rem 1rem;
      background: rgba(139, 92, 246, 0.1);
      border-radius: 6px;
      border-left: 4px solid var(--accent);
    }

    .team-roster-tabs {
      display: flex;
      gap: 0.5rem;
      overflow-x: auto;
      padding-bottom: 0.5rem;
    }

    .team-roster-tabs::-webkit-scrollbar {
      height: 4px;
    }

    .team-roster-tabs::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
    }

    .team-roster-tabs::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 2px;
    }

    .player-tab {
      padding: 0.75rem 1rem;
      background: var(--surface-glass);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text-muted);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-snappy);
      flex-shrink: 0;
      white-space: nowrap;
    }

    .player-tab.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .player-tab:hover:not(.active) {
      background: rgba(129, 140, 248, 0.2);
      border-color: rgba(129, 140, 248, 0.3);
    }

    /* Active Stream */
    .active-stream {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      overflow: hidden;
      aspect-ratio: 16/9;
      position: relative;
    }

    .stream-frame {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Stream Controls */
    .stream-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 10;
    }

    .stream-controls .team-select-btn,
    .stream-controls .btn {
      font-size: 0.8rem;
      padding: 0.5rem 0.8rem;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      transition: all 0.2s ease;
      backdrop-filter: blur(4px);
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .stream-controls .team-select-btn:hover,
    .stream-controls .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
      background: rgba(0, 0, 0, 0.8);
    }

    /* Sidebar */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .sidebar-section {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .sidebar-section h3 {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--text-primary);
    }

    /* Voting Section */
    .voting-section {
      text-align: center;
    }

    /* Viewer Tracking Section */
    .viewer-tracking-section {
      text-align: center;
    }

    .viewer-stats-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .total-viewers {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(56, 189, 248, 0.2));
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 0.75rem;
      padding: 1rem;
    }

    .viewer-count {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-strong);
      margin-bottom: 0.25rem;
    }

    .viewer-label {
      font-size: 0.9rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .streamer-viewers {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .streamer-viewer-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      transition: all var(--transition-snappy);
      font-size: 0.85rem;
    }

    .streamer-viewer-item:hover {
      background: rgba(129, 140, 248, 0.1);
      border-color: rgba(129, 140, 248, 0.3);
    }

    .streamer-name {
      font-weight: 500;
      color: var(--text-primary);
      font-size: 0.8rem;
    }

    .streamer-count {
      font-weight: 600;
      color: var(--accent-strong);
      font-size: 0.8rem;
    }

    .viewer-trend {
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .viewer-trend.up {
      color: var(--success);
    }

    .viewer-trend.down {
      color: var(--danger);
    }

    .viewer-trend.neutral {
      color: var(--text-muted);
    }

    /* Viewer History Styles */
    .viewer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .viewer-history-btn {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      padding: 0.5rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: all var(--transition-snappy);
      font-size: 1.2rem;
    }

    .viewer-history-btn:hover {
      background: rgba(129, 140, 248, 0.2);
      border-color: rgba(129, 140, 248, 0.3);
    }

    .viewer-history-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .viewer-history-content {
      background: var(--card-bg);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 1rem;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .viewer-history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .viewer-history-header h3 {
      margin: 0;
      color: var(--text-primary);
    }

    .close-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all var(--transition-snappy);
    }

    .close-btn:hover {
      background: rgba(148, 163, 184, 0.2);
      color: var(--text-primary);
    }

    .viewer-history-body {
      padding: 1.5rem;
    }

    .history-stats {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .history-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      background: var(--surface-glass);
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
    }

    .history-label {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .history-value {
      color: var(--accent-strong);
      font-weight: 600;
      font-size: 1.1rem;
    }

    .recent-updates {
      max-height: 200px;
      overflow-y: auto;
    }

    .update-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      font-size: 0.9rem;
    }

    .update-item:last-child {
      border-bottom: none;
    }

    .update-time {
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    .update-details {
      color: var(--text-primary);
    }

    .vote-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    .vote-btn {
      flex: 1;
      padding: 0.75rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: var(--surface-glass);
      color: var(--text-primary);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .vote-btn:hover {
      border-color: var(--accent);
      background: rgba(139, 92, 246, 0.2);
    }

    .vote-btn.voted {
      border-color: var(--success);
      background: rgba(34, 197, 94, 0.2);
      color: var(--success);
    }

    /* Chat Section */
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .streamer-dropdown {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.25rem;
      color: var(--text-primary);
      padding: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
    }

    .streamer-dropdown:focus {
      outline: none;
      border-color: var(--accent);
    }



    /* Match Cards */
    .recent-matches-section {
      margin-top: 2rem;
    }

    .section-title {
      color: var(--accent);
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
      text-align: center;
    }

    .recent-matches-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
    }

    .recent-match-card {
      background: var(--card-bg);
      border-radius: 0.5rem;
      padding: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid rgba(148, 163, 184, 0.1);
      min-height: 60px;
    }

    .match-teams {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .team-info {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      min-width: 0;
    }

    .team-logo-small {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .team-name {
      font-weight: bold;
      color: var(--text-primary);
      font-size: 0.875rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .match-score {
      font-size: 1rem;
      font-weight: bold;
      color: var(--accent);
      white-space: nowrap;
      margin: 0 0.5rem;
    }

    .match-date {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
      flex-shrink: 0;
    }

    /* Twitch Chat Section */
    .twitch-chat-section {
      margin-top: 1rem;
    }

    .twitch-chat-container {
      background: var(--card-bg);
      border-radius: 0.5rem;
      overflow: hidden;
      position: relative;
      z-index: 10;
      isolation: isolate;
      width: 100%;
      height: 500px;
    }
    
    .twitch-chat-container iframe {
      position: relative;
      z-index: 10;
      background: transparent;
    }

    /* Player Stats Styles */
    .player-stats-section {
      margin-bottom: 1.5rem;
    }

    .player-stats-display {
      padding: 1rem;
    }

    .player-stats-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: var(--surface-glass);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      transition: all var(--transition-snappy);
    }

    .stat-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .stat-rate {
      font-size: 0.9rem;
      color: var(--accent);
      font-weight: 600;
    }

    .stats-chart-container {
      background: var(--surface-glass);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .stats-chart-container canvas {
      max-height: 300px;
    }

    .stats-loading {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
    }

    /* Team Stats Styles */
    .team-stats-section {
      margin-bottom: 1.5rem;
    }

    .team-stats-display {
      background: var(--card-bg);
      border-radius: 1rem;
      padding: 2rem;
      max-width: 900px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .team-stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .team-stats-card {
      background: var(--surface-glass);
      padding: 1.5rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
    }

    .team-stats-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .team-stats-header img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
    }

    .team-stats-header h3 {
      color: var(--text-primary);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .team-metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
    }

    .team-metric {
      text-align: center;
      padding: 1rem;
      background: rgba(148, 163, 184, 0.05);
      border-radius: 0.5rem;
    }

    .team-metric-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--accent-strong);
      margin-bottom: 0.25rem;
    }

    .team-metric-label {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .team-comparison {
      background: var(--surface-glass);
      padding: 1.5rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
      margin-top: 1.5rem;
    }

    .comparison-header {
      text-align: center;
      margin-bottom: 1.5rem;
      color: var(--text-primary);
      font-size: 1.125rem;
      font-weight: 600;
    }

    .comparison-grid {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 1rem;
      align-items: center;
    }

    .comparison-team {
      text-align: center;
    }

    .comparison-vs {
      color: var(--text-muted);
      font-weight: 600;
      font-size: 1.125rem;
    }

    .comparison-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
    }

    .comparison-metric:last-child {
      border-bottom: none;
    }

    .comparison-metric-label {
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .comparison-metric-values {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .comparison-value {
      font-weight: 600;
      min-width: 40px;
      text-align: center;
    }

    .comparison-value.winner {
      color: var(--success);
    }

    .comparison-value.loser {
      color: var(--danger);
    }

    /* Team Line Chart Styles */
    .team-line-chart {
      margin-top: 2rem;
      padding: 1.5rem;
      background: var(--surface-glass);
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
    }

    .chart-header {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }

    /* Admin Login Form Styles */
    .login-form {
      max-width: 400px;
      margin: 0 auto;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      color: var(--text-primary);
      font-weight: 500;
      margin-bottom: 0.5rem;
    }

    .form-group input[type="email"],
    .form-group input[type="password"] {
      width: 100%;
      padding: 0.75rem;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
    }

    .form-group input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .error-message {
      text-align: center;
      font-size: 0.875rem;
    }

    /* Admin Panel Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .modal-content {
      background: var(--card-bg);
      border-radius: 1rem;
      padding: 0;
      max-width: 600px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .modal-header h2 {
      color: var(--text-primary);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .modal-body {
      padding: 1.5rem;
    }

    .admin-section {
      margin-bottom: 2rem;
    }

    .admin-section h3 {
      color: var(--text-primary);
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .current-match {
      background: var(--surface-glass);
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
      color: var(--text-primary);
    }

    .match-selector {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .team-selector {
      flex: 1;
    }

    .team-selector label {
      display: block;
      color: var(--text-primary);
      font-weight: 500;
      margin-bottom: 0.5rem;
    }

    .form-select {
      width: 100%;
      padding: 0.75rem;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .vs-divider {
      color: var(--text-muted);
      font-weight: 600;
      font-size: 1.125rem;
    }

    .admin-actions {
      display: flex;
      gap: 1rem;
    }

    .live-status {
      background: var(--surface-glass);
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.1);
      color: var(--text-primary);
    }

    /* Live Player Indicators */
    .player-tab.live {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.4), rgba(22, 163, 74, 0.3)) !important;
      border: 3px solid rgba(34, 197, 94, 1) !important;
      color: #ffffff !important;
      box-shadow: 0 0 25px rgba(34, 197, 94, 0.8), 0 0 50px rgba(34, 197, 94, 0.6), inset 0 0 20px rgba(34, 197, 94, 0.2) !important;
      animation: livePulse 2s ease-in-out infinite;
      position: relative;
      font-weight: bold !important;
      transform: scale(1.05);
      z-index: 10;
    }

    /* Donation System Styles */
    .donation-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    .donation-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(147, 51, 234, 0.95), rgba(59, 130, 246, 0.95));
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 1rem;
      padding: 2rem 3rem;
      color: white;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      animation: donationPop 3s ease-out forwards;
      z-index: 1001;
    }

    .donation-amount {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .donation-message {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      opacity: 0.9;
    }

    .donation-from {
      font-size: 1rem;
      opacity: 0.8;
      font-style: italic;
    }

    @keyframes donationPop {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
    }

    /* Confetti particles */
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff6b6b;
      animation: confetti-fall 3s linear infinite;
    }

    .confetti:nth-child(2n) { background: #4ecdc4; }
    .confetti:nth-child(3n) { background: #45b7d1; }
    .confetti:nth-child(4n) { background: #f9ca24; }
    .confetti:nth-child(5n) { background: #f0932b; }
    .confetti:nth-child(6n) { background: #eb4d4b; }
    .confetti:nth-child(7n) { background: #6c5ce7; }
    .confetti:nth-child(8n) { background: #a29bfe; }

    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Donation buttons */
    .donation-buttons {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      z-index: 100;
    }

    .donation-btn {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .donation-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
    }

    .donation-btn.bits {
      background: linear-gradient(135deg, #9146ff, #772ce8);
      box-shadow: 0 4px 15px rgba(145, 70, 255, 0.4);
    }

    .donation-btn.bits:hover {
      box-shadow: 0 6px 20px rgba(145, 70, 255, 0.6);
    }

    .donation-btn.channel-points {
      background: linear-gradient(135deg, #00d4aa, #00b894);
      box-shadow: 0 4px 15px rgba(0, 212, 170, 0.4);
    }

    .donation-btn.channel-points:hover {
      box-shadow: 0 6px 20px rgba(0, 212, 170, 0.6);
    }

    .player-tab.live:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.2));
      border-color: rgba(34, 197, 94, 0.8);
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.4);
    }

    .player-tab.live::before {
      content: "🔴 LIVE";
      margin-right: 0.5rem;
      font-size: 0.7rem;
      font-weight: bold;
      animation: liveBlink 1.5s ease-in-out infinite;
      text-shadow: 0 0 5px rgba(255, 0, 0, 0.8);
    }

    @keyframes livePulse {
      0%, 100% {
        box-shadow: 0 0 15px rgba(34, 197, 94, 0.4), 0 0 30px rgba(34, 197, 94, 0.2);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.4);
        transform: scale(1.02);
      }
    }

    @keyframes liveBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .live-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
      margin-right: 0.5rem;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Poll Management Styles */
    .poll-management {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }
    .current-poll {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      padding: 1rem;
    }
    .current-poll h4 {
      color: var(--text-primary);
      margin-bottom: 1rem;
      font-size: 1rem;
    }
    .poll-actions {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      padding: 1rem;
    }
    .poll-actions h4 {
      color: var(--text-primary);
      margin-bottom: 1rem;
      font-size: 1rem;
    }
    .poll-actions .form-group {
      margin-bottom: 1rem;
    }
    .poll-actions .form-group label {
      display: block;
      color: var(--text-primary);
      font-weight: 500;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
    }
    .poll-actions .form-group input {
      width: 100%;
      padding: 0.75rem;
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
    }
    .poll-actions .form-group input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }
    
    .current-poll-content h5 {
      color: var(--text-primary);
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }
    .poll-options {
      margin-bottom: 1rem;
    }
    .poll-option {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      background: rgba(148, 163, 184, 0.1);
      border-radius: 0.25rem;
    }
    .option-number {
      font-weight: 600;
      margin-right: 0.5rem;
      color: var(--accent);
    }
    .option-text {
      color: var(--text-primary);
    }
    .poll-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 1rem;
    }

    /* Footer */
    footer {
      background: var(--card-bg);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding: 2rem;
      text-align: center;
      color: var(--text-muted);
      margin-top: 2rem;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .main-container {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      .sidebar {
        order: -1;
      }
    }

    @media (max-width: 1200px) {
      .main-container {
        grid-template-columns: 1fr 350px;
      }
    }

    @media (max-width: 768px) {
      .main-container {
        padding: 1rem;
      }

      .header-container {
        flex-direction: column;
        gap: 1rem;
      }

      .header-nav {
        flex-wrap: wrap;
        justify-content: center;
      }

      .match-display {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }

      .vs-text {
        order: -1;
      }
    }

    /* Event Streams Sidebar */
    .event-streams-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-snappy);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
    }

    .event-streams-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
    }

    .stream-count {
      background: var(--danger);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 700;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .event-streams-sidebar {
      position: fixed;
      top: 0;
      right: -500px;
      width: 500px;
      height: 100vh;
      background: var(--card-bg);
      border-left: 1px solid rgba(148, 163, 184, 0.16);
      backdrop-filter: blur(16px);
      z-index: 50;
      transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow-y: auto;
      box-shadow: -10px 0 30px rgba(0, 0, 0, 0.3);
    }

    .event-streams-sidebar.open {
      right: 0;
    }

    .sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 45;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .sidebar-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .sidebar-header {
      padding: 1.5rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.16);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--panel-bg);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .sidebar-header h3 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1.25rem;
      font-weight: 700;
    }

    .close-sidebar {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all var(--transition-snappy);
    }

    .close-sidebar:hover {
      background: rgba(148, 163, 184, 0.1);
      color: var(--text-primary);
    }

    .sidebar-content {
      padding: 1rem;
    }

    .event-stream-preview {
      background: var(--surface-glass);
      border: 1px solid rgba(148, 163, 184, 0.16);
      border-radius: 0.75rem;
      margin-bottom: 1rem;
      cursor: pointer;
      transition: all var(--transition-snappy);
      position: relative;
      overflow: hidden;
    }

    .event-stream-preview:hover {
      border-color: var(--accent-strong);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .event-stream-preview.live {
      border-color: var(--success);
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
    }

    .event-stream-preview.live::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--success);
      z-index: 2;
    }

    .stream-preview-header {
      padding: 0.75rem;
      background: var(--panel-bg);
      border-bottom: 1px solid rgba(148, 163, 184, 0.16);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .stream-preview-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.9rem;
      line-height: 1.2;
      flex: 1;
      margin-right: 0.5rem;
    }

    .stream-preview-category {
      background: var(--accent);
      color: white;
      padding: 0.2rem 0.4rem;
      border-radius: 0.25rem;
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .stream-preview-iframe {
      width: 100%;
      height: 120px;
      border: none;
      background: #000;
      position: relative;
    }

    .stream-preview-loading {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #333;
      border-top: 2px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 8px;
    }

    .loading-text, .error-text {
      color: #888;
      font-size: 12px;
      text-align: center;
    }

    .error-text {
      color: var(--danger);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .stream-preview-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity var(--transition-snappy);
      z-index: 1;
      pointer-events: none;
    }

    .event-stream-preview:hover .stream-preview-overlay {
      opacity: 0.8;
      pointer-events: auto;
    }

    .stream-preview-play-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all var(--transition-snappy);
    }

    .stream-preview-play-btn:hover {
      background: #7c3aed;
      transform: scale(1.1);
    }

    .stream-preview-info {
      padding: 0.5rem 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--surface-glass);
    }

    .stream-preview-viewers {
      color: var(--text-muted);
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .stream-preview-status {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.75rem;
    }

    .status-live {
      color: var(--success);
      font-weight: 600;
    }

    .status-offline {
      color: var(--text-muted);
    }

    .live-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      animation: livePulse 2s ease-in-out infinite;
    }

    .no-events {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
      font-style: italic;
    }

    /* Responsive Design for Event Streams */
    @media (max-width: 768px) {
      .event-streams-sidebar {
        width: 100%;
        right: -100%;
      }

      .event-streams-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <!-- Team Logo Background Pattern -->
  <div id="bg-left"></div>
  <div id="bg-right"></div>
  
  <!-- Header -->
  <nav id="global-header">
    <div class="header-container">
      <div class="header-brand">
        <img src="Tribes Professional League.png" alt="Tribes Professional League logo" onerror="this.style.display='none'">
        <div>
          <h1 class="brand-title">Tribes Professional League</h1>
          <p class="brand-subtitle">Spectating Platform</p>
        </div>
      </div>
      <div class="header-nav">
        <a href="index.html" class="nav-link">Main</a>
        <a href="Schedule.html" class="nav-link">Matches</a>
        <a href="LadderBoard.html" class="nav-link">Ladder</a>
        <a href="PlayerStats.html" class="nav-link">Statistics</a>
        <a href="News.html" class="nav-link">News</a>
        <div class="nav-dropdown">
          <button>
            Admin
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
            </svg>
          </button>
          <div class="nav-dropdown-content">
            <a href="LeagueManager.html">League Manager</a>
            <a href="TournamentManager.html">Tournament Manager</a>
            <a href="MatchStatsAdmin.html">Match Stats Admin</a>
            <a href="NewsAdmin.html">News Admin</a>
            <a href="StreamersAdmin.html">Streamers Admin</a>
          </div>
        </div>
      </div>
      <div class="auth-buttons">
        <button id="event-streams-toggle" class="event-streams-btn">
          <span>Event Streams</span>
          <span class="stream-count" id="event-stream-count">0</span>
        </button>
        <button id="admin-login-btn" class="btn btn-secondary" style="display: none;">Admin Login</button>
        <button id="admin-panel-btn" class="btn btn-secondary" style="display: none;">Admin Panel</button>
        <button id="admin-logout-btn" class="btn btn-danger" style="display: none;">Logout</button>
        <button id="twitch-login-btn" class="btn btn-primary">Sign in with Twitch</button>
        <span id="twitch-user" style="display: none; color: var(--text-muted); font-size: 0.9rem;"></span>
      </div>
    </div>
  </nav>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">

      <!-- Active Stream -->
      <div class="active-stream">
        <iframe class="stream-frame" id="stream-frame" src="https://player.twitch.tv/?channel=oo0oo_live&autoplay=false" allowfullscreen></iframe>
        <!-- Stream Controls -->
        <div class="stream-controls">
          <button class="team-select-btn" id="caster-btn" style="background: #f59e0b;">Load Caster (0o0o0)</button>
          <button id="show-team-stats-btn" class="btn btn-secondary">View Team Stats</button>
        </div>
      </div>

      <!-- Player Tabs -->
      <div class="player-tabs" id="player-tabs">
        <!-- Player tabs will be populated here -->
      </div>

      <!-- Match Display -->
      <div class="match-display-compact" id="match-display">
        <div class="team-compact" id="team-a-display">
          <div class="team-logo-compact" id="team-a-logo">
            <img src="images/TeamDPRKLogo3.png" alt="Team A" onerror="this.style.display='none'">
          </div>
          <div class="team-name-compact" id="team-a-name">Team A</div>
        </div>
        <div class="vs-text-compact">VS</div>
        <div class="team-compact" id="team-b-display">
          <div class="team-logo-compact" id="team-b-logo">
            <img src="images/TeamDPRKLogo3.png" alt="Team B" onerror="this.style.display='none'">
          </div>
          <div class="team-name-compact" id="team-b-name">Team B</div>
        </div>
      </div>

      <!-- Player Stats Section -->
      <div class="player-stats-section" id="player-stats-section" style="display: none;">
        <div class="spectating-section">
          <div class="spectating-header">
            <div class="spectating-label">Player Statistics</div>
            <button class="team-select-btn" id="close-stats-btn">Close Stats</button>
        </div>
          <div id="player-stats-content">
            <div class="stats-loading">Loading player statistics...</div>
          </div>
        </div>
      </div>

      <!-- Team Stats Section -->
      <div class="team-stats-section" id="team-stats-section" style="display: none;">
        <div class="spectating-section">
          <div class="spectating-header">
            <div class="spectating-label">Team Statistics</div>
            <button class="team-select-btn" id="close-team-stats-btn">Close Stats</button>
          </div>
          <div id="team-stats-content">
            <div class="stats-loading">Loading team statistics...</div>
          </div>
        </div>
      </div>

      <!-- Admin Login Modal -->
      <div id="admin-login-modal" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Admin Login</h2>
            <button id="close-admin-login-modal" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            <div class="admin-section">
              <div class="login-form">
                <div class="form-group">
                  <label for="admin-email">Email:</label>
                  <input id="admin-email" type="email" class="form-select" placeholder="Enter admin email">
                </div>
                <div class="form-group">
                  <label for="admin-password">Password:</label>
                  <input id="admin-password" type="password" class="form-select" placeholder="Enter password">
                </div>
                <div class="admin-actions">
                  <button id="admin-login-submit" class="btn btn-primary">Login</button>
                  <button id="cancel-admin-login" class="btn btn-secondary">Cancel</button>
                </div>
                <div id="admin-login-error" class="error-message" style="display: none; color: var(--danger); margin-top: 1rem;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Admin Panel Modal -->
      <div id="admin-modal" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Admin Panel - Set Active Match</h2>
            <button id="close-admin-modal" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            <div class="admin-section">
              <h3>Current Active Match</h3>
              <div id="current-match-display" class="current-match">
                <p>No active match set</p>
              </div>
            </div>
            
            <div class="admin-section">
              <h3>Set New Active Match</h3>
              <div class="match-selector">
                <div class="team-selector">
                  <label for="admin-team-a">Team A:</label>
                  <select id="admin-team-a" class="form-select">
                    <option value="">Select Team A</option>
                  </select>
                </div>
                <div class="vs-divider">VS</div>
                <div class="team-selector">
                  <label for="admin-team-b">Team B:</label>
                  <select id="admin-team-b" class="form-select">
                    <option value="">Select Team B</option>
                  </select>
                </div>
              </div>
              <div class="admin-actions">
                <button id="set-active-match" class="btn btn-primary">Set Active Match</button>
                <button id="clear-active-match" class="btn btn-danger">Clear Match</button>
              </div>
            </div>
            
            <div class="admin-section">
              <h3>Live Player Status</h3>
              <div id="live-players-status" class="live-status">
                <p>Checking live status...</p>
              </div>
            </div>
            
            <div class="admin-section">
              <h3>Vote Polls</h3>
              <div class="poll-management">
                <div class="current-poll">
                  <h4>Current Poll</h4>
                  <div id="current-poll-display">
                    <p>No active poll</p>
                  </div>
                </div>
                
                <div class="poll-actions">
                  <h4>Create/Edit Poll</h4>
                  <div class="form-group">
                    <label for="poll-question">Poll Question:</label>
                    <input id="poll-question" type="text" class="form-select" placeholder="Enter poll question">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-1">Option 1:</label>
                    <input id="poll-option-1" type="text" class="form-select" placeholder="First option">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-2">Option 2:</label>
                    <input id="poll-option-2" type="text" class="form-select" placeholder="Second option">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-3">Option 3 (optional):</label>
                    <input id="poll-option-3" type="text" class="form-select" placeholder="Third option">
                  </div>
                  <div class="form-group">
                    <label for="poll-option-4">Option 4 (optional):</label>
                    <input id="poll-option-4" type="text" class="form-select" placeholder="Fourth option">
                  </div>
                  <div class="admin-actions">
                    <button id="save-poll" class="btn btn-primary">Save Poll</button>
                    <button id="clear-poll" class="btn btn-danger">Clear Poll</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Recent Matches -->
      <div class="recent-matches-section">
        <h3 class="section-title">Recent Matches</h3>
        <div class="recent-matches-grid" id="recent-matches-grid">
          <!-- Recent matches will be populated here -->
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Twitch Chat Section -->
      <div class="sidebar-section chat-section">
        <div class="chat-header">
          <h3>Live Chat</h3>
          <select id="streamer-select" class="streamer-dropdown">
            <option value="oo0oo_live">0o0o0 (Caster)</option>
            <option value="tribesprofessionalleague">TPL Main Chat</option>
          </select>
        </div>
        <div class="twitch-chat-container">
          <div class="chat-loading" style="display: flex; align-items: center; justify-content: center; height: 500px; background: var(--surface-glass); border-radius: 0.5rem; color: var(--text-muted);">
            <div class="text-center">
              <div class="animate-spin inline-block w-6 h-6 border-2 border-blue-600 border-t-transparent rounded-full mb-2"></div>
              <div>Connecting to Chat...</div>
            </div>
          </div>
          <iframe id="twitch-chat-iframe" src="about:blank" style="width: 100%; height: 500px; border: none; border-radius: 0.5rem; display: none; position: relative; z-index: 1;"></iframe>
        </div>
        
      </div>

      <!-- Voting Section -->
      <div class="sidebar-section voting-section">
        <h3>Vote for Winner</h3>
        <div class="vote-buttons">
          <button class="vote-btn" id="vote-team-a">Team A</button>
          <button class="vote-btn" id="vote-team-b">Team B</button>
        </div>
      </div>

      <!-- Viewer Tracking Section -->
      <div class="sidebar-section viewer-tracking-section">
        <div class="viewer-header">
          <h3>Live Viewers</h3>
          <button id="viewer-history-btn" class="viewer-history-btn" title="View viewer history">
            📊
          </button>
        </div>
        <div class="viewer-stats-container">
          <div class="total-viewers">
            <div class="viewer-count" id="total-viewer-count">0</div>
            <div class="viewer-label">Total Viewers</div>
          </div>
          <div class="streamer-viewers" id="streamer-viewers-list">
            <!-- Individual streamer viewer counts will be populated here -->
          </div>
        </div>
        
        <!-- Viewer History Modal -->
        <div id="viewer-history-modal" class="viewer-history-modal" style="display: none;">
          <div class="viewer-history-content">
            <div class="viewer-history-header">
              <h3>Viewer History</h3>
              <button id="close-viewer-history" class="close-btn">×</button>
            </div>
            <div class="viewer-history-body">
              <div id="viewer-history-chart" class="viewer-history-chart">
                <!-- Simple text-based history for now -->
                <div class="history-stats">
                  <div class="history-item">
                    <span class="history-label">Peak Viewers Today:</span>
                    <span class="history-value" id="peak-viewers-today">0</span>
                  </div>
                  <div class="history-item">
                    <span class="history-label">Average Viewers:</span>
                    <span class="history-value" id="avg-viewers">0</span>
                  </div>
                  <div class="history-item">
                    <span class="history-label">Total View Time:</span>
                    <span class="history-value" id="total-view-time">0h 0m</span>
                  </div>
                </div>
                <div class="recent-updates" id="recent-viewer-updates">
                  <!-- Recent viewer updates will be shown here -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>


    </div>
  </div>

  <!-- Footer -->
  <footer>
    <p>&copy; 2024 Tribes Professional League. All rights reserved.</p>
  </footer>

  <!-- Load OAuth functionality -->
  <script src="oauth.js?v=2"></script>
  <!-- Load Chart.js for player stats -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  
  <!-- Confetti.js for vote celebrations -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, getDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB_ksHlcP2P9cT5jbo2IAGxbQ4zgEODkyM",
      authDomain: "team-sign-up-b5646.firebaseapp.com",
      projectId: "team-sign-up-b5646",
      storageBucket: "team-sign-up-b5646.firebasestorage.app",
      messagingSenderId: "951471144681",
      appId: "1:951471144681:web:a2458675ce73ce9ad9ba78"
    };

    const firebaseApp = initializeApp(firebaseConfig);
    const db = getFirestore(firebaseApp);
    const auth = getAuth();
    
    // Make Firebase available globally for Twitch handle loading
    window.firebase = {
      firestore: () => db,
      auth: auth
    };
    
    // Admin UIDs from LeagueManager.html
    const ADMIN_UIDS = [
      'DkBHsCzLK5a9KiX50g0pHJrEqGq2',
      'A2ZV8vziNsXqZkyqHzAB266B9pP2'
    ];

    const TEAM_DATA = {
      'AV!': { 
        logo: 'images/aV!.png', 
        name: 'Avalanche', 
        folder: 'AV!',
        roster: "Players: TritiumJones, BakaToma, Vorpalkitty, Franchez, Dean, Ggglygy, Wriggles, Blitz, Hosh, Luna, Def_Monk",
        streams: [
          { name: 'Wriggles', url: 'https://www.twitch.tv/wrigglespk' },
          { name: 'TritiumJones', url: 'https://www.twitch.tv/tritiumjones' },
          { name: 'Dean', url: 'https://www.twitch.tv/wholuvsdean' },
          { name: 'PROJ', url: 'https://www.twitch.tv/prj_tv' },
          { name: 'Ggglygy', url: 'https://www.twitch.tv/ggglygy' },
          { name: 'BakaToma', url: 'https://www.twitch.tv/bakatoma1' },
          { name: 'Def_Monk (YT)', url: 'https://www.youtube.com/@defmonk0/streams' }
        ]
      },
      'EPI': { 
        logo: 'https://github.com/T24085/Team-ePi/blob/main/ePi.png?raw=true', 
        name: 'ePidemic', 
        folder: 'EPI',
        roster: "Captain: @[ePi] Convik\nCore: Goshawk, Emma, Nanox, Blu, TartarosK\nBench: apo",
        streams: [
          { name: 'Kenxai', url: 'https://www.twitch.tv/kenxai' },
          { name: 'Makasuro', url: 'https://www.twitch.tv/makasuro' }
        ]
      },
      'DPRK': { 
        logo: 'https://github.com/T24085/TeamDPRK/blob/main/TeamDPRKLogo3.png?raw=true', 
        name: 'DPRK', 
        folder: 'DPRK',
        roster: "Roster information not available.",
        streams: [
          { name: 'CheezeCaek', url: 'https://www.twitch.tv/cheezecaek' },
          { name: 'silynn', url: 'https://www.twitch.tv/cheddox' },
          { name: 'ColonelFatso', url: 'https://www.twitch.tv/colonelfatso' },
          { name: 'Pandora', url: 'https://www.twitch.tv/pandoracast' },
          { name: 'Nemesis', url: 'https://www.twitch.tv/seansguitarworldbang' }
        ]
      },
      'Zen': { 
        logo: 'https://github.com/T24085/Team-Zen/blob/main/Zenlogo.png?raw=true', 
        name: 'Zen', 
        folder: 'ZEN',
        roster: "Captain: @ℨ Gigz\nCore: Beamz, Hydroxide, Gnome, Slyce, Mikesters, Twin\nBench: Flocks\nNote: DM Cats/Glem to update the roster",
        streams: [
          { name: 'Mikesters', url: 'https://www.twitch.tv/mikesters17' },
          { name: 'Nikebeamz', url: 'https://www.twitch.tv/nikebeamz' },
          { name: 'Gnome', url: 'https://www.twitch.tv/gnome827' }
        ]
      },
      'TXM': { 
        logo: 'https://github.com/T24085/Team-TXM/blob/main/TXM.png?raw=true', 
        name: 'Texas Militia', 
        folder: 'TXM',
        roster: "Captain: @OperationCats (LO/LD)\nCore: Prizzo, Cryof, Amyou, Thatguy, Visis, Jive, freefood, Howsya\nBench: Txredneck",
        streams: [
          { name: 'Prizzo', url: 'https://www.twitch.tv/prizzo4real' },
          { name: 'OperationCats', url: 'https://www.twitch.tv/operationcats' },
          { name: 'Goshawk', url: 'https://www.twitch.tv/g0shawk' },
          { name: 'Visis', url: 'https://www.twitch.tv/visisgaming' },
          { name: 'Cryof', url: 'https://www.twitch.tv/cryofzshooter' },
          { name: 'Jive', url: 'https://www.twitch.tv/heavenlyjive' },
          { name: 'Amyou', url: 'https://www.twitch.tv/iamyougaming' },
          { name: 'freefood', url: 'https://www.twitch.tv/freefoodd' },
          { name: 'Howsya', url: 'https://www.twitch.tv/howsya' }
        ]
      },
      'FPS': { 
        logo: 'https://github.com/T24085/Team-FPS/blob/main/FPSlogo.png?raw=true', 
        name: 'Flag Pole Smokers', 
        folder: 'FPS',
        roster: "Captain: @S...\nCore: Brit, Icedwinds, Dugong, Beldark, Realhumanbeing, Simmons, Nightstar\nBench: Kilfaxi, Morokor",
        streams: [
          { name: 'SulliedSoc', url: 'https://www.twitch.tv/SulliedSoc' },
          { name: 'Beldark', url: 'https://www.twitch.tv/beldarkk' },
          { name: 'Simmons', url: 'https://www.twitch.tv/simmons572' }
        ]
      },
      'FT': { 
        logo: 'https://github.com/T24085/Team-FT/blob/main/FTlogo.png?raw=true', 
        name: 'Flying Tractors', 
        folder: 'FT',
        roster: "Players: playb0x, Bizow, Zao, nato, LightningMcMeme, Bazz-B, didjital\nBench: bgkillas, Dreadtitan, Orvid",
        streams: [
          { name: 'Bizow', url: 'https://www.twitch.tv/bizow' },
          { name: 'Zao', url: 'https://www.twitch.tv/zao' },
          { name: 'Bazz-B', url: 'https://www.twitch.tv/bazzb' },
          { name: 'didjital', url: 'https://www.twitch.tv/didjital' },
          { name: 'bgkillas', url: 'https://www.twitch.tv/bgkillas' },
          { name: 'Orvid', url: 'https://www.twitch.tv/orvid' },
          { name: 'nato', url: 'https://www.twitch.tv/natopotato262' },
          { name: 'playb0x', url: 'https://www.twitch.tv/playb0x' },
          { name: 'Dreadtitan', url: 'https://www.twitch.tv/dreadtitan' }
        ]
      },
      'HoE': { 
        logo: 'https://github.com/T24085/Team-HOE/blob/main/HoE.png?raw=true', 
        name: 'Hegemony of Euros', 
        folder: 'HOE',
        roster: "Captain: @[ɧơɛ] Katar Xwokark\nCore: Gotlub, Mansku, Lord Buschguy, björnbär, Waffleking, TribalChief\nBench: cym3, Gwej, tumi, ThermoFlux, unam",
        streams: [
          { name: 'Katar', url: 'https://www.twitch.tv/karolk10' },
          { name: 'gwej', url: 'https://www.twitch.tv/gwej' },
          { name: 'cym3', url: 'https://www.twitch.tv/cymm3' },
          { name: 'LordBuschguy', url: 'https://www.twitch.tv/lordbuschguy' },
          { name: 'Gotlub', url: 'https://www.twitch.tv/gotlub' },
          { name: 'Mansku', url: 'https://www.twitch.tv/mansku' },
          { name: 'björnbär', url: 'https://www.twitch.tv/bjornbar' },
          { name: 'Waffleking', url: 'https://www.twitch.tv/waffleking' },
          { name: 'TribalChief', url: 'https://www.twitch.tv/tribalchief' },
          { name: 'tumi', url: 'https://www.twitch.tv/tumi' },
          { name: 'ThermoFlux', url: 'https://www.twitch.tv/thermoflux' },
          { name: 'unam', url: 'https://www.twitch.tv/unam' }
        ]
      },
      'WIZ': { 
        logo: 'https://github.com/T24085/Team-Magic/blob/main/Magic.png?raw=true', 
        name: 'Magic', 
        folder: 'WIZ',
        roster: "Captain: @[wiz] Lange\nCore: Rebeltrooper, XRY, Dust, Cinnamon, Songsteal, Sek, SplitSecond\nBench: Snakke, Lester",
        streams: [
          { name: 'XRY', url: 'https://www.twitch.tv/xry_tv' },
          { name: 'Splitsecond', url: 'https://www.twitch.tv/splitsecondta' },
          { name: 'Howsya', url: 'https://www.twitch.tv/howsya' },
          { name: 'Vaxity', url: 'https://www.twitch.tv/vaxitylol' }
        ]
      },
      'DS': { 
        logo: 'DeadStopLogo.png', 
        name: 'DeadStop', 
        folder: 'DS',
        roster: "Captain: Blitz\nCore: apc, Hosh, Luna, Rock, Rell, Iinferno, Makasuro, CheesyDean, ContingencyPlan\nBench: Nykie4Life",
        streams: [
          { name: 'iinferno', url: 'https://www.twitch.tv/bschrift/video/2399902418' },
          { name: 'Paprika (YT)', url: 'https://www.youtube.com/@0Luna_' },
          { name: 'Blitz', url: 'https://www.twitch.tv/slohp0k3' },
          { name: 'apc', url: 'https://www.twitch.tv/apcizzle' },
          { name: 'Makasuro', url: 'https://www.twitch.tv/makasuro' }
        ]
      },
      'UE': { 
        logo: 'https://github.com/T24085/Team-UE/blob/main/UE.png?raw=true', 
        name: 'Unhandled Exception', 
        folder: 'UE',
        roster: "Captain: @[-UE-] - Season 1 TPL-O\nPlayers: Loot, DeadManwalking, Pablo, ContingencyPlan\nBench: kilshot, Caricature, Stimula, Demontoe, Expungebob, Shadowwalker140i, hawxter, Anni, guruizzy",
        streams: [
          { name: 'Loot', url: 'https://www.twitch.tv/ghost_loot' },
          { name: 'DeadManwalking', url: 'https://www.youtube.com/@DeadManWalking-UF-/streams' },
          { name: 'Pablo', url: 'https://www.twitch.tv/eltimablo' },
          { name: 'ContingencyPlan', url: 'https://www.twitch.tv/contingencyplan' },
          { name: 'kilshot', url: 'https://www.twitch.tv/kilshot' },
          { name: 'Caricature', url: 'https://www.twitch.tv/caricature' },
          { name: 'Stimula', url: 'https://www.twitch.tv/stimula' },
          { name: 'Demontoe', url: 'https://www.twitch.tv/demontoe' },
          { name: 'Expungebob', url: 'https://www.twitch.tv/expungebob' },
          { name: 'Shadowwalker140i', url: 'https://www.twitch.tv/shadowwalker140i' },
          { name: 'hawxter', url: 'https://www.twitch.tv/hawxter' },
          { name: 'Anni', url: 'https://www.twitch.tv/anni' },
          { name: 'guruizzy', url: 'https://www.twitch.tv/guruizzy' }
        ]
      },
      'KTL': { 
        logo: 'https://github.com/T24085/Team-KTL/blob/main/KTLlogo.png?raw=true', 
        name: 'Kicked to Lobby', 
        folder: 'KTL',
        roster: "Captain: @n0xide\nCore: =ACE=, Navy, ctrl, kwago, Paragon, SecondSight, Torment, Alphakrab",
        streams: [
          { name: 'n0xide', url: 'https://www.twitch.tv/n0xide' },
          { name: 'isoitiro', url: 'https://www.twitch.tv/isoitiro' },
          { name: 'Navy', url: 'https://www.twitch.tv/navy' },
          { name: 'ctrl', url: 'https://www.twitch.tv/ctrl' },
          { name: 'kwago', url: 'https://www.twitch.tv/kwago' },
          { name: 'Paragon', url: 'https://www.twitch.tv/paragon' },
          { name: 'SecondSight', url: 'https://www.twitch.tv/secondsight' },
          { name: 'Torment', url: 'https://www.twitch.tv/torment' },
          { name: 'Alphakrab', url: 'https://www.twitch.tv/alphakrab' }
        ]
      },
      'Null': { 
        logo: 'https://github.com/T24085/Team-Null/blob/main/NullLogo.png?raw=true', 
        name: 'null', 
        folder: 'Null',
        roster: "Captain: @_...\nCore: Blaspheme, Annaberries, xQ, muuki, exhumaxer, corbeling, mikeax2\nBench: ryan",
        streams: [
          { name: 'mikeax2', url: 'https://www.twitch.tv/mikeax2' },
          { name: 'z4t01', url: 'https://www.twitch.tv/z4t01' }
        ]
      },
      'TA': { 
        logo: 'https://github.com/T24085/Team-Toxic-Aimers/blob/main/ToxicAimersLogo.png?raw=true', 
        name: 'Toxic Aimers', 
        folder: 'TA',
        roster: "Captain: @R...\nCore: Song, Sek, Hatuey, DareDevilMoon, Nerve, Radishblue, Trey\nBench: Sin, Stork",
        streams: [
          { name: 'Stork', url: 'https://www.twitch.tv/storksoofly' }
        ]
      }
    };

    // Function to find team data by name (handles variations in team names)
    function findTeamData(teamName) {
      if (!teamName) return null;
      
      // Direct key match
      if (TEAM_DATA[teamName]) {
        return TEAM_DATA[teamName];
      }
      
      // Try to find by name property
      for (const [key, teamData] of Object.entries(TEAM_DATA)) {
        if (teamData.name === teamName) {
          return teamData;
        }
      }
      
      // Handle common variations - map full names to abbreviations
      const variations = {
        'Avalanche!': 'AV!',
        'Avalanche': 'AV!',
        'ePidemic': 'EPI',
        'Hegemony of Euros': 'HoE',
        'Flying Tractors': 'FT',
        'Flag Pole Smokers': 'FPS',
        'Toxic Aimers': 'TA',
        'Texas Militia': 'TXM',
        'Kicked to Lobby': 'KTL',
        'Unhandled Exception': 'UE',
        'Magic': 'WIZ',
        'DeadStop': 'DS',
        'null': 'Null'
      };
      
      if (variations[teamName]) {
        return TEAM_DATA[variations[teamName]];
      }
      
      console.log(`No team data found for: ${teamName}`);
      return null;
    }

    let selectedTeams = { teamA: null, teamB: null };
    let teamRosters = {};

    document.addEventListener('DOMContentLoaded', function() {
      initializePollManagement();
      initializeVoting();
      
      // Initialize live announcement banner
      initLiveAnnouncementBanner();
      
      // Load active match first, then team rosters
      loadActiveMatch().then(() => {
        loadTeamRosters().then(() => {
          // Update live indicators after teams are loaded
          setTimeout(async () => {
            await updateLivePlayerIndicators();
          }, 2000); // Wait 2 seconds for everything to settle
        });
      });
      
      // Load current poll for main page
      loadCurrentPollForMainPage();
      
      // Set up real-time poll updates
      setInterval(loadCurrentPollForMainPage, 5000); // Update every 5 seconds
      
      initializeTwitchPlayer();
      initializePlayerStats();
      initializeTeamStats();
      loadRecentMatches();
      initializeTwitchChat();
      
      // Initialize Twitch OAuth functionality
      if (window.twitchOAuth) {
        window.twitchOAuth.updateNav();
      } else {
        // Handle non-authenticated users
        console.log('Twitch OAuth not available - showing guest experience');
        // Delay to ensure page is fully loaded
        setTimeout(showGuestExperience, 1000);
      }
      
      // Set up admin system
      setupAdminSystem();
      
      // Set up Firebase Auth state listener
      onAuthStateChanged(auth, (user) => {
        if (user && ADMIN_UIDS.includes(user.uid)) {
          isAdmin = true;
          console.log('Admin user logged in:', user.email);
        } else {
          isAdmin = false;
          if (user) {
            console.log('Non-admin user logged in:', user.email);
            signOut(auth); // Sign out non-admin users
          }
        }
        checkAdminStatus();
      });
      
      // Set up periodic live player checks
      setInterval(async () => {
        await updateLivePlayerIndicators();
      }, 10000); // Check every 10 seconds
      
      // Also check more frequently for the first few minutes
      let quickChecks = 0;
      const quickInterval = setInterval(async () => {
        await updateLivePlayerIndicators();
        quickChecks++;
        if (quickChecks >= 12) { // Stop after 2 minutes (12 * 10 seconds)
          clearInterval(quickInterval);
        }
      }, 10000);
    });

    // Set up admin system event listeners
    function setupAdminSystem() {
      // Admin login button
      document.getElementById('admin-login-btn').addEventListener('click', showAdminLogin);

      // Admin panel button
      document.getElementById('admin-panel-btn').addEventListener('click', showAdminPanel);

      // Admin logout button
      document.getElementById('admin-logout-btn').addEventListener('click', () => {
        signOut(auth);
      });

      // Admin login form
      document.getElementById('admin-login-submit').addEventListener('click', handleAdminLogin);
      document.getElementById('cancel-admin-login').addEventListener('click', hideAdminLogin);

      // Close admin login modal
      document.getElementById('close-admin-login-modal').addEventListener('click', hideAdminLogin);

      // Close admin panel modal
      document.getElementById('close-admin-modal').addEventListener('click', hideAdminPanel);

      // Close modals when clicking outside
      document.getElementById('admin-login-modal').addEventListener('click', (e) => {
        if (e.target.id === 'admin-login-modal') {
          hideAdminLogin();
        }
      });

      document.getElementById('admin-modal').addEventListener('click', (e) => {
        if (e.target.id === 'admin-modal') {
          hideAdminPanel();
        }
      });

      // Handle Enter key in login form
      document.getElementById('admin-password').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          handleAdminLogin();
        }
      });
    }

    // Show admin login modal
    function showAdminLogin() {
      document.getElementById('admin-login-modal').style.display = 'flex';
      document.getElementById('admin-email').focus();
    }

    // Hide admin login modal
    function hideAdminLogin() {
      document.getElementById('admin-login-modal').style.display = 'none';
      document.getElementById('admin-email').value = '';
      document.getElementById('admin-password').value = '';
      document.getElementById('admin-login-error').style.display = 'none';
    }

    // Handle admin login
    async function handleAdminLogin() {
      const email = document.getElementById('admin-email').value;
      const password = document.getElementById('admin-password').value;
      const errorDiv = document.getElementById('admin-login-error');

      if (!email || !password) {
        errorDiv.textContent = 'Please enter both email and password';
        errorDiv.style.display = 'block';
        return;
      }

      try {
        await signInWithEmailAndPassword(auth, email, password);
        hideAdminLogin();
      } catch (error) {
        console.error('Admin login error:', error);
        errorDiv.textContent = error.message;
        errorDiv.style.display = 'block';
      }
    }

    // Function to parse roster text into player objects
    function parseRosterText(rosterText) {
      if (!rosterText || rosterText === "Roster information not available.") {
        return [];
      }
      
      const players = [];
      const lines = rosterText.split('\n');
      
      lines.forEach(line => {
        if (line.includes('Players:')) {
          const mainPlayers = line.split('Players:')[1].split(',').map(p => p.trim());
          mainPlayers.forEach(playerName => {
            if (playerName && playerName !== '') {
              players.push({
                name: playerName,
                role: 'Player',
                displayName: playerName
              });
            }
          });
        } else if (line.includes('Core:')) {
          const corePlayers = line.split('Core:')[1].split(',').map(p => p.trim());
          corePlayers.forEach(playerName => {
            if (playerName && playerName !== '') {
              players.push({
                name: playerName,
                role: 'Core',
                displayName: playerName
              });
            }
          });
        } else if (line.includes('Bench:')) {
          const benchPlayers = line.split('Bench:')[1].split(',').map(p => p.trim());
          benchPlayers.forEach(playerName => {
            if (playerName && playerName !== '') {
              players.push({
                name: playerName,
                role: 'Bench',
                displayName: playerName
              });
            }
          });
        } else if (line.includes('Captain:')) {
          const captainName = line.split('Captain:')[1].replace('@', '').trim();
          if (captainName && captainName !== '') {
            players.push({
              name: captainName,
              role: 'Captain',
              displayName: captainName
            });
          }
        } else if (line.includes('Ace:')) {
          const aceName = line.split('Ace:')[1].trim();
          if (aceName && aceName !== '') {
            players.push({
              name: aceName,
              role: 'Ace',
              displayName: aceName
            });
          }
        }
      });
      
      return players;
    }

    async function loadTeamRosters() {
      try {
        console.log('Loading team rosters...');
        const teamsRef = collection(db, 'teams');
        const teamsSnapshot = await getDocs(teamsRef);
        
        console.log('Teams snapshot size:', teamsSnapshot.size);
        
        // First, load from Firestore
        teamsSnapshot.forEach(doc => {
          const teamData = doc.data();
          // console.log('Processing team:', teamData.teamName, teamData);
          
          if (teamData.teamName) {
            // Load complete roster including all players and bench players
            const completeRoster = [];
            
            // Add main roster players
            if (teamData.players && Array.isArray(teamData.players)) {
              // console.log('Adding main players for', teamData.teamName, ':', teamData.players);
              completeRoster.push(...teamData.players);
            }
            
            // Add bench players if they exist
            if (teamData.benchPlayers && Array.isArray(teamData.benchPlayers)) {
              // console.log('Adding bench players for', teamData.teamName, ':', teamData.benchPlayers);
              completeRoster.push(...teamData.benchPlayers);
            }
            
            // Add any additional roster data
            if (teamData.roster && Array.isArray(teamData.roster)) {
              console.log('Adding roster data for', teamData.teamName, ':', teamData.roster);
              completeRoster.push(...teamData.roster);
            }
            
            teamRosters[teamData.teamName] = completeRoster;
            // console.log('Final roster for', teamData.teamName, ':', completeRoster);
          }
        });
        
        // Fill in missing teams with default data from TEAM_DATA
        Object.keys(TEAM_DATA).forEach(teamKey => {
          const teamName = TEAM_DATA[teamKey].name;
          const defaultRoster = parseRosterText(TEAM_DATA[teamKey].roster);
          
          // Store roster data under both the key and the name for compatibility
          if (!teamRosters[teamKey] || teamRosters[teamKey].length === 0) {
            console.log('Using default roster for team key', teamKey);
            teamRosters[teamKey] = defaultRoster;
            console.log('Default roster for', teamKey, ':', defaultRoster);
          }
          
          if (!teamRosters[teamName] || teamRosters[teamName].length === 0) {
            console.log('Using default roster for team name', teamName);
            teamRosters[teamName] = defaultRoster;
            console.log('Default roster for', teamName, ':', defaultRoster);
          }
        });
        
        console.log('Loaded complete team rosters:', teamRosters);
        
        // Update player tabs if teams are selected
        if (selectedTeams.teamA && selectedTeams.teamB) {
          // console.log('Updating player tabs for teams:', selectedTeams.teamA, selectedTeams.teamB);
          updatePlayerTabs();
        }
      } catch (error) {
        console.error('Error loading team rosters:', error);
        
        // Fallback to default data if Firestore fails
        console.log('Falling back to default team rosters...');
        Object.keys(TEAM_DATA).forEach(teamKey => {
          const teamName = TEAM_DATA[teamKey].name;
          const defaultRoster = parseRosterText(TEAM_DATA[teamKey].roster);
          
          // Store roster data under both the key and the name for compatibility
          teamRosters[teamKey] = defaultRoster;
          teamRosters[teamName] = defaultRoster;
        });
        
        if (selectedTeams.teamA && selectedTeams.teamB) {
          updatePlayerTabs();
        }
      }
    }

    // Poll Management functionality
    let currentPoll = null;

    async function loadCurrentPoll() {
      try {
        const docRef = doc(db, 'admin', 'currentPoll');
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
          currentPoll = docSnap.data();
          updateCurrentPollDisplay();
          populatePollForm();
        } else {
          currentPoll = null;
          updateCurrentPollDisplay();
        }
      } catch (error) {
        console.error('Error loading current poll:', error);
      }
    }

    function updateCurrentPollDisplay() {
      const display = document.getElementById('current-poll-display');
      if (!display) return;

      if (currentPoll) {
        display.innerHTML = `
          <div class="current-poll-content">
            <h5>${currentPoll.question}</h5>
            <div class="poll-options">
              ${currentPoll.options.map((option, index) => `
                <div class="poll-option">
                  <span class="option-number">${index + 1}.</span>
                  <span class="option-text">${option}</span>
          </div>
              `).join('')}
            </div>
            <p class="poll-meta">Created: ${new Date(currentPoll.createdAt?.toDate?.() || currentPoll.createdAt).toLocaleString()}</p>
          </div>
        `;
      } else {
        display.innerHTML = '<p>No active poll</p>';
      }
    }

    function populatePollForm() {
      if (currentPoll) {
        document.getElementById('poll-question').value = currentPoll.question || '';
        document.getElementById('poll-option-1').value = currentPoll.options?.[0] || '';
        document.getElementById('poll-option-2').value = currentPoll.options?.[1] || '';
        document.getElementById('poll-option-3').value = currentPoll.options?.[2] || '';
        document.getElementById('poll-option-4').value = currentPoll.options?.[3] || '';
      }
    }

    async function savePoll() {
      try {
        const question = document.getElementById('poll-question').value.trim();
        const option1 = document.getElementById('poll-option-1').value.trim();
        const option2 = document.getElementById('poll-option-2').value.trim();
        const option3 = document.getElementById('poll-option-3').value.trim();
        const option4 = document.getElementById('poll-option-4').value.trim();

        if (!question || !option1 || !option2) {
          alert('Please fill in the question and at least two options.');
          return;
        }

        const options = [option1, option2];
        if (option3) options.push(option3);
        if (option4) options.push(option4);

        const pollData = {
          question,
          options,
          createdAt: serverTimestamp(),
          votes: {} // Initialize empty votes object
        };

        console.log('Attempting to save poll:', pollData);
        console.log('Current user:', auth.currentUser);
        console.log('Is admin:', isAdmin);

        await setDoc(doc(db, 'admin', 'currentPoll'), pollData);
        
        currentPoll = pollData;
        updateCurrentPollDisplay();
        // Also update the main page poll display
        updateMainPagePollDisplay(pollData);
        alert('Poll saved successfully!');
      } catch (error) {
        console.error('Error saving poll:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        alert(`Failed to save poll: ${error.message}`);
      }
    }

    async function clearPoll() {
      try {
        await setDoc(doc(db, 'admin', 'currentPoll'), {});
        currentPoll = null;
        updateCurrentPollDisplay();
        // Also update the main page poll display
        updateMainPagePollDisplay(null);
        
        // Clear form
        document.getElementById('poll-question').value = '';
        document.getElementById('poll-option-1').value = '';
        document.getElementById('poll-option-2').value = '';
        document.getElementById('poll-option-3').value = '';
        document.getElementById('poll-option-4').value = '';
        
        alert('Poll cleared successfully!');
      } catch (error) {
        console.error('Error clearing poll:', error);
        alert('Failed to clear poll. Please try again.');
      }
    }

    function initializePollManagement() {
      // Load current poll
      loadCurrentPoll();

      // Set up event listeners
      const saveBtn = document.getElementById('save-poll');
      const clearBtn = document.getElementById('clear-poll');

      if (saveBtn) {
        saveBtn.addEventListener('click', savePoll);
      }

      if (clearBtn) {
        clearBtn.addEventListener('click', clearPoll);
      }
    }

    // Load current poll for main page display
    async function loadCurrentPollForMainPage() {
      try {
        const docRef = doc(db, 'admin', 'currentPoll');
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
          const pollData = docSnap.data();
          updateMainPagePollDisplay(pollData);
          } else {
          updateMainPagePollDisplay(null);
        }
      } catch (error) {
        console.error('Error loading current poll for main page:', error);
        updateMainPagePollDisplay(null);
      }
    }

    // Update the main page poll display
    function updateMainPagePollDisplay(pollData) {
      const pollSection = document.querySelector('.voting-section');
      if (!pollSection) return;

      if (pollData && pollData.question && pollData.options) {
        // Update the poll question
        const pollTitle = pollSection.querySelector('h3');
        if (pollTitle) {
          pollTitle.textContent = pollData.question;
        }

        // Update the voting buttons with results
        const voteButtons = pollSection.querySelectorAll('.vote-btn');
        const votes = pollData.votes || {};
        const totalVotes = Object.keys(votes).length;

        console.log('Poll data:', pollData);
        console.log('Votes object:', votes);
        console.log('Total votes:', totalVotes);

        pollData.options.forEach((option, index) => {
          if (voteButtons[index]) {
            // Count votes for this option - votes object has userId as key, optionIndex as value
            const optionVotes = Object.values(votes).filter(vote => {
              // Handle both string and number vote values
              const voteValue = typeof vote === 'string' ? parseInt(vote) : vote;
              return voteValue === index;
            }).length;
            
            const percentage = totalVotes > 0 ? Math.round((optionVotes / totalVotes) * 100) : 0;
            
            console.log(`Option ${index} (${option}): ${optionVotes} votes (${percentage}%)`);
            
            voteButtons[index].textContent = `${option} (${optionVotes} votes - ${percentage}%)`;
            voteButtons[index].style.display = 'block';
            
            // Add visual indicator for vote percentage
            voteButtons[index].style.background = `linear-gradient(90deg, var(--accent) ${percentage}%, rgba(148, 163, 184, 0.2) ${percentage}%)`;
          }
        });

        // Hide unused buttons
        for (let i = pollData.options.length; i < voteButtons.length; i++) {
          if (voteButtons[i]) {
            voteButtons[i].style.display = 'none';
          }
        }

        // Add total votes display
        let totalVotesDisplay = pollSection.querySelector('.total-votes');
        if (!totalVotesDisplay) {
          totalVotesDisplay = document.createElement('div');
          totalVotesDisplay.className = 'total-votes';
          totalVotesDisplay.style.cssText = 'text-align: center; margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted);';
          pollSection.appendChild(totalVotesDisplay);
        }
        totalVotesDisplay.textContent = `Total Votes: ${totalVotes}`;

        console.log('Updated main page poll display:', pollData);
      } else {
        // Show default voting
        const pollTitle = pollSection.querySelector('h3');
        if (pollTitle) {
          pollTitle.textContent = 'Vote for Winner';
        }

        const voteButtons = pollSection.querySelectorAll('.vote-btn');
        if (voteButtons[0]) voteButtons[0].textContent = 'Team A';
        if (voteButtons[1]) voteButtons[1].textContent = 'Team B';
        if (voteButtons[0]) voteButtons[0].style.display = 'block';
        if (voteButtons[1]) voteButtons[1].style.display = 'block';
        
        // Reset button styles
        voteButtons.forEach(btn => {
          btn.style.background = '';
        });

        // Hide additional buttons
        for (let i = 2; i < voteButtons.length; i++) {
          if (voteButtons[i]) {
            voteButtons[i].style.display = 'none';
          }
        }

        // Remove total votes display
        const totalVotesDisplay = pollSection.querySelector('.total-votes');
        if (totalVotesDisplay) {
          totalVotesDisplay.remove();
        }
      }
    }

    function updateMatchDisplay() {
      const teamA = TEAM_DATA[selectedTeams.teamA];
      const teamB = TEAM_DATA[selectedTeams.teamB];
      const matchDisplay = document.getElementById('match-display');
      
      if (teamA) {
        document.getElementById('team-a-name').textContent = teamA.name;
        document.getElementById('team-a-logo').innerHTML = `<img src="${teamA.logo}" alt="${teamA.name}" onerror="this.style.display='none'">`;
      }
      
      if (teamB) {
        document.getElementById('team-b-name').textContent = teamB.name;
        document.getElementById('team-b-logo').innerHTML = `<img src="${teamB.logo}" alt="${teamB.name}" onerror="this.style.display='none'">`;
      }
      
      // Set background image based on team matchup
      if (teamA && teamB) {
        loadMatchupImageWithFallbacks(teamA.folder, teamB.folder, matchDisplay);
        
        // Set team logo background pattern like in ScrimWatcher
        console.log('Setting background images:', teamA.logo, teamB.logo);
        document.getElementById('bg-left').style.backgroundImage = `url(${teamA.logo})`;
        document.getElementById('bg-right').style.backgroundImage = `url(${teamB.logo})`;
        console.log('Background images set successfully');
      } else {
        // Clear background patterns if no teams selected
        document.getElementById('bg-left').style.backgroundImage = '';
        document.getElementById('bg-right').style.backgroundImage = '';
      }
    }
    
    function loadMatchupImageWithFallbacks(teamAFolder, teamBFolder, matchDisplay) {
      console.log('Loading matchup image for:', teamAFolder, 'vs', teamBFolder);
      
      // Try different naming conventions with GitHub raw links
      const possiblePaths = [
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamAFolder}/${teamAFolder}vs${teamBFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamBFolder}/${teamBFolder}vs${teamAFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamAFolder}/${teamAFolder}Vs${teamBFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamBFolder}/${teamBFolder}Vs${teamAFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamAFolder}/${teamAFolder}VS${teamBFolder}.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/${teamBFolder}/${teamBFolder}VS${teamAFolder}.png`,
        // Try with exact case matching for known files
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/DPRK/DPRKvsZen.png`,
        `https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/ZEN/DPRKvsZen.png`
      ];
      
      console.log('All possible paths:', possiblePaths);
      
      let currentIndex = 0;
      
      function tryNextPath() {
        if (currentIndex >= possiblePaths.length) {
          console.log('All matchup image paths failed, removing background');
          matchDisplay.style.backgroundImage = 'none';
          return;
        }
        
        const currentPath = possiblePaths[currentIndex];
        console.log(`Trying matchup image path ${currentIndex + 1}/${possiblePaths.length}:`, currentPath);
        
        const testImage = new Image();
        
        testImage.onload = function() {
          console.log('✅ Matchup image loaded successfully:', currentPath);
          matchDisplay.style.backgroundImage = `url(${currentPath})`;
          matchDisplay.style.backgroundSize = 'cover';
          matchDisplay.style.backgroundPosition = 'center';
          matchDisplay.style.backgroundRepeat = 'no-repeat';
          matchDisplay.classList.add('has-background');
        };
        
        testImage.onerror = function() {
          console.log('❌ Failed to load:', currentPath);
          currentIndex++;
          tryNextPath();
        };
        
        testImage.src = currentPath;
      }
      
      tryNextPath();
    }

    function updatePlayerTabs() {
      const playerTabs = document.querySelector('.player-tabs');
      const teamA = selectedTeams.teamA;
      const teamB = selectedTeams.teamB;
      
      if (!teamA || !teamB) return;
      
      const teamARoster = teamRosters[teamA] || [];
      const teamBRoster = teamRosters[teamB] || [];
      
      // Filter out unnamed players (those with generic names like "Player 8")
      const filterValidPlayers = (roster) => {
        return roster.filter(player => {
          const name = player.name || player.displayName || '';
          // Filter out generic player names and empty names
          return name && 
                 !name.toLowerCase().includes('player') && 
                 name.trim() !== '' &&
                 !name.match(/^player\s*\d+$/i);
        });
      };
      
      const validTeamARoster = filterValidPlayers(teamARoster);
      const validTeamBRoster = filterValidPlayers(teamBRoster);
      
      // Clear existing tabs
      playerTabs.innerHTML = '';
      
      // Add Team A section
      if (validTeamARoster.length > 0) {
        const teamASection = document.createElement('div');
        teamASection.className = 'team-roster-section';
        
        const teamAHeader = document.createElement('div');
        teamAHeader.className = 'team-roster-header';
        teamAHeader.textContent = `${TEAM_DATA[teamA].name} Players`;
        teamASection.appendChild(teamAHeader);
        
        const teamATabs = document.createElement('div');
        teamATabs.className = 'team-roster-tabs';
        
        validTeamARoster.forEach((player, index) => {
          const tab = document.createElement('button');
          tab.className = `player-tab ${index === 0 ? 'active' : ''}`;
          tab.textContent = player.name || player.displayName;
          tab.dataset.team = 'A';
          tab.dataset.playerIndex = teamARoster.indexOf(player);
          
          // Check if player has a Twitch link
          const twitchHandle = getTwitchHandleForPlayer(player);
          if (!twitchHandle) {
            tab.style.color = '#ef4444'; // Red for no Twitch link
          }
          
          teamATabs.appendChild(tab);
        });
        
        teamASection.appendChild(teamATabs);
        playerTabs.appendChild(teamASection);
      }
      
      // Add Team B section
      if (validTeamBRoster.length > 0) {
        const teamBSection = document.createElement('div');
        teamBSection.className = 'team-roster-section';
        
        const teamBHeader = document.createElement('div');
        teamBHeader.className = 'team-roster-header';
        teamBHeader.textContent = `${TEAM_DATA[teamB].name} Players`;
        teamBSection.appendChild(teamBHeader);
        
        const teamBTabs = document.createElement('div');
        teamBTabs.className = 'team-roster-tabs';
        
        validTeamBRoster.forEach((player, index) => {
          const tab = document.createElement('button');
          tab.className = 'player-tab';
          tab.textContent = player.name || player.displayName;
          tab.dataset.team = 'B';
          tab.dataset.playerIndex = teamBRoster.indexOf(player);
          
          // Check if player has a Twitch link
          const twitchHandle = getTwitchHandleForPlayer(player);
          if (!twitchHandle) {
            tab.style.color = '#ef4444'; // Red for no Twitch link
          }
          
          teamBTabs.appendChild(tab);
        });
        
        teamBSection.appendChild(teamBTabs);
        playerTabs.appendChild(teamBSection);
      }
      
      // Add match stats tab
      const statsSection = document.createElement('div');
      statsSection.className = 'team-roster-section';
      
      const statsHeader = document.createElement('div');
      statsHeader.className = 'team-roster-header';
      statsHeader.textContent = 'Match Information';
      statsSection.appendChild(statsHeader);
      
      // Match Stats button removed as requested
      
      // Re-initialize tab functionality
      initializePlayerTabs();
      
      // Update live indicators after teams are loaded
      setTimeout(() => {
        updateLivePlayerIndicators();
      }, 2000); // Give time for Twitch data to load
    }

    function initializePlayerTabs() {
      const playerTabs = document.querySelectorAll('.player-tab');
      playerTabs.forEach(tab => {
        tab.addEventListener('click', function() {
          // Remove active class from all tabs
          playerTabs.forEach(t => t.classList.remove('active'));
          // Add active class to clicked tab
          this.classList.add('active');
          
          // Update stream and show stats if it's a player tab
          if (this.dataset.team && this.dataset.playerIndex !== undefined) {
            updateStreamForPlayer(this);
            showPlayerStatsForTab(this);
          }
        });
      });
    }

    function showPlayerStatsForTab(tab) {
      const team = tab.dataset.team;
      const playerIndex = tab.dataset.playerIndex;
      const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
      const roster = teamRosters[teamKey] || [];
      const player = roster[playerIndex];
      
      if (player) {
        const playerName = player.name || player.displayName;
        if (playerName) {
          console.log('Showing stats for player:', playerName);
          showPlayerStats(playerName);
        }
      }
    }

    // Name mapping for players where database name doesn't match oauth.js name
    const PLAYER_NAME_MAPPING = {
      // Avalanche team mappings
      'TritiumJones': 'tritiumjones',
      'BakaToma': 'bakatoma1',
      'Vorpalkitty': 'vorpalkitty',  // Need to find their Twitch handle
      'Franchez': 'franchez',        // Need to find their Twitch handle
      'Dean': 'wholuvsdean',
      'Ggglygy': 'ggglygy',
      'Wriggles': 'wrigglespk',
      'Blitz': 'slohp0k3',           // Blitz from DeadStop
      'Hosh': 'hosh',                // Need to find their Twitch handle
      'Luna': '0Luna_',              // Luna from DeadStop (Paprika)
      'Def_Monk': 'defmonk0',
      
      // ePidemic team mappings
      'Kenxai': 'kenxai',
      'Makasuro': 'makasuro',
      
      // DPRK team mappings
      'CheezeCaek': 'cheezecaek',
      'silynn': 'cheddox',
      'ColonelFatso': 'colonelfatso',
      'Pandora': 'pandoracast',
      'Panda': 'pandoracast',
      'Nemesis': 'seansguitarworldbang',
      
      // Zen team mappings
      'Mikesters': 'mikesters17',
      'Nikebeamz': 'nikebeamz',
      'Beamz': 'nikebeamz',  // Roster shows "Beamz", stream is "Nikebeamz"
      'Gnome': 'gnome827',
      
      // TXM team mappings
      'Prizzo': 'prizzo4real',
      'OperationCats': 'operationcats',
      'Goshawk': 'g0shawk',
      'Visis': 'visisgaming',
      'Cryof': 'cryofzshooter',
      'Jive': 'heavenlyjive',
      'Amyou': 'iamyougaming',
      'freefood': 'freefoodd',
      'Howsya': 'howsya',
      
      // FPS team mappings
      'SulliedSoc': 'SulliedSoc',
      'Beldark': 'beldarkk',
      'Simmons': 'simmons572',
      
      // Flying Tractors team mappings
      'playb0x': 'playb0x',
      'Bizow': 'mikeax2',  // Bizow streams as Mikeax2
      'Zao': 'mikeax2',    // or Zao streams as Mikeax2
      'nato': 'natopotato262',
      'LightningMcMeme': 'lightningmcmeme',  // LightningMcMeme has their own stream
      'Bazz-B': 'mikeax2', // or Bazz-B streams as Mikeax2
      'didjital': 'mikeax2', // or didjital streams as Mikeax2
      'bgkillas': 'mikeax2', // bench player
      'Dreadtitan': 'dreadtitan',
      'Orvid': 'mikeax2',   // bench player
      
      // HoE team mappings
      'Katar': 'karolk10',
      'gwej': 'gwej',
      'cym3': 'cymm3',
      'LordBuschguy': 'lordbuschguy',
      
      // KTL team mappings
      'isoitiro': 'isoitiro',
      
      // Magic team mappings
      'XRY': 'xry_tv',
      'Splitsecond': 'splitsecondta',
      'Vaxity': 'vaxitylol',
      
      // Null team mappings
      'z4t01': 'z4t01',
      
      // Toxic Aimers team mappings
      'Song': 'song',
      'Sek': 'sek',
      'Hatuey': 'hatuey',
      'DareDevilMoon': 'daredevilmoon',
      'Nerve': 'nerve',
      'Radishblue': 'radishblue',
      'Trey': 'trey',
      'Sin': 'sin',
      'Stork': 'storksoofly',
      
      // DeadStop team mappings
      'iinferno': 'bschrift',
      'Paprika': '0Luna_',
      'Blitz': 'slohp0k3',
      'apc': 'apcizzle',
      
      // UE team mappings
      'PabloSexcrobar': 'eltimablo',
      'RoamenCota': 'roamencota',
      'Deadmanwalking': 'DeadManWalking-UF-',
      'Ghost_Loot': 'ghost_loot',
      
      // Legacy mappings
      'Glem': 'Glem',
      'Rhino': 'Rhino',
      'Radishblue': 'Radishblue'
    };

    // Global variable to store Firebase Twitch handles
    let firebaseTwitchHandles = {};

    // Load Twitch handles from Firebase
    async function loadFirebaseTwitchHandles() {
      try {
        if (!window.firebase || !window.firebase.firestore) {
          console.log('Firebase not available, skipping Twitch handle loading');
          return;
        }

        const db = window.firebase.firestore();
        const handlesSnapshot = await db.collection('playerTwitchHandles').get();
        
        firebaseTwitchHandles = {};
        handlesSnapshot.forEach(doc => {
          const data = doc.data();
          firebaseTwitchHandles[data.playerName] = data.twitchHandle;
        });
        
        console.log('Loaded Firebase Twitch handles:', firebaseTwitchHandles);
        console.log('Number of handles loaded:', Object.keys(firebaseTwitchHandles).length);
      } catch (error) {
        console.error('Error loading Firebase Twitch handles:', error);
      }
    }

    function getTwitchHandleForPlayer(player) {
      // console.log(`Getting Twitch handle for player:`, player);
      
      const playerName = player.name || player.displayName;
      
      // First priority: Check Firebase handles (admin-managed)
      // console.log(`Getting handle for ${playerName}. Firebase handles available:`, Object.keys(firebaseTwitchHandles));
      if (playerName && firebaseTwitchHandles[playerName]) {
        const handle = firebaseTwitchHandles[playerName];
        // console.log(`✅ Found Firebase Twitch handle for ${playerName}: ${handle}`);
        return validateTwitchHandle(handle, playerName);
      } else {
        // console.log(`❌ No Firebase handle found for ${playerName}`);
      }
      
      // Second priority: Check player object properties
      let twitchHandle = player.twitchHandle || player.twitch || player.twitchChannel || player.channel;
      
      // If we got a full URL, extract just the handle
      if (twitchHandle && twitchHandle.includes('twitch.tv/')) {
        const match = twitchHandle.match(/twitch\.tv\/([^/?]+)/i);
        if (match) {
          twitchHandle = match[1];
          console.log(`Extracted handle from URL: ${twitchHandle}`);
        }
      }
      
      // Third priority: Use hardcoded mappings
      if (!twitchHandle && player.name) {
        const mappedName = PLAYER_NAME_MAPPING[player.name] || player.name;
        // console.log(`Player ${player.name} mapped to: ${mappedName}`);
        
        // Check if the mapped name is already a Twitch handle (contains lowercase letters/numbers)
        // This handles cases like 'Panda' -> 'pandoracast' where the mapping is direct
        if (mappedName && mappedName !== player.name && /^[a-z0-9_]+$/.test(mappedName)) {
          twitchHandle = mappedName;
          // console.log(`Direct Twitch handle mapping for ${player.name}: ${twitchHandle}`);
        } else {
          // Look up in oauth.js TEAM_STREAMS data
          if (window.twitchOAuth && window.twitchOAuth.TEAM_STREAMS) {
            // console.log(`Looking in oauth.js TEAM_STREAMS for ${mappedName}`);
            for (const [teamName, streams] of Object.entries(window.twitchOAuth.TEAM_STREAMS)) {
              const streamer = streams.find(s => s.name === mappedName);
              if (streamer) {
                // Extract Twitch handle from URL
                const match = streamer.url.match(/twitch\.tv\/([^/?]+)/i);
                if (match) {
                  twitchHandle = match[1];
                  console.log(`Found Twitch handle for ${player.name} (mapped to ${mappedName}): ${twitchHandle}`);
                  break;
                }
              }
            }
          }
          
          // If still no handle found, check default TEAM_DATA streams
          if (!twitchHandle) {
            // console.log(`Looking in default TEAM_DATA streams for ${mappedName} or ${player.name}`);
            for (const [teamKey, teamData] of Object.entries(TEAM_DATA)) {
              if (teamData.streams && Array.isArray(teamData.streams)) {
                const streamer = teamData.streams.find(s => s.name === mappedName || s.name === player.name);
                if (streamer) {
                  // Extract Twitch handle from URL
                  const match = streamer.url.match(/twitch\.tv\/([^/?]+)/i);
                  if (match) {
                    twitchHandle = match[1];
                    console.log(`Found Twitch handle in default data for ${player.name}: ${twitchHandle}`);
                    break;
                  }
                }
              }
            }
          }
        }
      }
      
      // console.log(`Final Twitch handle for ${playerName}: ${twitchHandle}`);
      return validateTwitchHandle(twitchHandle, playerName);
    }

    // Validate Twitch handle format and length
    function validateTwitchHandle(twitchHandle, playerName) {
      if (!twitchHandle) {
        return null;
      }
      
      // Ensure it's not too long and contains only valid characters
      if (twitchHandle.length > 100) {
        console.warn(`Twitch handle too long for ${playerName}: ${twitchHandle} (${twitchHandle.length} chars)`);
        return null;
      }
      if (!/^[a-zA-Z0-9_]+$/.test(twitchHandle)) {
        console.warn(`Invalid Twitch handle format for ${playerName}: ${twitchHandle}`);
        return null;
      }
      
      return twitchHandle;
    }

    function updateStreamForPlayer(selectedTab) {
      const team = selectedTab.dataset.team;
      const playerIndex = selectedTab.dataset.playerIndex;
      
      if (team && playerIndex !== undefined) {
        const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
        const roster = teamRosters[teamKey] || [];
        const player = roster[playerIndex];
        
        if (player) {
          // Use the new function to get Twitch handle
          const twitchHandle = getTwitchHandleForPlayer(player);
          
          if (twitchHandle) {
            const streamFrame = document.getElementById('stream-frame');
            if (streamFrame && streamFrame.tagName === 'IFRAME') {
              // Use a more permissive parent domain for local development
              let parentDomain = window.location.hostname;
              if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
                parentDomain = 'tribesprofessionalleague.com'; // Use the production domain
              }
              
              // Use the same format as TribesScrimWatcher
              streamFrame.src = `https://player.twitch.tv/?channel=${encodeURIComponent(twitchHandle)}&parent=${parentDomain}&autoplay=false`;
              console.log(`Loading stream for ${player.name}: ${twitchHandle} with parent: ${parentDomain}`);
            } else {
              console.error('Stream frame element not found or was replaced! Attempting to restore...');
              // Try to restore the iframe if it was replaced
              restoreStreamFrame();
              // Try again after a short delay
              setTimeout(() => {
                const newStreamFrame = document.getElementById('stream-frame');
                if (newStreamFrame && newStreamFrame.tagName === 'IFRAME') {
                  let parentDomain = window.location.hostname;
                  if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
                    parentDomain = 'tribesprofessionalleague.com';
                  }
                  newStreamFrame.src = `https://player.twitch.tv/?channel=${encodeURIComponent(twitchHandle)}&parent=${parentDomain}&autoplay=false`;
                  console.log(`Loading stream for ${player.name} after restore: ${twitchHandle} with parent: ${parentDomain}`);
                }
              }, 200);
            }
          } else {
            console.log('No Twitch handle found for player:', player);
          }
        }
      }

      // Update live indicators and streamer chat after a short delay to allow Twitch data to load
      setTimeout(() => {
        updateLivePlayerIndicators();
        updateStreamerChat();
        updateStreamerDropdown();
      }, 1000);
    }

    function initializeChat() {
      const chatInput = document.querySelector('.chat-input');
      const chatSend = document.querySelector('.chat-send');
      const chatMessages = document.querySelector('.chat-messages');
      // Note: streamer chat now uses iframe instead of messages div
      const chatTabs = document.querySelectorAll('.chat-tab');
      const chatContainers = document.querySelectorAll('.chat-container');

      // Chat tab switching
      chatTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabType = tab.dataset.tab;
          
          // Update active tab
          chatTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Update active container
          chatContainers.forEach(container => container.classList.remove('active'));
          document.getElementById(`${tabType}-chat`).classList.add('active');
        });
      });

      function addMessage(message, isUser = false, chatType = 'main') {
        // Only handle main chat messages, streamer chat uses iframe
        if (chatType === 'main') {
        const messageDiv = document.createElement('div');
        messageDiv.style.marginBottom = '0.5rem';
        messageDiv.style.padding = '0.5rem';
        messageDiv.style.borderRadius = '4px';
        messageDiv.style.backgroundColor = isUser ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255, 255, 255, 0.05)';
        messageDiv.textContent = message;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }

      // Main chat functionality
      chatSend.addEventListener('click', () => {
        const message = chatInput.value.trim();
        if (message) {
          addMessage(`You: ${message}`, true, 'main');
          chatInput.value = '';
          
          // Simulate response
          setTimeout(() => {
            addMessage('ChatBot: Thanks for the message!', false, 'main');
          }, 1000);
        }
      });

      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          chatSend.click();
        }
      });

      // Streamer chat functionality
      const streamerChatInput = document.getElementById('streamer-chat-input');
      const streamerChatSend = document.getElementById('streamer-chat-send');
      
      if (streamerChatSend) {
        streamerChatSend.addEventListener('click', () => {
          const message = streamerChatInput.value.trim();
          if (message) {
            // In a real implementation, this would send the message to Twitch chat
            // For now, we'll just show a confirmation
            alert(`Message sent to streamer chat: "${message}"`);
            streamerChatInput.value = '';
          }
        });
      }

      if (streamerChatInput) {
        streamerChatInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            streamerChatSend.click();
          }
        });
      }

      // Simulate some initial messages
      setTimeout(() => {
        addMessage('Welcome to the chat!', false, 'main');
        addMessage('Match starting soon!', false, 'main');
      }, 1000);

      // Streamer chat functionality will be defined globally below

      // Update streamer chat periodically
      setInterval(updateStreamerChat, 10000);
      updateStreamerChat();
    }

    function initializeVoting() {
      const voteButtons = document.querySelectorAll('.vote-btn');
      
      voteButtons.forEach((button, index) => {
        button.addEventListener('click', function() {
          // Remove voted class from all buttons
          voteButtons.forEach(btn => btn.classList.remove('voted'));
          // Add voted class to clicked button
          this.classList.add('voted');
          
          // Trigger confetti celebration
          triggerVoteCelebration();
          
          // Save vote to Firebase
          saveVote(index);
          
          // Show confirmation
          const teamName = this.textContent;
          alert(`You voted for ${teamName}!`);
        });
      });
    }

    async function saveVote(optionIndex) {
      try {
        // Generate a unique user ID for this session
        let userId = localStorage.getItem('voteUserId');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('voteUserId', userId);
        }

        // Get current poll data
        const pollDoc = await getDoc(doc(db, 'admin', 'currentPoll'));
        if (pollDoc.exists()) {
          const pollData = pollDoc.data();
          const votes = pollData.votes || {};
          
          // Update the vote
          votes[userId] = optionIndex;
          
          // Save back to Firebase
          await setDoc(doc(db, 'admin', 'currentPoll'), {
            ...pollData,
            votes: votes
          }, { merge: true });
          
          console.log('Vote saved successfully:', { userId, optionIndex });
          
          // Refresh the poll display
          setTimeout(() => {
            loadCurrentPollForMainPage();
          }, 500);
        }
      } catch (error) {
        console.error('Error saving vote:', error);
        alert('Failed to save vote. Please try again.');
      }
    }

    function triggerVoteCelebration() {
      // Create multiple confetti bursts
      const duration = 3000;
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      const interval = setInterval(function() {
        const timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
          return clearInterval(interval);
        }

        const particleCount = 50 * (timeLeft / duration);
        
        // Fire from left edge
        confetti({
          ...defaults,
          particleCount,
          origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
        });
        
        // Fire from right edge
        confetti({
          ...defaults,
          particleCount,
          origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
        });
      }, 250);
    }

    function initializeTwitchPlayer() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        // Get the current hostname - same as TribesScrimWatcher
        const parentDomain = window.location.hostname;
        
        // Update the iframe src with the correct parent parameter
        const currentSrc = streamFrame.src;
        const newSrc = currentSrc.includes('parent=') 
          ? currentSrc.replace(/parent=[^&]*/, `parent=${parentDomain}`)
          : `${currentSrc}&parent=${parentDomain}`;
        
        streamFrame.src = newSrc;
        console.log('Twitch player initialized with parent:', parentDomain);
        
        // Add error handling for the iframe
        streamFrame.onerror = function() {
          console.error('Failed to load Twitch player');
          // Show a fallback message or try alternative loading
          showPlayerFallback();
        };
        
        // Add load event listener
        streamFrame.onload = function() {
          console.log('Twitch player loaded successfully');
        };

        // Note: Removed iframe content check as it's unreliable for Twitch embeds
        // Cross-origin restrictions prevent checking iframe content even when working properly

        // Also listen for console errors that might indicate content blocking
        const originalConsoleError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          if (message.includes('PlaybackAccessToken') && message.includes('server error') ||
              message.includes('Failed to determine content classification')) {
            console.log('Detected Twitch content blocking error - showing fallback');
            setTimeout(() => showContentBlockedFallback(), 1000);
          }
          originalConsoleError.apply(console, args);
        };
      }
    }

    function showPlayerFallback() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        // Create a fallback div with instructions
        const fallbackDiv = document.createElement('div');
        fallbackDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        fallbackDiv.innerHTML = `
          <h3>Stream Loading...</h3>
          <p>If the stream doesn't load, try refreshing the page or check if the streamer is live.</p>
          <button onclick="location.reload()" style="
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
          ">Refresh Page</button>
        `;
        
        // Replace the iframe with fallback content
        streamFrame.parentNode.replaceChild(fallbackDiv, streamFrame);
      }
    }

    // Handle content blocked by browser (like Brave's privacy features)
    function showContentBlockedFallback() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        const blockedDiv = document.createElement('div');
        blockedDiv.id = 'content-blocked-fallback';
        blockedDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        blockedDiv.innerHTML = `
          <h3>🚫 Content Blocked by Browser</h3>
          <p>Your browser's privacy settings are blocking Twitch content.</p>
          <p><strong>To fix this:</strong></p>
          <ul style="text-align: left; margin: 1rem 0;">
            <li><strong>Brave:</strong> Click the shield icon → Turn off "Trackers & ads blocked" for this site</li>
            <li><strong>Chrome:</strong> Click the shield icon → Allow "Insecure content"</li>
            <li><strong>Firefox:</strong> Click the shield icon → Turn off "Enhanced Tracking Protection"</li>
          </ul>
          <p>Or try refreshing the page after adjusting settings.</p>
          <div style="margin-top: 1rem;">
            <button onclick="restoreStreamFrame()" style="
              background: var(--success);
              color: white;
              border: none;
              padding: 0.75rem 1.5rem;
              border-radius: 0.5rem;
              cursor: pointer;
              font-size: 1rem;
              margin-right: 0.5rem;
            ">Try Again</button>
            <button onclick="location.reload()" style="
              background: var(--accent);
              color: white;
              border: none;
              padding: 0.75rem 1.5rem;
              border-radius: 0.5rem;
              cursor: pointer;
              font-size: 1rem;
              margin-right: 0.5rem;
            ">Refresh Page</button>
            <button onclick="showAlternativeContent()" style="
              background: var(--surface-glass);
              color: var(--text-primary);
              border: 1px solid var(--accent);
              padding: 0.75rem 1.5rem;
              border-radius: 0.5rem;
              cursor: pointer;
              font-size: 1rem;
            ">Show Alternative Content</button>
          </div>
          <p style="margin-top: 1rem; font-size: 0.875rem; color: var(--text-muted);">
            If you're using Edge and logged into Twitch, try clicking "Try Again" first.
          </p>
        `;
        
        // Replace the iframe with the blocked content message
        streamFrame.parentNode.replaceChild(blockedDiv, streamFrame);
      }
    }

    function restoreStreamFrame() {
      const fallbackDiv = document.getElementById('content-blocked-fallback');
      if (fallbackDiv) {
        const newIframe = document.createElement('iframe');
        newIframe.className = 'stream-frame';
        newIframe.id = 'stream-frame';
        newIframe.src = 'https://player.twitch.tv/?channel=tribesprofessionalleague&autoplay=false';
        newIframe.allowFullscreen = true;
        
        // Replace the fallback div with the new iframe
        fallbackDiv.parentNode.replaceChild(newIframe, fallbackDiv);
        
        // Re-initialize the Twitch player
        setTimeout(() => {
          initializeTwitchPlayer();
        }, 100);
      }
    }

    // Show alternative content when Twitch is blocked
    function showAlternativeContent() {
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        const altDiv = document.createElement('div');
        altDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        altDiv.innerHTML = `
          <h3>📺 Content Temporarily Unavailable</h3>
          <p>Twitch streaming is currently blocked by your browser settings.</p>
          <p>You can still enjoy all other features:</p>
          <ul style="text-align: left; margin: 1rem 0;">
            <li>View match information and team statistics</li>
            <li>Vote in polls and see real-time results</li>
            <li>Chat with other viewers</li>
            <li>Access player information and stats</li>
          </ul>
          <p>To enable streaming, please adjust your browser's privacy settings.</p>
          <button onclick="showContentBlockedFallback()" style="
            background: var(--surface-glass);
            color: var(--text-primary);
            border: 1px solid var(--accent);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
            font-size: 0.9rem;
          ">Back to Fix Instructions</button>
        `;
        
        // Replace the current content with alternative options
        streamFrame.parentNode.replaceChild(altDiv, streamFrame);
      }
    }

    // Handle guest experience for non-authenticated users
    function showGuestExperience() {
      // Show a message in the stream area for guests
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        const guestDiv = document.createElement('div');
        guestDiv.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          background: var(--card-bg);
          color: var(--text-primary);
          text-align: center;
          padding: 2rem;
        `;
        guestDiv.innerHTML = `
          <h3>Welcome to Tribes Professional League</h3>
          <p>Sign in with Twitch to watch live streams and access all features.</p>
          <p>You can still view match information, team stats, and vote in polls!</p>
          <button onclick="document.getElementById('twitch-login-btn').click()" style="
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
            font-size: 1rem;
          ">Sign in with Twitch</button>
        `;
        
        // Replace the iframe with the guest message
        streamFrame.parentNode.replaceChild(guestDiv, streamFrame);
      }

      // Disable player tab functionality for guests
      const playerTabs = document.querySelectorAll('.player-tab');
      playerTabs.forEach(tab => {
        tab.style.opacity = '0.6';
        tab.style.cursor = 'not-allowed';
        tab.title = 'Sign in with Twitch to watch player streams';
      });
    }

    // Restore authenticated experience when user signs in
    function restoreAuthenticatedExperience() {
      // Restore player tab functionality
      const playerTabs = document.querySelectorAll('.player-tab');
      playerTabs.forEach(tab => {
        tab.style.opacity = '1';
        tab.style.cursor = 'pointer';
        tab.title = '';
      });

      // Restore the Twitch player
      const streamContainer = document.querySelector('.stream-container');
      if (streamContainer) {
        const guestDiv = streamContainer.querySelector('div');
        if (guestDiv && guestDiv.innerHTML.includes('Welcome to Tribes Professional League')) {
          // Restore the original iframe
          const iframe = document.createElement('iframe');
          iframe.className = 'stream-frame';
          iframe.id = 'stream-frame';
          iframe.src = 'https://player.twitch.tv/?channel=tribesprofessionalleague&autoplay=false';
          iframe.allowFullscreen = true;
          
          streamContainer.replaceChild(iframe, guestDiv);
          
          // Re-initialize the Twitch player
          setTimeout(() => {
            initializeTwitchPlayer();
          }, 500);
        }
      }
    }

    // Test function to manually load DPRK vs Zen image
    function testDPRKvsZen() {
      const matchDisplay = document.getElementById('match-display');
      const testPath = "https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo's/TeamMatchUps/DPRK/DPRKvsZen.png";
      console.log('Testing direct path:', testPath);
      
      const testImage = new Image();
      testImage.onload = function() {
        console.log('✅ Direct test successful!');
        matchDisplay.style.backgroundImage = `url(${testPath})`;
        matchDisplay.style.backgroundSize = 'cover';
        matchDisplay.style.backgroundPosition = 'center';
        matchDisplay.style.backgroundRepeat = 'no-repeat';
        matchDisplay.classList.add('has-background');
      };
      testImage.onerror = function() {
        console.log('❌ Direct test failed!');
      };
      testImage.src = testPath;
    }
    
    // Test function to manually set background images
    function testBackgroundImages() {
      console.log('Testing background images...');
      const testLogo = 'https://raw.githubusercontent.com/T24085/ProjectTribes/main/TribesLeagueLogo\'s/TeamDPRKLogo3.png';
      
      document.getElementById('bg-left').style.backgroundImage = `url(${testLogo})`;
      document.getElementById('bg-right').style.backgroundImage = `url(${testLogo})`;
      
      console.log('Background images set to:', testLogo);
      console.log('Left background:', document.getElementById('bg-left').style.backgroundImage);
      console.log('Right background:', document.getElementById('bg-right').style.backgroundImage);
    }

    // Test function to check player name mapping
    function testPlayerMapping() {
      console.log('Testing player name mapping...');
      
      // Test Panda -> Pandora mapping
      const testPlayer = { name: 'Panda', twitch: '' };
      const handle = getTwitchHandleForPlayer(testPlayer);
      console.log(`Panda mapping result: ${handle}`);
      
      // Test Glem mapping
      const testPlayer2 = { name: 'Glem', twitch: '' };
      const handle2 = getTwitchHandleForPlayer(testPlayer2);
      console.log(`Glem mapping result: ${handle2}`);
      
      // Show all available mappings
      console.log('Available name mappings:', PLAYER_NAME_MAPPING);
    }

    // Test function to verify Twitch player URL format
    function testTwitchPlayerFormat() {
      console.log('Testing Twitch player URL format...');
      const parentDomain = window.location.hostname;
      const testChannel = 'pandoracast';
      
      const testUrl = `https://player.twitch.tv/?channel=${encodeURIComponent(testChannel)}&parent=${parentDomain}&autoplay=false`;
      console.log('Test URL format:', testUrl);
      
      // Test if this matches TribesScrimWatcher format
      const streamFrame = document.querySelector('.stream-frame');
      if (streamFrame) {
        streamFrame.src = testUrl;
        console.log('Applied test URL to player');
      }
    }

    // Test function to verify team logo URLs are working
    function testTeamLogos() {
      console.log('Testing team logo URLs...');
      
      // Test DPRK and Zen logos specifically
      const dprkLogo = TEAM_DATA['DPRK'].logo;
      const zenLogo = TEAM_DATA['Zen'].logo;
      
      console.log('DPRK logo URL:', dprkLogo);
      console.log('Zen logo URL:', zenLogo);
      
      // Test loading the logos
      const testImage1 = new Image();
      testImage1.onload = function() {
        console.log('✅ DPRK logo loaded successfully');
        // Set as background to test
        document.getElementById('bg-left').style.backgroundImage = `url(${dprkLogo})`;
      };
      testImage1.onerror = function() {
        console.log('❌ DPRK logo failed to load');
      };
      testImage1.src = dprkLogo;
      
      const testImage2 = new Image();
      testImage2.onload = function() {
        console.log('✅ Zen logo loaded successfully');
        // Set as background to test
        document.getElementById('bg-right').style.backgroundImage = `url(${zenLogo})`;
      };
      testImage2.onerror = function() {
        console.log('❌ Zen logo failed to load');
      };
      testImage2.src = zenLogo;
    }

    // Function to adjust background logo opacity for better readability
    function adjustBackgroundOpacity(opacity) {
      const bgLeft = document.getElementById('bg-left');
      const bgRight = document.getElementById('bg-right');
      
      if (bgLeft && bgRight) {
        bgLeft.style.opacity = opacity;
        bgRight.style.opacity = opacity;
        console.log(`Background opacity set to ${opacity}`);
      }
    }

    // Player Stats functionality
    let playerStatsData = null;
    let currentStatsChart = null;

    async function loadPlayerStats() {
      try {
        console.log('Starting to load player stats...');
        const docRef = doc(db, 'publicStats', 'aggregates');
        console.log('Document reference created:', docRef);
        const docSnap = await getDoc(docRef);
        console.log('Document snapshot received:', docSnap);

        if (!docSnap.exists()) {
          console.log('No published stats found - document does not exist');
          return null;
        }

        const data = docSnap.data() || {};
        
        // Hydrate the data like PlayerStats.html does
        const hydratePlayers = (entries = []) => {
          const map = new Map();
          entries.forEach(entry => {
            const teams = Array.isArray(entry.teams) ? new Set(entry.teams) : new Set(entry.team ? [entry.team] : []);
            map.set(entry.name, { ...entry, teams });
          });
          return map;
        };

        const hydratePlayerMaps = (entries = []) => {
          const map = new Map();
          entries.forEach(entry => {
            const teams = Array.isArray(entry.teams) ? new Set(entry.teams) : new Set();
            map.set(`${entry.player}__${entry.map}`, { ...entry, teams });
          });
          return map;
        };

        const hydrateTeams = (entries = []) => {
          const map = new Map();
          entries.forEach(entry => {
            map.set(entry.name, { ...entry });
          });
          return map;
        };

        window.playerStatsData = {
          playerTotals: hydratePlayers(data.playerTotals || []),
          playerMapStats: hydratePlayerMaps(data.playerMapStats || []),
          teamTotals: hydrateTeams(data.teamTotals || []),
          totalMatches: data.totalMatches || 0,
          generatedAt: data.generatedAt
        };

        console.log('Player stats loaded:', window.playerStatsData);
        console.log('Available players:', Array.from(window.window.playerStatsData.playerTotals.keys()));
        
        // Check if stats are empty
        if (window.window.playerStatsData.playerTotals.size === 0) {
          console.log('Published stats are empty - no player data found');
          return null;
        }
        
        return window.playerStatsData;
      } catch (error) {
        console.error('Error loading player stats:', error);
        return null;
      }
    }

    function showPlayerStats(playerName) {
      const statsSection = document.getElementById('player-stats-section');
      const statsContent = document.getElementById('player-stats-content');
      
      if (!statsSection || !statsContent) return;

      if (!window.playerStatsData) {
        statsContent.innerHTML = '<div class="text-center text-gray-400">No player statistics available</div>';
        statsSection.style.display = 'block';
        return;
      }

      console.log('Looking for player stats:', playerName);
      console.log('Available players in stats:', Array.from(window.window.playerStatsData.playerTotals.keys()));

      // Try exact match first
      let player = window.window.playerStatsData.playerTotals.get(playerName);
      
      // If no exact match, try case-insensitive search
      if (!player && playerName) {
        const playerNames = Array.from(window.playerStatsData.playerTotals.keys());
        const foundName = playerNames.find(name => 
          name && name.toLowerCase() === playerName.toLowerCase()
        );
        if (foundName) {
          player = window.playerStatsData.playerTotals.get(foundName);
          console.log('Found case-insensitive match:', foundName);
        }
      }

      // If still no match, try partial matching
      if (!player && playerName) {
        const playerNames = Array.from(window.playerStatsData.playerTotals.keys());
        const foundName = playerNames.find(name => 
          name && (
            name.toLowerCase().includes(playerName.toLowerCase()) ||
            playerName.toLowerCase().includes(name.toLowerCase())
          )
        );
        if (foundName) {
          player = window.playerStatsData.playerTotals.get(foundName);
          console.log('Found partial match:', foundName);
        }
      }

      if (!player) {
        statsContent.innerHTML = `
          <div class="text-center text-gray-400">
            <p>No statistics found for "${playerName}"</p>
            <p class="text-sm mt-2">Available players: ${Array.from(window.playerStatsData.playerTotals.keys()).slice(0, 10).join(', ')}${window.playerStatsData.playerTotals.size > 10 ? '...' : ''}</p>
          </div>
        `;
        statsSection.style.display = 'block';
        return;
      }

      // Calculate player metrics
      const time = parseFloat(player.time) || 0;
      const kills = parseFloat(player.kills) || 0;
      const assists = parseFloat(player.assists) || 0;
      const score = parseFloat(player.score) || 0;
      const captures = parseFloat(player.captures) || 0;
      const returns = parseFloat(player.returns) || 0;
      const matches = parseFloat(player.matches) || 0;

      const kpm = time > 0 ? kills / time : 0;
      const apm = time > 0 ? assists / time : 0;
      const spm = time > 0 ? score / time : 0;
      const cpm = time > 0 ? captures / time : 0;
      const rpm = time > 0 ? returns / time : 0;

      const teams = Array.from(player.teams || []).join(', ') || 'Unknown';

      // Create stats display
      statsContent.innerHTML = `
        <div class="player-stats-display">
          <div class="player-stats-header">
            <h3 class="text-2xl font-bold text-white mb-2">${playerName}</h3>
            <p class="text-gray-300 mb-4">Teams: ${teams} | Matches: ${matches} | Playtime: ${time.toFixed(1)} min</p>
          </div>
          
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-label">Score</div>
              <div class="stat-value">${score.toFixed(0)}</div>
              <div class="stat-rate">${spm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Kills</div>
              <div class="stat-value">${kills.toFixed(0)}</div>
              <div class="stat-rate">${kpm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Assists</div>
              <div class="stat-value">${assists.toFixed(0)}</div>
              <div class="stat-rate">${apm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Captures</div>
              <div class="stat-value">${captures.toFixed(0)}</div>
              <div class="stat-rate">${cpm.toFixed(2)}/min</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Returns</div>
              <div class="stat-value">${returns.toFixed(0)}</div>
              <div class="stat-rate">${rpm.toFixed(2)}/min</div>
            </div>
          </div>

          <div class="stats-chart-container">
            <h4 class="text-lg font-semibold text-white mb-4">Performance Metrics</h4>
            <canvas id="player-stats-chart" width="400" height="200"></canvas>
          </div>
        </div>
      `;

      // Create performance chart
      setTimeout(() => {
        createPlayerStatsChart(playerName, { kpm, apm, spm, cpm, rpm });
      }, 100);

      statsSection.style.display = 'block';
    }

    function createPlayerStatsChart(playerName, metrics) {
      const canvas = document.getElementById('player-stats-chart');
      if (!canvas) return;

      // Destroy existing chart
      if (currentStatsChart) {
        currentStatsChart.destroy();
      }

      const ctx = canvas.getContext('2d');
      // Use separate scaling for Score vs other metrics to make all bars visible
      const combatMax = Math.max(metrics.kpm, metrics.apm, metrics.cpm, metrics.rpm);
      const scoreMax = metrics.spm;
      
      // Scale combat stats to 0-100% based on their max
      const combatScale = combatMax > 0 ? 100 / combatMax : 1;
      
      // Scale score to 0-100% but use a smaller multiplier to make it less dominant
      const scoreScale = scoreMax > 0 ? 50 / scoreMax : 1; // Score gets 50% max height
      
      const normalizedData = [
        Math.min(metrics.spm * scoreScale, 100),     // Score/min (scaled to max 50% of chart)
        Math.min(metrics.kpm * combatScale, 100),    // Kills/min (scaled to combat max)
        Math.min(metrics.apm * combatScale, 100),    // Assists/min (scaled to combat max)
        Math.min(metrics.cpm * combatScale, 100),    // Captures/min (scaled to combat max)
        Math.min(metrics.rpm * combatScale, 100)     // Returns/min (scaled to combat max)
      ];

      currentStatsChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Score/min', 'Kills/min', 'Assists/min', 'Captures/min', 'Returns/min'],
          datasets: [{
            label: `${playerName} Performance (Normalized)`,
            data: normalizedData,
            backgroundColor: [
              'rgba(16, 185, 129, 0.8)',  // Green for score
              'rgba(239, 68, 68, 0.8)',   // Red for kills
              'rgba(59, 130, 246, 0.8)',  // Blue for assists
              'rgba(245, 158, 11, 0.8)',  // Yellow for captures
              'rgba(139, 92, 246, 0.8)'   // Purple for returns
            ],
            borderColor: [
              'rgba(16, 185, 129, 1)',
              'rgba(239, 68, 68, 1)',
              'rgba(59, 130, 246, 1)',
              'rgba(245, 158, 11, 1)',
              'rgba(139, 92, 246, 1)'
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: '#e2e8f0'
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const index = context.dataIndex;
                  const originalValues = [metrics.spm, metrics.kpm, metrics.apm, metrics.cpm, metrics.rpm];
                  const labels = ['Score/min', 'Kills/min', 'Assists/min', 'Captures/min', 'Returns/min'];
                  return `${labels[index]}: ${originalValues[index].toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                color: '#94a3b8',
                callback: function(value) {
                  return value + '%';
                }
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.1)'
              }
            },
            x: {
              ticks: {
                color: '#94a3b8'
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.1)'
              }
            }
          }
        }
      });
    }

    function hidePlayerStats() {
      const statsSection = document.getElementById('player-stats-section');
      if (statsSection) {
        statsSection.style.display = 'none';
      }
      if (currentStatsChart) {
        currentStatsChart.destroy();
        currentStatsChart = null;
      }
    }

    function initializePlayerStats() {
      console.log('Initializing player stats...');
      // Load player stats data
      loadPlayerStats().then((result) => {
        console.log('Player stats loading completed:', result);
      }).catch((error) => {
        console.error('Player stats loading failed:', error);
      });
      
      // Add close button functionality
      const closeStatsBtn = document.getElementById('close-stats-btn');
      if (closeStatsBtn) {
        closeStatsBtn.addEventListener('click', hidePlayerStats);
      }
    }
    
    // Test function for player stats
    function testPlayerStats() {
      console.log('Testing player stats functionality...');
      if (window.playerStatsData) {
        console.log('Player stats data loaded:', window.playerStatsData);
        const playerNames = Array.from(window.playerStatsData.playerTotals.keys());
        console.log('Available players:', playerNames);
        if (playerNames.length > 0) {
          showPlayerStats(playerNames[0]);
        }
      } else {
        console.log('No player stats data available');
        loadPlayerStats().then(() => {
          console.log('Player stats loaded, try testPlayerStats() again');
        });
      }
    }

    // Debug function to compare roster names with stats names
    function debugPlayerNames() {
      console.log('=== Player Name Debug ===');
      console.log('Selected teams:', selectedTeams);
      
      if (selectedTeams.teamA && selectedTeams.teamB) {
        const teamARoster = teamRosters[selectedTeams.teamA] || [];
        const teamBRoster = teamRosters[selectedTeams.teamB] || [];
        
        console.log('Team A roster names:', teamARoster.map(p => p.name || p.displayName));
        console.log('Team B roster names:', teamBRoster.map(p => p.name || p.displayName));
      }
      
      if (window.playerStatsData) {
        const statsNames = Array.from(window.playerStatsData.playerTotals.keys());
        console.log('Stats database names:', statsNames);
        
        // Check for matches
        if (selectedTeams.teamA && selectedTeams.teamB) {
          const allRosterNames = [
            ...(teamRosters[selectedTeams.teamA] || []).map(p => p.name || p.displayName),
            ...(teamRosters[selectedTeams.teamB] || []).map(p => p.name || p.displayName)
          ];
          
          console.log('=== Name Matching Analysis ===');
          allRosterNames.forEach(rosterName => {
            const exactMatch = statsNames.includes(rosterName);
            const caseMatch = statsNames.find(s => s.toLowerCase() === rosterName.toLowerCase());
            const partialMatch = statsNames.find(s => 
              s.toLowerCase().includes(rosterName.toLowerCase()) ||
              rosterName.toLowerCase().includes(s.toLowerCase())
            );
            
            console.log(`"${rosterName}":`, {
              exact: exactMatch,
              caseInsensitive: caseMatch || 'none',
              partial: partialMatch || 'none'
            });
          });
        }
      } else {
        console.log('No player stats data loaded yet');
      }
    }

    // Admin System
    let activeMatch = null;
    let isAdmin = false;
    let livePlayers = new Set();

    // Check if user is admin using Firebase Auth
    function checkAdminStatus() {
      // This will be called by onAuthStateChanged
      if (isAdmin) {
        document.getElementById('admin-login-btn').style.display = 'none';
        document.getElementById('admin-panel-btn').style.display = 'inline-block';
        document.getElementById('admin-logout-btn').style.display = 'inline-block';
      } else {
        document.getElementById('admin-login-btn').style.display = 'inline-block';
        document.getElementById('admin-panel-btn').style.display = 'none';
        document.getElementById('admin-logout-btn').style.display = 'none';
      }
    }

    // Load active match from Firebase
    async function loadActiveMatch() {
      try {
        const docRef = doc(db, 'admin', 'activeMatch');
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
          activeMatch = docSnap.data();
          updateCurrentMatchDisplay();
          if (activeMatch.teamA && activeMatch.teamB) {
            selectedTeams.teamA = activeMatch.teamA;
            selectedTeams.teamB = activeMatch.teamB;
            console.log('Loaded active match:', selectedTeams);
            // Update the main page display
            updateMatchDisplay();
            loadTeamRosters().then(() => {
              // Player tabs will be updated in loadTeamRosters
            });
          }
        } else {
          // Set default match if none exists
          setDefaultMatch();
        }
      } catch (error) {
        console.error('Error loading active match:', error);
        setDefaultMatch();
      }
    }

    // Set default match (first two teams)
    function setDefaultMatch() {
      const teamKeys = Object.keys(TEAM_DATA);
      if (teamKeys.length >= 2) {
        selectedTeams.teamA = teamKeys[0];
        selectedTeams.teamB = teamKeys[1];
        loadTeamRosters();
      }
    }

    // Save active match to Firebase
    async function saveActiveMatch(teamA, teamB) {
      try {
        const matchData = {
          teamA: teamA,
          teamB: teamB,
          timestamp: serverTimestamp()
        };

        console.log('Attempting to save active match:', matchData);
        console.log('Current user:', auth.currentUser);
        console.log('Is admin:', isAdmin);

        const docRef = doc(db, 'admin', 'activeMatch');
        await setDoc(docRef, matchData);
        activeMatch = { teamA, teamB };
        updateCurrentMatchDisplay();
        
        // Update the main page display
        selectedTeams.teamA = teamA;
        selectedTeams.teamB = teamB;
        updateMatchDisplay();
        loadTeamRosters().then(() => {
          // Player tabs will be updated in loadTeamRosters
        });
        
        console.log('Active match saved:', teamA, 'vs', teamB);
      } catch (error) {
        console.error('Error saving active match:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        alert(`Failed to save active match: ${error.message}`);
      }
    }

    // Update current match display
    function updateCurrentMatchDisplay() {
      const display = document.getElementById('current-match-display');
      if (activeMatch && activeMatch.teamA && activeMatch.teamB) {
        const teamAData = TEAM_DATA[activeMatch.teamA];
        const teamBData = TEAM_DATA[activeMatch.teamB];
        display.innerHTML = `
          <div style="display: flex; align-items: center; gap: 1rem;">
            <img src="${teamAData.logo}" alt="${teamAData.name}" style="width: 40px; height: 40px; border-radius: 50%;">
            <span style="font-weight: 600;">${teamAData.name}</span>
            <span style="color: var(--text-muted);">VS</span>
            <span style="font-weight: 600;">${teamBData.name}</span>
            <img src="${teamBData.logo}" alt="${teamBData.name}" style="width: 40px; height: 40px; border-radius: 50%;">
          </div>
        `;
      } else {
        display.innerHTML = '<p>No active match set</p>';
      }
    }

    // Initialize admin panel
    function initializeAdminPanel() {
      // Populate team selectors
      const teamASelect = document.getElementById('admin-team-a');
      const teamBSelect = document.getElementById('admin-team-b');
      
      // Clear existing options first (except the first default option)
      teamASelect.innerHTML = '<option value="">Select Team A</option>';
      teamBSelect.innerHTML = '<option value="">Select Team B</option>';
      
      Object.keys(TEAM_DATA).forEach(teamKey => {
        const team = TEAM_DATA[teamKey];
        const optionA = new Option(team.name, teamKey);
        const optionB = new Option(team.name, teamKey);
        teamASelect.add(optionA);
        teamBSelect.add(optionB);
      });

      // Set current match if exists
      if (activeMatch && activeMatch.teamA && activeMatch.teamB) {
        teamASelect.value = activeMatch.teamA;
        teamBSelect.value = activeMatch.teamB;
      }

      // Event listeners
      document.getElementById('set-active-match').addEventListener('click', () => {
        const teamA = teamASelect.value;
        const teamB = teamBSelect.value;
        
        if (!teamA || !teamB) {
          alert('Please select both teams');
          return;
        }
        
        if (teamA === teamB) {
          alert('Teams must be different');
          return;
        }
        
        saveActiveMatch(teamA, teamB);
        // Update the main display
        selectedTeams.teamA = teamA;
        selectedTeams.teamB = teamB;
        loadTeamRosters();
        // Auto-load team statistics
        setTimeout(() => {
          showTeamStats();
        }, 1000); // Small delay to ensure rosters are loaded
        hideAdminPanel();
      });

      document.getElementById('clear-active-match').addEventListener('click', () => {
        if (confirm('Are you sure you want to clear the active match?')) {
          saveActiveMatch('', '');
          setDefaultMatch();
          hideAdminPanel();
        }
      });

      // Auto-load team stats when teams are selected in admin panel
      teamASelect.addEventListener('change', () => {
        const teamA = teamASelect.value;
        const teamB = teamBSelect.value;
        if (teamA && teamB && teamA !== teamB) {
          selectedTeams.teamA = teamA;
          selectedTeams.teamB = teamB;
          loadTeamRosters();
          setTimeout(() => {
            showTeamStats();
          }, 1000);
        }
      });

      teamBSelect.addEventListener('change', () => {
        const teamA = teamASelect.value;
        const teamB = teamBSelect.value;
        if (teamA && teamB && teamA !== teamB) {
          selectedTeams.teamA = teamA;
          selectedTeams.teamB = teamB;
          loadTeamRosters();
          setTimeout(() => {
            showTeamStats();
          }, 1000);
        }
      });

      // Update live status
      updateLivePlayersStatus();
      
      // Load current poll
      loadCurrentPoll();
    }

    // Show admin panel
    function showAdminPanel() {
      if (!isAdmin) {
        alert('Admin access required');
        return;
      }
      document.getElementById('admin-modal').style.display = 'flex';
      initializeAdminPanel();
    }

    // Hide admin panel
    function hideAdminPanel() {
      document.getElementById('admin-modal').style.display = 'none';
    }

    // Update live players status
    function updateLivePlayersStatus() {
      const statusDiv = document.getElementById('live-players-status');
      if (livePlayers.size === 0) {
        statusDiv.innerHTML = '<p>No live players detected</p>';
      } else {
        const liveList = Array.from(livePlayers).map(player => `<span class="live-indicator"></span>${player}`).join('<br>');
        statusDiv.innerHTML = `<p><strong>Live Players (${livePlayers.size}):</strong></p><p>${liveList}</p>`;
      }
    }

    // Live announcement banner functionality
    function initLiveAnnouncementBanner() {
      const banner = document.getElementById("live-announcement-banner");
      const nav = document.querySelector("nav");
      if (!banner || !nav) return;

      const BANNER_GAP = 12;
      const iconMarkup = "<span class='banner-icon' aria-hidden='true'><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none'><path fill='currentColor' d='M1.45 7.88a.75.75 0 0 1 1.06-.03A11.94 11.94 0 0 1 10 5c2.99 0 5.73 1.12 7.49 2.85a.75.75 0 0 1-1.03 1.09A10.44 10.44 0 0 0 10 6.5c-2.62 0-5 1-6.46 2.44a.75.75 0 0 1-1.06-.03zm2.94 3a.75.75 0 0 1 1.06-.05A7.45 7.45 0 0 1 10 9c2.09 0 3.99.86 5.55 2.3a.75.75 0 1 1-1 1.12A5.95 5.95 0 0 0 10 10.5a5.95 5.95 0 0 0-4.55 1.92.75.75 0 0 1-1.06-.03zM10 13.25a2.25 2.25 0 1 1 0 4.5 2.25 2.25 0 0 1 0-4.5z'/></svg></span>";
      const htmlEscapes = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "\u0027": "&#39;" };
      const escapeHtml = (str = "") => String(str).replace(/[&<>\"\u0027]/g, ch => htmlEscapes[ch] || ch);
      const highlight = (team) => `<strong>${escapeHtml(team)}</strong>`;
      
      const formatMessage = (teams) => {
        if (!teams.length) return "";
        if (teams.length === 1) return `${highlight(teams[0])} is live!`;
        if (teams.length === 2) return `${highlight(teams[0])} vs ${highlight(teams[1])} is live!`;
        const extra = teams.length - 2;
        return `${highlight(teams[0])} vs ${highlight(teams[1])} + ${extra} more live!`;
      };
      
      const syncLayout = () => {
        const navHeight = nav.offsetHeight;
        const isVisible = banner.classList.contains("is-visible");
        const bannerHeight = isVisible ? banner.offsetHeight : 0;
        banner.style.top = `${navHeight + BANNER_GAP}px`;
      };
      
      const hideBanner = () => {
        banner.classList.remove("is-visible");
        banner.innerHTML = "";
        syncLayout();
      };
      
      const showBanner = (teams) => {
        const message = formatMessage(teams);
        if (!message) {
          hideBanner();
          return;
        }
        banner.innerHTML = `${iconMarkup}<span>${message}</span>`;
        if (!banner.classList.contains("is-visible")) {
          requestAnimationFrame(() => {
            banner.classList.add("is-visible");
            requestAnimationFrame(syncLayout);
          });
        } else {
          syncLayout();
        }
      };

      // Store banner functions globally for use by live indicators
      window.liveBanner = { showBanner, hideBanner };
    }

    // Check for live players and update indicators
    async function updateLivePlayerIndicators() {
      // console.log('Checking live player indicators...');
      
      if (!window.twitchOAuth) {
        // console.log('Twitch OAuth not available - skipping live indicators');
        return;
      }

      // Get all player logins from the current teams
      const allPlayerLogins = [];
      // console.log('Team rosters available:', Object.keys(teamRosters));
      Object.values(teamRosters).forEach(roster => {
        roster.forEach(player => {
          // console.log(`Processing player: ${player.name || player.displayName}`);
          const twitchHandle = getTwitchHandleForPlayer(player);
          // console.log(`Resolved handle for ${player.name || player.displayName}: ${twitchHandle}`);
          if (twitchHandle && twitchHandle !== 'undefined' && twitchHandle !== 'null' && twitchHandle.length > 0) {
            allPlayerLogins.push(twitchHandle);
          }
        });
      });

      if (allPlayerLogins.length === 0) {
        // console.log('No player logins found for live stream checking');
        return;
      }

      // console.log('Checking live status for players:', allPlayerLogins);

      // Fetch current live streams in batches to avoid API limits
      let liveStreams = [];
      try {
        // Twitch API has a limit of 100 user_login parameters per request
        const BATCH_SIZE = 100;
        const batches = [];
        
        for (let i = 0; i < allPlayerLogins.length; i += BATCH_SIZE) {
          batches.push(allPlayerLogins.slice(i, i + BATCH_SIZE));
        }
        
        // Process each batch
        for (const batch of batches) {
          try {
            const batchStreams = await window.twitchOAuth.fetchLiveStreams(batch);
            liveStreams.push(...batchStreams);
          } catch (batchError) {
            console.error('Error fetching batch:', batchError);
            // Continue with other batches even if one fails
          }
        }
        
        // console.log('Fetched live streams:', liveStreams.length);
      } catch (error) {
        console.error('Error fetching live streams:', error);
        // console.log('Falling back to test data for live indicators');
        // Fallback: mark some players as live for testing
        liveStreams = allPlayerLogins.slice(0, 2).map(login => ({
          user_login: login,
          user_name: login,
          viewer_count: Math.floor(Math.random() * 50) + 10
        }));
        // console.log('Using fallback live streams:', liveStreams.length);
      }
      const playerTabs = document.querySelectorAll('.player-tab');
      
      // console.log('Found live streams:', liveStreams.length);
      // console.log('Found player tabs:', playerTabs.length);
      // console.log('Live streams data:', liveStreams.map(s => ({ name: s.user_name, login: s.user_login })));
      
      // Clear previous live indicators and reset colors
      playerTabs.forEach(tab => {
        tab.classList.remove('live');
        // Reset to default or red if no twitch
        if (tab.dataset.team && tab.dataset.playerIndex !== undefined) {
          const team = tab.dataset.team;
          const playerIndex = tab.dataset.playerIndex;
          const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
          const roster = teamRosters[teamKey] || [];
          const player = roster[playerIndex];
          if (player) {
            const twitchHandle = getTwitchHandleForPlayer(player);
            if (!twitchHandle) {
              tab.style.color = '#ef4444'; // Red for no Twitch link
            } else {
              tab.style.color = ''; // Reset to default
            }
          }
        }
      });
      livePlayers.clear();

      // Check each player tab
      playerTabs.forEach(tab => {
        if (tab.dataset.team && tab.dataset.playerIndex !== undefined) {
          const team = tab.dataset.team;
          const playerIndex = tab.dataset.playerIndex;
          const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
          const roster = teamRosters[teamKey] || [];
          const player = roster[playerIndex];
          
          if (player) {
            const playerName = player.name || player.displayName;
            const twitchHandle = getTwitchHandleForPlayer(player);
            
            // console.log(`Checking player ${playerName} with Twitch handle: ${twitchHandle}`);
            
            // Check if this player is live
            const isLive = liveStreams.some(stream => {
              const streamLogin = stream.user_login ? stream.user_login.toLowerCase() : '';
              const handle = twitchHandle ? twitchHandle.toLowerCase() : '';
              const match = streamLogin === handle;
              if (match) {
                // console.log(`Found live stream for ${playerName}: ${stream.user_name}`);
              }
              return match;
            });
            
            if (isLive) {
              tab.classList.add('live');
              tab.style.color = '#22c55e'; // Green for live players
              livePlayers.add(playerName);
              // console.log(`Marked ${playerName} as live`);
            }
          }
        }
      });

      // console.log('Live players found:', Array.from(livePlayers));

      // Update admin panel if open
      if (document.getElementById('admin-modal').style.display === 'flex') {
        updateLivePlayersStatus();
      }
      
      // Update banner with live teams
      updateLiveBanner();
    }

    // Update live banner based on live players
    function updateLiveBanner() {
      if (!window.liveBanner) return;
      
      // Get unique teams that have live players
      const liveTeams = new Set();
      const playerTabs = document.querySelectorAll('.player-tab.live');
      
      playerTabs.forEach(tab => {
        if (tab.dataset.team && tab.dataset.playerIndex !== undefined) {
          const team = tab.dataset.team;
          const teamKey = team === 'A' ? selectedTeams.teamA : selectedTeams.teamB;
          if (teamKey) {
            liveTeams.add(teamKey);
          }
        }
      });
      
      const liveTeamsArray = Array.from(liveTeams);
      // console.log('Live teams for banner:', liveTeamsArray);
      
      if (liveTeamsArray.length > 0) {
        window.liveBanner.showBanner(liveTeamsArray);
      } else {
        window.liveBanner.hideBanner();
      }
    }

    // Team Stats functionality
    function showTeamStats() {
      const statsSection = document.getElementById('team-stats-section');
      const statsContent = document.getElementById('team-stats-content');
      
      if (!statsSection || !statsContent) return;

      if (!window.playerStatsData || !selectedTeams.teamA || !selectedTeams.teamB) {
        statsContent.innerHTML = '<div class="text-center text-gray-400">No team statistics available</div>';
        statsSection.style.display = 'block';
        return;
      }

      const teamAData = TEAM_DATA[selectedTeams.teamA];
      const teamBData = TEAM_DATA[selectedTeams.teamB];
      const teamARoster = teamRosters[selectedTeams.teamA] || [];
      const teamBRoster = teamRosters[selectedTeams.teamB] || [];

      // Calculate team stats
      const teamAStats = calculateTeamStats(teamARoster);
      const teamBStats = calculateTeamStats(teamBRoster);

      // Generate HTML
      statsContent.innerHTML = `
        <div class="team-stats-grid">
          <div class="team-stats-card">
            <div class="team-stats-header">
              <img src="${teamAData.logo}" alt="${teamAData.name}">
              <h3>${teamAData.name}</h3>
            </div>
            <div class="team-metrics-grid">
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalKills}</div>
                <div class="team-metric-label">Total Kills</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalAssists}</div>
                <div class="team-metric-label">Total Assists</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalScore}</div>
                <div class="team-metric-label">Total Score</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalCaptures}</div>
                <div class="team-metric-label">Total Captures</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalReturns}</div>
                <div class="team-metric-label">Total Returns</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamAStats.totalTime.toFixed(1)}h</div>
                <div class="team-metric-label">Play Time</div>
              </div>
            </div>
          </div>
          
          <div class="team-stats-card">
            <div class="team-stats-header">
              <img src="${teamBData.logo}" alt="${teamBData.name}">
              <h3>${teamBData.name}</h3>
            </div>
            <div class="team-metrics-grid">
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalKills}</div>
                <div class="team-metric-label">Total Kills</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalAssists}</div>
                <div class="team-metric-label">Total Assists</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalScore}</div>
                <div class="team-metric-label">Total Score</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalCaptures}</div>
                <div class="team-metric-label">Total Captures</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalReturns}</div>
                <div class="team-metric-label">Total Returns</div>
              </div>
              <div class="team-metric">
                <div class="team-metric-value">${teamBStats.totalTime.toFixed(1)}h</div>
                <div class="team-metric-label">Play Time</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="team-line-chart">
          <div class="chart-header">Team Stats Comparison</div>
          <div class="chart-container">
            <canvas id="team-stats-chart" width="400" height="200"></canvas>
          </div>
        </div>
      `;

      statsSection.style.display = 'block';
      
      // Create the line chart after ensuring data is loaded
      const createChart = async () => {
        // Make sure player stats are loaded first
        if (!window.playerStatsData || !window.playerStatsData.playerTotals || window.playerStatsData.playerTotals.size === 0) {
          console.log('Player stats not loaded or empty, loading now...');
          await loadPlayerStats();
        }
        
        // Wait a bit more for data to be processed
        setTimeout(() => {
          createTeamStatsRadarChart(teamAStats, teamBStats, teamAData.name, teamBData.name);
        }, 200);
      };
      
      createChart();
    }

    function calculateTeamStats(roster) {
      let totalKills = 0;
      let totalAssists = 0;
      let totalScore = 0;
      let totalCaptures = 0;
      let totalReturns = 0;
      let totalTime = 0;

      console.log('Calculating team stats for roster:', roster);
      console.log('Available player stats data:', window.playerStatsData?.playerTotals?.size || 0, 'players');

      roster.forEach(player => {
        const playerName = player.name || player.displayName;
        console.log('Looking for player:', playerName);
        
        if (playerName && window.playerStatsData && window.playerStatsData.playerTotals) {
          // Try to find player stats with name matching
          let playerStats = window.playerStatsData.playerTotals.get(playerName);
          
          if (!playerStats) {
            // Try case-insensitive search
            const playerNames = Array.from(window.playerStatsData.playerTotals.keys());
            const foundName = playerNames.find(name => 
              name && name.toLowerCase() === playerName.toLowerCase()
            );
            if (foundName) {
              console.log('Found case-insensitive match:', foundName, 'for', playerName);
              playerStats = window.playerStatsData.playerTotals.get(foundName);
            } else {
              console.log('No stats found for player:', playerName);
            }
          } else {
            console.log('Found direct match for player:', playerName);
          }

          if (playerStats) {
            console.log('Player stats for', playerName, ':', playerStats);
            totalKills += parseFloat(playerStats.kills) || 0;
            totalAssists += parseFloat(playerStats.assists) || 0;
            totalScore += parseFloat(playerStats.score) || 0;
            totalCaptures += parseFloat(playerStats.captures) || 0;
            totalReturns += parseFloat(playerStats.returns) || 0;
            totalTime += parseFloat(playerStats.time) || 0;
          }
        }
      });

      console.log('Final team stats - Kills:', totalKills, 'Assists:', totalAssists, 'Score:', totalScore);

      const avgKillsPerMinute = totalTime > 0 ? (totalKills / (totalTime * 60)) : 0;
      const avgScorePerMinute = totalTime > 0 ? (totalScore / (totalTime * 60)) : 0;

      return {
        totalKills,
        totalAssists,
        totalScore,
        totalCaptures,
        totalReturns,
        totalTime,
        avgKillsPerMinute,
        avgScorePerMinute
      };
    }

    function createTeamStatsRadarChart(teamAStats, teamBStats, teamAName, teamBName) {
      console.log('Creating radar chart for teams:', teamAName, 'vs', teamBName);
      console.log('Team A stats:', teamAStats);
      console.log('Team B stats:', teamBStats);
      const canvas = document.getElementById('team-stats-chart');
      if (!canvas) {
        console.error('Team stats chart canvas not found');
        return;
      }

      // Destroy existing chart if it exists
      if (window.teamStatsChart) {
        window.teamStatsChart.destroy();
      }

      const ctx = canvas.getContext('2d');
      
      
      // Calculate normalized values for radar chart (0-100 scale)
      const normalizeValue = (value, maxValue) => {
        if (maxValue === 0) return 0;
        return Math.min(100, (value / maxValue) * 100);
      };
      
      // Calculate per-minute rates for better comparison
      const teamAKPM = teamAStats.totalTime > 0 ? teamAStats.totalKills / teamAStats.totalTime : 0;
      const teamBKPM = teamBStats.totalTime > 0 ? teamBStats.totalKills / teamBStats.totalTime : 0;
      const teamAAPM = teamAStats.totalTime > 0 ? teamAStats.totalAssists / teamAStats.totalTime : 0;
      const teamBAPM = teamBStats.totalTime > 0 ? teamBStats.totalAssists / teamBStats.totalTime : 0;
      const teamASPM = teamAStats.totalTime > 0 ? teamAStats.totalScore / teamAStats.totalTime : 0;
      const teamBSPM = teamBStats.totalTime > 0 ? teamBStats.totalScore / teamBStats.totalTime : 0;
      const teamACPM = teamAStats.totalTime > 0 ? teamAStats.totalCaptures / teamAStats.totalTime : 0;
      const teamBCPM = teamBStats.totalTime > 0 ? teamBStats.totalCaptures / teamBStats.totalTime : 0;
      const teamARPM = teamAStats.totalTime > 0 ? teamAStats.totalReturns / teamAStats.totalTime : 0;
      const teamBRPM = teamBStats.totalTime > 0 ? teamBStats.totalReturns / teamBStats.totalTime : 0;
      
      // Find max per-minute values for normalization
      const maxKPM = Math.max(teamAKPM, teamBKPM);
      const maxAPM = Math.max(teamAAPM, teamBAPM);
      const maxSPM = Math.max(teamASPM, teamBSPM);
      const maxCPM = Math.max(teamACPM, teamBCPM);
      const maxRPM = Math.max(teamARPM, teamBRPM);
      
      // Prepare radar chart data
      const labels = ['Kills/min', 'Assists/min', 'Score/min', 'Captures/min', 'Returns/min'];
      
      const teamAData = [
        normalizeValue(teamAKPM, maxKPM),
        normalizeValue(teamAAPM, maxAPM),
        normalizeValue(teamASPM, maxSPM),
        normalizeValue(teamACPM, maxCPM),
        normalizeValue(teamARPM, maxRPM)
      ];
      
      const teamBData = [
        normalizeValue(teamBKPM, maxKPM),
        normalizeValue(teamBAPM, maxAPM),
        normalizeValue(teamBSPM, maxSPM),
        normalizeValue(teamBCPM, maxCPM),
        normalizeValue(teamBRPM, maxRPM)
      ];
      
      console.log('Team A normalized data:', teamAData);
      console.log('Team B normalized data:', teamBData);

      window.teamStatsChart = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: labels,
          datasets: [
            {
              label: teamAName,
              data: teamAData,
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.2)',
              borderWidth: 3,
              pointBackgroundColor: '#3b82f6',
              pointBorderColor: '#ffffff',
              pointBorderWidth: 2,
              pointRadius: 6
            },
            {
              label: teamBName,
              data: teamBData,
              borderColor: '#ef4444',
              backgroundColor: 'rgba(239, 68, 68, 0.2)',
              borderWidth: 3,
              pointBackgroundColor: '#ef4444',
              pointBorderColor: '#ffffff',
              pointBorderWidth: 2,
              pointRadius: 6
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'top',
              labels: {
                color: '#e2e8f0',
                font: {
                  size: 14,
                  weight: 'bold'
                },
                padding: 20
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#e2e8f0',
              borderColor: 'rgba(148, 163, 184, 0.2)',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  const teamName = context.dataset.label;
                  const statName = context.label;
                  const normalizedValue = context.parsed.r;
                  
                  // Get actual values for tooltip
                  let actualValue = 0;
                  if (teamName === teamAName) {
                    switch (statName) {
                      case 'Kills/min': actualValue = teamAKPM; break;
                      case 'Assists/min': actualValue = teamAAPM; break;
                      case 'Score/min': actualValue = teamASPM; break;
                      case 'Captures/min': actualValue = teamACPM; break;
                      case 'Returns/min': actualValue = teamARPM; break;
                    }
                  } else {
                    switch (statName) {
                      case 'Kills/min': actualValue = teamBKPM; break;
                      case 'Assists/min': actualValue = teamBAPM; break;
                      case 'Score/min': actualValue = teamBSPM; break;
                      case 'Captures/min': actualValue = teamBCPM; break;
                      case 'Returns/min': actualValue = teamBRPM; break;
                    }
                  }
                  
                  return `${statName}: ${actualValue.toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            r: {
              beginAtZero: true,
              max: 100,
              ticks: {
                color: '#94a3b8',
                font: {
                  size: 10
                },
                callback: function(value) {
                  return value + '%';
                }
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.2)'
              },
              angleLines: {
                color: 'rgba(148, 163, 184, 0.2)'
              },
              pointLabels: {
                color: '#e2e8f0',
                font: {
                  size: 12,
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }

    function hideTeamStats() {
      const statsSection = document.getElementById('team-stats-section');
      if (statsSection) {
        statsSection.style.display = 'none';
      }
      
      // Destroy the team stats chart if it exists
      if (window.teamStatsChart) {
        window.teamStatsChart.destroy();
        window.teamStatsChart = null;
      }
    }

    function initializeTeamStats() {
      const closeBtn = document.getElementById('close-team-stats-btn');
      if (closeBtn) {
        closeBtn.addEventListener('click', hideTeamStats);
      }
      
      const showBtn = document.getElementById('show-team-stats-btn');
      if (showBtn) {
        showBtn.addEventListener('click', showTeamStats);
      }
      
      // Add caster button functionality
      const casterBtn = document.getElementById('caster-btn');
      if (casterBtn) {
        casterBtn.addEventListener('click', () => {
          const streamFrame = document.getElementById('stream-frame');
          if (streamFrame) {
            let parentDomain = window.location.hostname;
            if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
              parentDomain = 'tribesprofessionalleague.com';
            }
            streamFrame.src = `https://player.twitch.tv/?channel=oo0oo_live&parent=${parentDomain}&autoplay=false`;
            console.log('Loaded caster stream: oo0oo_live');
          }
          
          // Also update chat to caster
          updateStreamerChat('oo0oo_live');
          const streamerSelect = document.getElementById('streamer-select');
          if (streamerSelect) {
            streamerSelect.value = 'oo0oo_live';
          }
        });
      }
    }

    // Load recent matches from Firebase
    async function loadRecentMatches() {
      try {
        console.log('Loading recent matches from TPL-O league system...');
        
        // Get all league schedules
        const schedulesRef = collection(db, 'leagueSchedules');
        const querySnapshot = await getDocs(schedulesRef);
        
        const allMatches = [];
        
        // Process each schedule document
        querySnapshot.forEach((doc) => {
          const data = doc.data();
          if (data.weeks && Array.isArray(data.weeks)) {
            data.weeks.forEach(week => {
              if (week.matches && Array.isArray(week.matches)) {
                week.matches.forEach(match => {
                  // Only include matches with scores (completed matches)
                  if (match.homeScore != null && match.awayScore != null && match.date) {
                    allMatches.push({
                      teamA: match.away,
                      teamB: match.home,
                      scoreA: match.awayScore,
                      scoreB: match.homeScore,
                      date: match.date,
                      created: new Date(match.date), // Use match date for sorting
                      season: data.season,
                      division: data.division,
                      week: week.week
                    });
                  }
                });
              }
            });
          }
        });
        
        // Sort by date (most recent first) and take the 6 most recent
        const recentMatches = allMatches
          .sort((a, b) => new Date(b.date) - new Date(a.date))
          .slice(0, 6);
        
        console.log('Recent matches loaded:', recentMatches);
        displayRecentMatches(recentMatches);
      } catch (error) {
        console.error('Error loading recent matches:', error);
        // Show placeholder if no matches found
        displayRecentMatches([]);
      }
    }

    // Display recent matches in the UI
    function displayRecentMatches(matches) {
      const grid = document.getElementById('recent-matches-grid');
      if (!grid) {
        console.error('Recent matches grid not found');
        return;
      }
      
      if (matches.length === 0) {
        grid.innerHTML = '<div class="recent-match-card"><div class="match-teams"><span class="team-name">No recent matches found</span></div></div>';
        return;
      }
      
      // Function to get team abbreviation from full name
      const getTeamAbbr = (teamName) => {
        // Find the team key by matching the full name
        for (const [key, data] of Object.entries(TEAM_DATA)) {
          if (data.name === teamName || key === teamName) {
            return key;
          }
        }
        return teamName; // Return original if no match found
      };
      
      // Function to get team logo from team name
      const getTeamLogo = (teamName) => {
        // First try direct match
        for (const [key, data] of Object.entries(TEAM_DATA)) {
          if (data.name === teamName || key === teamName) {
            return data.logo;
          }
        }
        
        // Try variations mapping (TPL-O team names)
        const variations = {
          'Avalanche!': 'AV!',
          'Avalanche': 'AV!',
          'ePidemic': 'EPI',
          'Hegemony of Euros': 'HoE',
          'Flying Tractors': 'FT',
          'Flag Pole Smokers': 'FPS',
          'Toxic Aimers': 'TA',
          'Texas Militia': 'TXM',
          'Kicked to Lobby': 'KTL',
          'Unhandled Exception': 'UE',
          'Magic': 'WIZ',
          'DeadStop': 'DS',
          'null': 'Null',
          'Zen': 'ZEN',
          'Team DPRK': 'DPRK',
          'DPRK': 'DPRK'
        };
        
        const teamKey = variations[teamName];
        if (teamKey && TEAM_DATA[teamKey]) {
          return TEAM_DATA[teamKey].logo;
        }
        
        return null; // Return null if no match found
      };
      
      grid.innerHTML = matches.map(match => {
        const teamA = match.teamA || 'Team A';
        const teamB = match.teamB || 'Team B';
        const teamAbbr = getTeamAbbr(teamA);
        const teamBAbbr = getTeamAbbr(teamB);
        const scoreA = match.scoreA || 0;
        const scoreB = match.scoreB || 0;
        const date = match.date ? new Date(match.date) : new Date();
        const dateStr = date.toLocaleDateString();
        
        // Get team logos
        const teamALogo = getTeamLogo(teamA);
        const teamBLogo = getTeamLogo(teamB);
        
        return `
          <div class="recent-match-card">
            <div class="match-teams">
              <div class="team-info">
                ${teamALogo ? `<img src="${teamALogo}" alt="${teamA} logo" class="team-logo-small" onerror="this.style.display='none'">` : ''}
                <span class="team-name">${teamAbbr}</span>
              </div>
              <div class="match-score">${scoreA} - ${scoreB}</div>
              <div class="team-info">
                ${teamBLogo ? `<img src="${teamBLogo}" alt="${teamB} logo" class="team-logo-small" onerror="this.style.display='none'">` : ''}
                <span class="team-name">${teamBAbbr}</span>
              </div>
            </div>
            <div class="match-date">${dateStr}</div>
          </div>
        `;
      }).join('');
    }

    // Initialize Twitch chat functionality
    function initializeTwitchChat() {
      console.log('Initializing Twitch chat...');
      
      const streamerSelect = document.getElementById('streamer-select');
      const chatIframe = document.getElementById('twitch-chat-iframe');
      const chatLoading = document.querySelector('.chat-loading');
      
      if (!streamerSelect || !chatIframe) {
        console.error('Twitch chat elements not found');
        return;
      }
      
      // Set up streamer dropdown change handler
      streamerSelect.addEventListener('change', function() {
        const selectedChannel = this.value;
        updateStreamerChat(selectedChannel);
      });
      
      // Initialize with default chat (caster)
      updateStreamerChat('oo0oo_live');
    }

    // Update streamer chat iframe
    function updateStreamerChat(channel = 'oo0oo_live') {
      const chatIframe = document.getElementById('twitch-chat-iframe');
      const chatLoading = document.querySelector('.chat-loading');
      
      if (!chatIframe) {
        console.error('Chat iframe not found');
        return;
      }
      
      // Show loading state
      if (chatLoading) {
        chatLoading.style.display = 'flex';
      }
      chatIframe.style.display = 'none';
      
      // Determine parent domain for Twitch embed
      let parentDomain = window.location.hostname;
      if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
        parentDomain = 'tribesprofessionalleague.com';
      }
      
      // Update iframe source
      const chatUrl = `https://www.twitch.tv/embed/${encodeURIComponent(channel)}/chat?parent=${parentDomain}`;
      console.log(`Loading Twitch chat: ${chatUrl}`);
      
      // Add error handling for iframe load
      chatIframe.onload = function() {
        console.log('Twitch chat iframe loaded successfully');
        if (chatLoading) {
          chatLoading.style.display = 'none';
        }
        chatIframe.style.display = 'block';
      };
      
      chatIframe.onerror = function() {
        console.error('Failed to load Twitch chat iframe');
        if (chatLoading) {
          chatLoading.innerHTML = `
            <div class="text-center">
              <div class="text-red-400 mb-2">⚠️</div>
              <div>Failed to load chat. Please try again.</div>
            </div>
          `;
        }
      };
      
      chatIframe.src = chatUrl;
      
      // Fallback timeout in case onload doesn't fire
      setTimeout(() => {
        if (chatIframe.style.display === 'none') {
          console.log('Fallback: showing chat after timeout');
          if (chatLoading) {
            chatLoading.style.display = 'none';
          }
          chatIframe.style.display = 'block';
        }
      }, 2000);
      
      console.log(`Updated Twitch chat to channel: ${channel} with parent: ${parentDomain}`);
    }


    // Viewer tracking variables
    let viewerData = new Map(); // Store current viewer counts
    let previousViewerData = new Map(); // Store previous counts for trends
    let viewerUpdateInterval = null;
    let viewerHistory = []; // Store historical viewer data
    let peakViewersToday = 0;
    let totalViewTime = 0; // in minutes
    let sessionStartTime = Date.now();

    // Initialize viewer tracking
    function initializeViewerTracking() {
      console.log('Initializing viewer tracking...');
      
      // Check for tracking prevention issues
      checkTrackingPrevention();
      
      // Initialize viewer history modal
      initializeViewerHistoryModal();
      
      // Start periodic viewer updates
      viewerUpdateInterval = setInterval(updateViewerCounts, 30000); // Update every 30 seconds
      
      // Initial update with a small delay to ensure DOM is ready
      setTimeout(() => {
        console.log('Running initial viewer count update...');
        updateViewerCounts();
      }, 1000);
    }
    
    // Check for tracking prevention issues
    function checkTrackingPrevention() {
      try {
        // Test if we can access localStorage (often blocked by tracking prevention)
        const testKey = 'tracking_test_' + Date.now();
        localStorage.setItem(testKey, 'test');
        localStorage.removeItem(testKey);
        console.log('Local storage access: OK');
      } catch (error) {
        console.warn('Tracking prevention detected - localStorage blocked:', error);
        // Show a user-friendly message
        const viewerSection = document.querySelector('.viewer-tracking-section');
        if (viewerSection) {
          const warning = document.createElement('div');
          warning.className = 'tracking-warning';
          warning.style.cssText = `
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
            color: #ffc107;
            font-size: 0.9rem;
          `;
          warning.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <span>⚠️</span>
              <span>Browser tracking prevention may limit viewer data. Try disabling tracking protection for this site.</span>
            </div>
          `;
          viewerSection.insertBefore(warning, viewerSection.firstChild);
        }
      }
    }

    // Initialize viewer history modal
    function initializeViewerHistoryModal() {
      console.log('Initializing viewer history modal...');
      
      const historyBtn = document.getElementById('viewer-history-btn');
      const historyModal = document.getElementById('viewer-history-modal');
      const closeBtn = document.getElementById('close-viewer-history');
      
      console.log('History button found:', !!historyBtn);
      console.log('History modal found:', !!historyModal);
      console.log('Close button found:', !!closeBtn);
      
      if (historyBtn) {
        historyBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('History button clicked');
          showViewerHistory();
        });
      } else {
        console.error('Viewer history button not found!');
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Close button clicked');
          hideViewerHistory();
        });
      } else {
        console.error('Close button not found!');
      }
      
      if (historyModal) {
        historyModal.addEventListener('click', (e) => {
          if (e.target === historyModal) {
            console.log('Modal background clicked');
            hideViewerHistory();
          }
        });
      } else {
        console.error('Viewer history modal not found!');
      }
    }

    // Show viewer history modal
    function showViewerHistory() {
      console.log('showViewerHistory called');
      const modal = document.getElementById('viewer-history-modal');
      console.log('Modal element:', modal);
      
      if (modal) {
        console.log('Updating viewer history display...');
        updateViewerHistoryDisplay();
        console.log('Setting modal display to flex');
        modal.style.display = 'flex';
        console.log('Modal should now be visible');
      } else {
        console.error('Viewer history modal not found!');
      }
    }

    // Hide viewer history modal
    function hideViewerHistory() {
      const modal = document.getElementById('viewer-history-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Update viewer history display
    function updateViewerHistoryDisplay() {
      // Calculate average viewers
      const avgViewers = viewerHistory.length > 0 
        ? Math.round(viewerHistory.reduce((sum, entry) => sum + entry.totalViewers, 0) / viewerHistory.length)
        : 0;
      
      // Calculate total view time (simplified - based on session time)
      const sessionMinutes = Math.floor((Date.now() - sessionStartTime) / 60000);
      const hours = Math.floor(sessionMinutes / 60);
      const minutes = sessionMinutes % 60;
      
      // Update history stats
      document.getElementById('peak-viewers-today').textContent = peakViewersToday.toLocaleString();
      document.getElementById('avg-viewers').textContent = avgViewers.toLocaleString();
      document.getElementById('total-view-time').textContent = `${hours}h ${minutes}m`;
      
      // Update recent updates
      updateRecentViewerUpdates();
    }

    // Update recent viewer updates
    function updateRecentViewerUpdates() {
      const recentUpdates = document.getElementById('recent-viewer-updates');
      if (!recentUpdates) return;
      
      // Show last 10 updates
      const recentHistory = viewerHistory.slice(-10).reverse();
      
      if (recentHistory.length === 0) {
        recentUpdates.innerHTML = '<div class="text-center text-gray-400 py-4">No viewer data yet</div>';
        return;
      }
      
      recentUpdates.innerHTML = recentHistory.map(entry => {
        const time = new Date(entry.timestamp).toLocaleTimeString();
        return `
          <div class="update-item">
            <div class="update-details">${entry.totalViewers.toLocaleString()} total viewers</div>
            <div class="update-time">${time}</div>
          </div>
        `;
      }).join('');
    }

    // Update viewer counts for all streamers
    async function updateViewerCounts() {
      try {
        console.log('Updating viewer counts...');
        
        // Store previous data for trend calculation
        previousViewerData = new Map(viewerData);
        viewerData.clear();
        
        // Get all streamers from team data
        const allStreamers = [];
        
        // Add caster
        allStreamers.push({ name: '0o0o0 (Caster)', handle: 'oo0oo_live' });
        
        // Add TPL main chat
        allStreamers.push({ name: 'TPL Main Chat', handle: 'tribesprofessionalleague' });
        
        // Use the team streams data from oauth.js if available, otherwise fall back to TEAM_DATA
        let teamStreamsData = {};
        if (window.twitchOAuth && window.twitchOAuth.TEAM_STREAMS) {
          teamStreamsData = window.twitchOAuth.TEAM_STREAMS;
          console.log('Using team streams data from oauth.js');
        } else {
          // Fallback to TEAM_DATA
          Object.values(TEAM_DATA).forEach(team => {
            if (team.streams && Array.isArray(team.streams)) {
              teamStreamsData[team.name] = team.streams;
            }
          });
          console.log('Using fallback team data from TEAM_DATA');
        }
        
        // Add all team streamers
        Object.entries(teamStreamsData).forEach(([teamName, streams]) => {
          if (Array.isArray(streams)) {
            streams.forEach(streamer => {
              const handle = streamer.url.match(/twitch\.tv\/([^/?]+)/i)?.[1];
              if (handle) {
                allStreamers.push({ 
                  name: streamer.name, 
                  handle: handle,
                  team: teamName 
                });
              }
            });
          }
        });
        
        console.log('Found streamers:', allStreamers);
        
        // Fetch real viewer data for each streamer
        const viewerPromises = allStreamers.map(async (streamer) => {
          try {
            const viewerCount = await getTwitchViewerCount(streamer.handle);
            viewerData.set(streamer.handle, {
              name: streamer.name,
              handle: streamer.handle,
              team: streamer.team,
              viewers: viewerCount,
              isLive: viewerCount > 0
            });
          } catch (error) {
            console.error(`Error fetching viewer count for ${streamer.handle}:`, error);
            viewerData.set(streamer.handle, {
              name: streamer.name,
              handle: streamer.handle,
              team: streamer.team,
              viewers: 0,
              isLive: false
            });
          }
        });
        
        await Promise.all(viewerPromises);
        
        console.log('Viewer data set:', viewerData);
        
        // Update the UI
        updateViewerDisplay();
        
        // Track viewer history
        trackViewerHistory();
        
      } catch (error) {
        console.error('Error updating viewer counts:', error);
      }
    }

    // Track viewer history
    function trackViewerHistory() {
      let totalViewers = 0;
      viewerData.forEach((data) => {
        if (data.isLive && data.viewers > 0) {
          totalViewers += data.viewers;
        }
      });
      
      // Update peak viewers
      if (totalViewers > peakViewersToday) {
        peakViewersToday = totalViewers;
      }
      
      // Add to history
      viewerHistory.push({
        timestamp: Date.now(),
        totalViewers: totalViewers,
        streamers: Array.from(viewerData.values()).filter(data => data.isLive)
      });
      
      // Keep only last 100 entries to prevent memory issues
      if (viewerHistory.length > 100) {
        viewerHistory = viewerHistory.slice(-100);
      }
    }

    // Get Twitch viewer count for a specific channel using real Twitch API
    async function getTwitchViewerCount(channel) {
      try {
        console.log(`Getting viewer count for channel: ${channel}`);
        
        // Check if we have Twitch OAuth available
        if (!window.twitchOAuth || !window.twitchOAuth.getToken()) {
          console.log('No Twitch OAuth token available, returning 0 viewers');
          // Return 0 when not authenticated to avoid showing fake live streams
          return 0;
        }
        
        // Try to use the existing Twitch API to get real viewer data
        try {
          const liveStreams = await window.twitchOAuth.fetchLiveStreams([channel]);
          console.log(`Live streams for ${channel}:`, liveStreams);
          
          if (liveStreams && liveStreams.length > 0) {
            const stream = liveStreams.find(s => 
              s.user_login && s.user_login.toLowerCase() === channel.toLowerCase()
            );
            
            if (stream) {
              console.log(`Found live stream for ${channel}: ${stream.viewer_count} viewers`);
              return stream.viewer_count || 0;
            }
          }
          
          console.log(`No live stream found for ${channel}`);
          return 0;
          
        } catch (apiError) {
          console.warn(`Twitch API call failed for ${channel}, likely due to tracking prevention:`, apiError);
          // If API fails, return 0 to avoid showing fake live streams
          return 0;
        }
        
      } catch (error) {
        console.error(`Error getting viewer count for ${channel}:`, error);
        // Return 0 on error to avoid showing fake live streams
        return 0;
      }
    }

    // Update the viewer display in the UI
    function updateViewerDisplay() {
      console.log('updateViewerDisplay called');
      const totalViewerCount = document.getElementById('total-viewer-count');
      const streamerViewersList = document.getElementById('streamer-viewers-list');
      
      console.log('Total viewer count element:', totalViewerCount);
      console.log('Streamer viewers list element:', streamerViewersList);
      
      if (!totalViewerCount || !streamerViewersList) {
        console.error('Viewer display elements not found');
        return;
      }
      
      // Calculate total viewers
      let totalViewers = 0;
      const liveStreamers = [];
      
      console.log('Processing viewer data:', viewerData);
      
      viewerData.forEach((data) => {
        console.log('Processing streamer:', data);
        if (data.viewers > 0) { // Show all streamers with viewers, not just live ones
          totalViewers += data.viewers;
          liveStreamers.push(data);
        }
      });
      
      console.log('Total viewers calculated:', totalViewers);
      console.log('Live streamers:', liveStreamers);
      
      // Update total viewer count with animation
      animateNumber(totalViewerCount, totalViewers);
      
      // Update individual streamer viewer counts
      streamerViewersList.innerHTML = '';
      
      if (liveStreamers.length === 0) {
        console.log('No live streamers found, showing empty state');
        streamerViewersList.innerHTML = `
          <div class="text-center text-gray-400 py-4">
            <div class="text-2xl mb-2">📺</div>
            <div>No live streams detected</div>
          </div>
        `;
        return;
      }
      
      // Sort by viewer count (highest first) and limit to top 5
      liveStreamers.sort((a, b) => b.viewers - a.viewers);
      const topStreamers = liveStreamers.slice(0, 5);
      
      console.log('Rendering top streamer items:', topStreamers);
      
      topStreamers.forEach((streamer) => {
        const previousData = previousViewerData.get(streamer.handle);
        const trend = calculateViewerTrend(streamer.viewers, previousData?.viewers || 0);
        
        const streamerItem = document.createElement('div');
        streamerItem.className = 'streamer-viewer-item';
        streamerItem.innerHTML = `
          <div class="streamer-name">
            ${streamer.name}
            ${streamer.team ? `<span class="text-xs text-gray-400">(${streamer.team})</span>` : ''}
          </div>
          <div class="streamer-count">
            ${streamer.viewers.toLocaleString()}
            ${trend !== 'neutral' ? `<span class="viewer-trend ${trend}">${trend === 'up' ? '↗' : '↘'}</span>` : ''}
          </div>
        `;
        
        streamerViewersList.appendChild(streamerItem);
      });
      
      // Add a summary if there are more than 5 streamers
      if (liveStreamers.length > 5) {
        const moreItem = document.createElement('div');
        moreItem.className = 'streamer-viewer-item';
        moreItem.style.cssText = 'text-align: center; color: var(--text-muted); font-style: italic; background: rgba(148, 163, 184, 0.1);';
        moreItem.innerHTML = `+${liveStreamers.length - 5} more streamers`;
        streamerViewersList.appendChild(moreItem);
      }
      
      console.log('Viewer display update complete');
      
      // Update event streams when viewer data changes
      if (typeof updateEventStreamsFromLiveData === 'function') {
        updateEventStreamsFromLiveData();
        if (typeof renderEventStreams === 'function') {
          renderEventStreams();
        }
        if (typeof updateStreamCount === 'function') {
          updateStreamCount();
        }
      }
    }

    // Calculate viewer trend (up, down, or neutral)
    function calculateViewerTrend(current, previous) {
      if (!previous || previous === 0) return 'neutral';
      
      const change = current - previous;
      const percentChange = (change / previous) * 100;
      
      if (percentChange > 5) return 'up';
      if (percentChange < -5) return 'down';
      return 'neutral';
    }

    // Animate number changes
    function animateNumber(element, targetNumber) {
      const currentNumber = parseInt(element.textContent) || 0;
      const increment = (targetNumber - currentNumber) / 20; // 20 steps
      let current = currentNumber;
      
      const timer = setInterval(() => {
        current += increment;
        if ((increment > 0 && current >= targetNumber) || (increment < 0 && current <= targetNumber)) {
          current = targetNumber;
          clearInterval(timer);
        }
        element.textContent = Math.floor(current).toLocaleString();
      }, 50);
    }

    // Update streamer dropdown with available streams
    function updateStreamerDropdown() {
      const streamerSelect = document.getElementById('streamer-select');
      if (!streamerSelect) return;
      
      // Clear existing options except the first two (caster and main chat)
      streamerSelect.innerHTML = `
        <option value="oo0oo_live">0o0o0 (Caster)</option>
        <option value="tribesprofessionalleague">TPL Main Chat</option>
      `;
      
      // Add all team streams
      Object.values(TEAM_DATA).forEach(team => {
        if (team.streams && Array.isArray(team.streams)) {
          team.streams.forEach(streamer => {
            const option = document.createElement('option');
            option.value = streamer.url.match(/twitch\.tv\/([^/?]+)/i)?.[1] || streamer.name.toLowerCase();
            option.textContent = `${streamer.name} (${team.name})`;
            streamerSelect.appendChild(option);
          });
        }
      });
    }

    // Make test functions available globally for debugging
    window.testDPRKvsZen = testDPRKvsZen;
    window.testBackgroundImages = testBackgroundImages;
    window.testPlayerMapping = testPlayerMapping;
    window.testTwitchPlayerFormat = testTwitchPlayerFormat;
    window.testTeamLogos = testTeamLogos;
    window.adjustBackgroundOpacity = adjustBackgroundOpacity;
    window.testPlayerStats = testPlayerStats;
    window.showPlayerStats = showPlayerStats;
    window.hidePlayerStats = hidePlayerStats;
    window.debugPlayerNames = debugPlayerNames;
    window.showAdminPanel = showAdminPanel;
    window.hideAdminPanel = hideAdminPanel;
    window.showTeamStats = showTeamStats;
    window.hideTeamStats = hideTeamStats;
    // window.debugStatsSystem = debugStatsSystem; // Function not defined
    window.loadRecentMatches = loadRecentMatches;
    window.initializeTwitchChat = initializeTwitchChat;
    window.updateStreamerChat = updateStreamerChat;
    window.initializeViewerTracking = initializeViewerTracking;
    window.updateViewerCounts = updateViewerCounts;
    window.showViewerHistory = showViewerHistory;
    window.hideViewerHistory = hideViewerHistory;
    
    // Test function for debugging viewer tracking
    window.testViewerTracking = function() {
      console.log('Testing viewer tracking...');
      console.log('TEAM_DATA:', TEAM_DATA);
      console.log('Twitch OAuth available:', !!window.twitchOAuth);
      console.log('Twitch token available:', !!window.twitchOAuth?.getToken());
      updateViewerCounts();
    };
    
    // Test function for debugging live indicators
    window.testLiveIndicators = async function() {
      console.log('Testing live indicators...');
      console.log('Team rosters:', teamRosters);
      console.log('Selected teams:', selectedTeams);
      console.log('Twitch OAuth available:', !!window.twitchOAuth);
      console.log('Twitch token available:', !!window.twitchOAuth?.getToken());
      console.log('Firebase handles loaded:', firebaseTwitchHandles);
      await updateLivePlayerIndicators();
    };
    
    // Function to manually refresh Firebase handles and update indicators
    window.refreshFirebaseHandles = async function() {
      console.log('Manually refreshing Firebase handles...');
      await loadFirebaseTwitchHandles();
      console.log('Firebase handles after refresh:', firebaseTwitchHandles);
      await updateLivePlayerIndicators();
    };
    
    // Debug function to check live detection status
    window.debugLiveDetection = function() {
      console.log('=== LIVE DETECTION DEBUG ===');
      console.log('Twitch OAuth available:', !!window.twitchOAuth);
      console.log('Twitch token available:', !!window.twitchOAuth?.getToken());
      console.log('Team rosters loaded:', Object.keys(teamRosters));
      console.log('Selected teams:', selectedTeams);
      console.log('Firebase handles:', firebaseTwitchHandles);
      
      // Check if player tabs exist
      const playerTabs = document.querySelectorAll('.player-tab');
      console.log('Player tabs found:', playerTabs.length);
      
      // Check current live players
      console.log('Current live players:', Array.from(livePlayers));
      
      // Test with a specific player
      if (selectedTeams.teamA && teamRosters[selectedTeams.teamA]) {
        const firstPlayer = teamRosters[selectedTeams.teamA][0];
        if (firstPlayer) {
          const handle = getTwitchHandleForPlayer(firstPlayer);
          console.log(`First player (${firstPlayer.name}) Twitch handle:`, handle);
        }
      }
    };
    
    // Enhanced debug function to test live detection manually
    window.testLiveDetection = async function() {
      console.log('=== TESTING LIVE DETECTION ===');
      
      // Check if we have the necessary components
      if (!window.twitchOAuth) {
        console.error('❌ Twitch OAuth not available');
        return;
      }
      
      if (!window.twitchOAuth.getToken()) {
        console.error('❌ No Twitch token - you may need to sign in with Twitch');
        return;
      }
      
      console.log('✅ Twitch OAuth and token available');
      
      // Test with a known live streamer (you can change this to your handle)
      const testHandles = ['pandoracast']; // Add your Twitch handle here
      
      try {
        console.log('Testing live stream detection for:', testHandles);
        const liveStreams = await window.twitchOAuth.fetchLiveStreams(testHandles);
        console.log('Live streams found:', liveStreams);
        
        if (liveStreams && liveStreams.length > 0) {
          console.log('✅ Live detection is working! Found streams:', liveStreams.map(s => s.user_name));
        } else {
          console.log('ℹ️ No live streams found for test handles');
        }
      } catch (error) {
        console.error('❌ Error testing live detection:', error);
      }
    };
    
    // Function to debug what handles are being sent to Twitch API
    window.debugTwitchHandles = function() {
      console.log('=== DEBUGGING TWITCH HANDLES ===');
      
      const allPlayerLogins = [];
      Object.values(teamRosters).forEach(roster => {
        roster.forEach(player => {
          const twitchHandle = getTwitchHandleForPlayer(player);
          if (twitchHandle) {
            allPlayerLogins.push(twitchHandle);
          }
        });
      });
      
      console.log('All Twitch handles being sent to API:', allPlayerLogins);
      console.log('Total handles:', allPlayerLogins.length);
      
      // Check for invalid handles
      const invalidHandles = allPlayerLogins.filter(handle => {
        return !handle || handle.length === 0 || handle.includes('undefined') || handle.includes('null');
      });
      
      if (invalidHandles.length > 0) {
        console.warn('⚠️ Invalid handles found:', invalidHandles);
      }
      
      // Check for handles that might be too long
      const longHandles = allPlayerLogins.filter(handle => handle && handle.length > 25);
      if (longHandles.length > 0) {
        console.warn('⚠️ Suspiciously long handles:', longHandles);
      }
      
      return allPlayerLogins;
    };
    
    // Function to manually trigger live indicator update
    window.forceLiveUpdate = async function() {
      console.log('=== FORCING LIVE UPDATE ===');
      try {
        await updateLivePlayerIndicators();
        console.log('✅ Live indicators updated');
      } catch (error) {
        console.error('❌ Error updating live indicators:', error);
      }
    };
    
    // Donation System Functions
    function triggerDonation(type, amount, message, from) {
      console.log(`Donation triggered: ${type} - ${amount} - ${message} - ${from}`);
      
      // Create confetti effect
      createConfetti();
      
      // Show donation notification
      showDonationNotification(type, amount, message, from);
      
      // Store donation in localStorage for persistence
      const donation = {
        type,
        amount,
        message,
        from,
        timestamp: Date.now()
      };
      
      // Add to donation history
      let donations = JSON.parse(localStorage.getItem('donations') || '[]');
      donations.push(donation);
      localStorage.setItem('donations', JSON.stringify(donations));
      
      // Broadcast to other users (in a real implementation, this would use WebSockets)
      broadcastDonation(donation);
    }
    
    function createConfetti() {
      const overlay = document.getElementById('donation-overlay');
      const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe'];
      
      // Create 50 confetti pieces
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.animationDelay = Math.random() * 3 + 's';
        confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
        
        overlay.appendChild(confetti);
        
        // Remove confetti after animation
        setTimeout(() => {
          if (confetti.parentNode) {
            confetti.parentNode.removeChild(confetti);
          }
        }, 5000);
      }
    }
    
    function showDonationNotification(type, amount, message, from) {
      const notification = document.createElement('div');
      notification.className = 'donation-notification';
      
      let displayAmount = '';
      let icon = '';
      
      switch(type) {
        case 'donation':
          displayAmount = `$${amount}`;
          icon = '💰';
          break;
        case 'bits':
          displayAmount = `${amount} Bits`;
          icon = '💎';
          break;
        case 'points':
          displayAmount = `${amount} Points`;
          icon = '⭐';
          break;
      }
      
      notification.innerHTML = `
        <div class="donation-amount">${icon} ${displayAmount}</div>
        <div class="donation-message">"${message}"</div>
        <div class="donation-from">- ${from}</div>
      `;
      
      document.body.appendChild(notification);
      
      // Remove notification after animation
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    function broadcastDonation(donation) {
      // In a real implementation, this would send to a WebSocket server
      // For now, we'll just log it
      console.log('Broadcasting donation:', donation);
      
      // You could integrate with Twitch API here to get real donations
      // or use a service like Streamlabs, StreamElements, etc.
    }
    
    // Function to simulate real donations (for testing)
    function simulateRandomDonation() {
      const types = ['donation', 'bits', 'points'];
      const amounts = {
        donation: [1, 5, 10, 25, 50, 100],
        bits: [50, 100, 250, 500, 1000, 2500],
        points: [100, 500, 1000, 2500, 5000, 10000]
      };
      const messages = [
        'Great stream!',
        'Love the content!',
        'Keep it up!',
        'Amazing gameplay!',
        'Thanks for the entertainment!',
        'You rock!',
        'Best streamer ever!',
        'This is awesome!'
      ];
      const names = [
        'Anonymous',
        'Viewer123',
        'GamerPro',
        'StreamFan',
        'TribesPlayer',
        'CommunityMember',
        'Supporter',
        'Fan'
      ];
      
      const type = types[Math.floor(Math.random() * types.length)];
      const amount = amounts[type][Math.floor(Math.random() * amounts[type].length)];
      const message = messages[Math.floor(Math.random() * messages.length)];
      const from = names[Math.floor(Math.random() * names.length)];
      
      triggerDonation(type, amount, message, from);
    }
    
    // Add global functions for testing
    window.triggerDonation = triggerDonation;
    window.simulateRandomDonation = simulateRandomDonation;
    
    // Twitch API Integration for Real Donations/Bits
    class TwitchDonationIntegration {
      constructor() {
        this.clientId = 'YOUR_TWITCH_CLIENT_ID'; // You'll need to get this from Twitch Developer Console
        this.accessToken = null;
        this.webhookSecret = 'YOUR_WEBHOOK_SECRET'; // For EventSub verification
        this.isConnected = false;
      }
      
      // Initialize Twitch API connection
      async initialize() {
        try {
          // Get access token from existing Twitch OAuth
          if (window.twitchOAuth && window.twitchOAuth.getToken()) {
            this.accessToken = window.twitchOAuth.getToken();
            this.isConnected = true;
            console.log('✅ Twitch API connected for donations');
            this.setupEventListeners();
          } else {
            console.log('⚠️ Twitch OAuth not available - donations will be test only');
          }
        } catch (error) {
          console.error('❌ Failed to initialize Twitch API:', error);
        }
      }
      
      // Setup EventSub webhooks for real-time events
      async setupEventListeners() {
        // This would typically be done on your server, but for demo purposes:
        console.log('Setting up Twitch EventSub listeners...');
        
        // You would need to:
        // 1. Create EventSub subscriptions for:
        //    - channel.bits (when someone sends bits)
        //    - channel.subscribe (when someone subscribes)
        //    - channel.channel_points_custom_reward_redemption.add (channel points)
        // 2. Set up a webhook endpoint to receive events
        // 3. Verify webhook signatures
        // 4. Process events and trigger confetti
        
        // For now, we'll simulate this with polling
        this.startPolling();
      }
      
      // Poll for recent events (simplified approach)
      async startPolling() {
        setInterval(async () => {
          if (this.isConnected) {
            await this.checkForNewEvents();
          }
        }, 10000); // Check every 10 seconds
      }
      
      // Check for new Twitch events
      async checkForNewEvents() {
        try {
          // This is a simplified version - in reality you'd use EventSub webhooks
          // For now, we'll just log that we're checking
          console.log('Checking for new Twitch events...');
          
          // You could also check recent chat messages for donation commands
          // or use other Twitch API endpoints
        } catch (error) {
          console.error('Error checking for events:', error);
        }
      }
      
      // Handle incoming bits event
      handleBitsEvent(event) {
        const { user_name, bits_used, message } = event;
        triggerDonation('bits', bits_used, message || 'Thanks for the bits!', user_name);
      }
      
      // Handle incoming subscription event
      handleSubscriptionEvent(event) {
        const { user_name, tier } = event;
        const amount = tier === '1000' ? 5 : tier === '2000' ? 10 : 25; // Convert tier to dollar equivalent
        triggerDonation('subscription', amount, 'Thanks for subscribing!', user_name);
      }
      
      // Handle channel points redemption
      handleChannelPointsEvent(event) {
        const { user_name, reward_title, cost } = event;
        triggerDonation('points', cost, `Redeemed: ${reward_title}`, user_name);
      }
    }
    
    // Initialize Twitch donation integration
    const twitchDonations = new TwitchDonationIntegration();
    window.twitchDonations = twitchDonations;
    
    // Local server connection for real-time donations
    let donationServerConnection = null;
    
    function connectToDonationServer() {
      // Try to connect to local donation server
      const serverUrl = 'http://localhost:3000/events';
      
      try {
        donationServerConnection = new EventSource(serverUrl);
        
        donationServerConnection.onopen = function(event) {
          console.log('✅ Connected to donation server');
        };
        
        donationServerConnection.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            
            if (data.type === 'donation') {
              const donation = data.data;
              console.log('🎉 Received donation from server:', donation);
              
              // Trigger donation effect
              triggerDonationWithTarget(
                donation.type,
                donation.amount,
                donation.message,
                donation.from,
                donation.target
              );
            } else if (data.type === 'connected') {
              console.log('📡 Connected to donation server:', data.message);
            }
          } catch (error) {
            console.error('Error parsing donation data:', error);
          }
        };
        
        donationServerConnection.onerror = function(event) {
          console.log('⚠️ Donation server connection error - server may not be running');
          // Try to reconnect after 5 seconds
          setTimeout(() => {
            if (donationServerConnection.readyState === EventSource.CLOSED) {
              connectToDonationServer();
            }
          }, 5000);
        };
        
      } catch (error) {
        console.log('⚠️ Could not connect to donation server:', error.message);
        console.log('💡 Make sure the donation server is running (double-click desktop shortcut)');
      }
    }
    
    // Test function to send donation to server
    function testServerConnection() {
      fetch('http://localhost:3000/test-donation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: 'donation',
          amount: 10,
          message: 'Test from website!',
          from: 'WebsiteTest'
        })
      })
      .then(response => response.json())
      .then(data => {
        console.log('✅ Server test successful:', data);
      })
      .catch(error => {
        console.log('❌ Server test failed:', error);
        console.log('💡 Make sure the donation server is running');
      });
    }
    
    // Start integration when page loads
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        twitchDonations.initialize();
        connectToDonationServer();
      }, 2000); // Wait for other systems to initialize
    });
    
    // Add global functions
    window.testServerConnection = testServerConnection;
    window.connectToDonationServer = connectToDonationServer;
    
    // Function to manually trigger donation for specific player/team
    function donateToPlayer(playerName, amount, message, from) {
      triggerDonation('player', amount, message, from, playerName);
    }
    
    // Function to donate to caster
    function donateToCaster(amount, message, from) {
      triggerDonation('caster', amount, message, from);
    }
    
    // Enhanced donation function with targets
    function triggerDonationWithTarget(type, amount, message, from, target = null) {
      const donation = {
        type,
        amount,
        message,
        from,
        target, // 'player_name' or 'caster' or null for general
        timestamp: Date.now()
      };
      
      // Create confetti effect
      createConfetti();
      
      // Show enhanced notification
      showEnhancedDonationNotification(donation);
      
      // Store donation
      let donations = JSON.parse(localStorage.getItem('donations') || '[]');
      donations.push(donation);
      localStorage.setItem('donations', JSON.stringify(donations));
      
      // Broadcast donation
      broadcastDonation(donation);
    }
    
    // Enhanced notification with target
    function showEnhancedDonationNotification(donation) {
      const notification = document.createElement('div');
      notification.className = 'donation-notification';
      
      let displayAmount = '';
      let icon = '';
      let targetText = '';
      
      switch(donation.type) {
        case 'donation':
        case 'player':
        case 'caster':
          displayAmount = `$${donation.amount}`;
          icon = '💰';
          break;
        case 'bits':
          displayAmount = `${donation.amount} Bits`;
          icon = '💎';
          break;
        case 'points':
          displayAmount = `${donation.amount} Points`;
          icon = '⭐';
          break;
        case 'subscription':
          displayAmount = `$${donation.amount}`;
          icon = '🎉';
          break;
      }
      
      if (donation.target) {
        if (donation.target === 'caster') {
          targetText = '<div style="font-size: 0.9rem; opacity: 0.8;">🎙️ To Caster</div>';
        } else {
          targetText = `<div style="font-size: 0.9rem; opacity: 0.8;">👤 To ${donation.target}</div>`;
        }
      }
      
      notification.innerHTML = `
        <div class="donation-amount">${icon} ${displayAmount}</div>
        ${targetText}
        <div class="donation-message">"${donation.message}"</div>
        <div class="donation-from">- ${donation.from}</div>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    // Add new global functions
    window.donateToPlayer = donateToPlayer;
    window.donateToCaster = donateToCaster;
    window.triggerDonationWithTarget = triggerDonationWithTarget;

    // Function to get app access token for server-to-server requests
    async function getAppAccessToken() {
      try {
        const response = await fetch('https://id.twitch.tv/oauth2/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            'client_id': 'meabi1n42pccff5rz9ujpno7ky9vlt',
            'client_secret': 'YOUR_CLIENT_SECRET', // This would need to be added securely
            'grant_type': 'client_credentials'
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data.access_token;
      } catch (error) {
        console.error('Error getting app access token:', error);
        return null;
      }
    }

    // Initialize everything when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, initializing...');
      
      // Load initial data
      loadTeamRosters();
      loadCurrentPoll();
      setInterval(loadCurrentPollForMainPage, 5000); // Update every 5 seconds
      
      // Load Firebase Twitch handles
      loadFirebaseTwitchHandles();
      
      initializeTwitchPlayer();
      initializePlayerStats();
      initializeTeamStats();
      loadRecentMatches();
      initializeTwitchChat();
      initializeViewerTracking();
      initializeEventStreams();
    });

    // Event Streams Functionality - Show real live streams from community
    let eventStreams = [];

    function initializeEventStreams() {
      const toggleBtn = document.getElementById('event-streams-toggle');
      const sidebar = document.getElementById('event-streams-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      const closeBtn = document.getElementById('close-sidebar');

      // Toggle sidebar
      toggleBtn.addEventListener('click', () => {
        sidebar.classList.toggle('open');
        overlay.classList.toggle('active');
      });

      // Close sidebar
      closeBtn.addEventListener('click', closeSidebar);
      overlay.addEventListener('click', closeSidebar);

      // Close on escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
          closeSidebar();
        }
      });

      // Render event streams
      updateEventStreamsFromLiveData();
      renderEventStreams();
      updateStreamCount();
      
      // Add return to teams button
      addReturnToTeamsButton();
    }

    function closeSidebar() {
      const sidebar = document.getElementById('event-streams-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
    }

    // Update event streams from real live stream data
    function updateEventStreamsFromLiveData() {
      eventStreams = [];
      
      // Get live streamers from the existing viewer data
      if (typeof viewerData !== 'undefined' && viewerData.size > 0) {
        viewerData.forEach((data) => {
          // Only show streams that are actually live with a minimum viewer count
          if (data.isLive && data.viewers > 0) {
            eventStreams.push({
              id: data.handle,
              title: `${data.name} (${data.team})`,
              description: `Live stream from ${data.name}`,
              streamUrl: `https://player.twitch.tv/?channel=${data.handle}&autoplay=false`,
              chatUrl: `https://www.twitch.tv/embed/${data.handle}/chat`,
              category: data.team || 'Community',
              isLive: true,
              viewers: data.viewers,
              startTime: new Date().toISOString(),
              handle: data.handle
            });
          }
        });
      }
      
      // Sort by viewer count (highest first)
      eventStreams.sort((a, b) => b.viewers - a.viewers);
    }

    function renderEventStreams() {
      const container = document.getElementById('event-streams-list');
      
      // Clear any existing content first
      container.innerHTML = '';
      
      if (eventStreams.length === 0) {
        container.innerHTML = '<div class="no-events">No event streams available</div>';
        return;
      }

      container.innerHTML = eventStreams.map(stream => `
        <div class="event-stream-preview ${stream.isLive ? 'live' : ''}" data-stream-id="${stream.id}">
          <div class="stream-preview-header">
            <div class="stream-preview-title">${stream.title}</div>
            <div class="stream-preview-category">${stream.category}</div>
          </div>
          <div style="position: relative;">
            <div class="stream-preview-loading" id="loading-${stream.handle}">
              <div class="loading-spinner"></div>
              <div class="loading-text">Loading stream...</div>
              <div class="loading-fallback" style="margin-top: 8px; font-size: 10px; color: #666;">
                If stream doesn't load, click the play button
              </div>
            </div>
            <iframe 
              class="stream-preview-iframe" 
              id="preview-${stream.handle}"
              src="https://player.twitch.tv/?channel=${stream.handle}&parent=tribesprofessionalleague.com&autoplay=true&muted=true&controls=false&playsinline=true"
              allowfullscreen
              onload="setTimeout(() => { const loading = document.getElementById('loading-${stream.handle}'); if(loading) loading.style.display='none'; }, 2000)"
              onerror="document.getElementById('loading-${stream.handle}').innerHTML='<div class=\\"error-text\\">Stream unavailable</div>'">
            </iframe>
            <div class="stream-preview-overlay">
              <button class="stream-preview-play-btn" data-stream-id="${stream.id}">
                ▶
              </button>
            </div>
          </div>
          <div class="stream-preview-info">
            <div class="stream-preview-viewers">
              👥 ${stream.viewers} viewers
            </div>
            <div class="stream-preview-status">
              ${stream.isLive ? '<span class="live-indicator"></span><span class="status-live">LIVE</span>' : '<span class="status-offline">Offline</span>'}
            </div>
          </div>
        </div>
      `).join('');

      // Add event listeners to the stream previews
      container.querySelectorAll('.event-stream-preview').forEach(preview => {
        preview.addEventListener('click', (e) => {
          const streamId = preview.dataset.streamId;
          switchToEventStream(streamId);
        });
      });

      // Add event listeners to the play buttons
      container.querySelectorAll('.stream-preview-play-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const streamId = btn.dataset.streamId;
          switchToEventStream(streamId);
        });
      });
    }

    function updateStreamCount() {
      const count = eventStreams.filter(stream => stream.isLive).length;
      document.getElementById('event-stream-count').textContent = count;
    }

    // Make switchToEventStream globally accessible
    window.switchToEventStream = function(streamId) {
      const stream = eventStreams.find(s => s.id === streamId);
      if (!stream) return;

      // Update main stream frame with full stream (not muted, with controls)
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        // Determine parent domain for Twitch embed (same logic as existing code)
        let parentDomain = window.location.hostname;
        if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
          parentDomain = 'tribesprofessionalleague.com';
        }
        
        // Build the stream URL with proper parent domain
        const streamUrl = `https://player.twitch.tv/?channel=${stream.handle}&parent=${parentDomain}&autoplay=false`;
        streamFrame.src = streamUrl;
      }

      // Update chat if available
      const chatFrame = document.querySelector('.twitch-chat-container iframe');
      if (chatFrame && stream.chatUrl) {
        // Also fix chat URL with proper parent domain
        let parentDomain = window.location.hostname;
        if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
          parentDomain = 'tribesprofessionalleague.com';
        }
        const chatUrl = `https://www.twitch.tv/embed/${stream.handle}/chat?parent=${parentDomain}`;
        chatFrame.src = chatUrl;
      }

      // Update the spectating section title to show we're watching an event
      const spectatingLabel = document.querySelector('.spectating-label');
      if (spectatingLabel) {
        spectatingLabel.textContent = `WATCHING: ${stream.category.toUpperCase()}`;
        spectatingLabel.style.background = 'var(--accent)';
      }

      // Close sidebar
      closeSidebar();

      // Show notification
      showNotification(`Now watching: ${stream.title}`);
    };

    function showNotification(message) {
      // Create a simple notification
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: var(--accent);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 0.5rem;
        z-index: 1000;
        font-weight: 600;
        box-shadow: var(--shadow-xl);
        animation: slideIn 0.3s ease;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // Add notification animations
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // Function to return to team streams
    window.returnToTeamStreams = function() {
      // Reset to default team stream
      const streamFrame = document.getElementById('stream-frame');
      if (streamFrame) {
        // Use the same parent domain logic as existing code
        let parentDomain = window.location.hostname;
        if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
          parentDomain = 'tribesprofessionalleague.com';
        }
        streamFrame.src = `https://player.twitch.tv/?channel=oo0oo_live&parent=${parentDomain}&autoplay=false`;
      }

      // Reset chat to default
      const chatFrame = document.querySelector('.twitch-chat-container iframe');
      if (chatFrame) {
        let parentDomain = window.location.hostname;
        if (parentDomain === 'localhost' || parentDomain === '127.0.0.1' || parentDomain.includes('192.168')) {
          parentDomain = 'tribesprofessionalleague.com';
        }
        chatFrame.src = `https://www.twitch.tv/embed/oo0oo_live/chat?parent=${parentDomain}`;
      }

      // Reset spectating label
      const spectatingLabel = document.querySelector('.spectating-label');
      if (spectatingLabel) {
        spectatingLabel.textContent = 'SPECTATING';
        spectatingLabel.style.background = 'var(--danger)';
      }

      showNotification('Returned to team streams');
    };

    // Admin functions for managing event streams (can be called from console for testing)
    window.addEventStream = function(stream) {
      eventStreams.push(stream);
      renderEventStreams();
      updateStreamCount();
    };

    window.removeEventStream = function(streamId) {
      eventStreams = eventStreams.filter(s => s.id !== streamId);
      renderEventStreams();
      updateStreamCount();
    };

    window.updateEventStreamStatus = function(streamId, isLive, viewers = 0) {
      const stream = eventStreams.find(s => s.id === streamId);
      if (stream) {
        stream.isLive = isLive;
        stream.viewers = viewers;
        renderEventStreams();
        updateStreamCount();
      }
    };

    // Add a "Return to Teams" button to the sidebar header
    function addReturnToTeamsButton() {
      const sidebarHeader = document.querySelector('.sidebar-header');
      const returnBtn = document.createElement('button');
      returnBtn.className = 'btn btn-secondary';
      returnBtn.style.cssText = 'padding: 0.25rem 0.5rem; font-size: 0.8rem; margin-right: 0.5rem;';
      returnBtn.textContent = '← Teams';
      returnBtn.onclick = () => {
        returnToTeamStreams();
        closeSidebar();
      };
      
      // Add a refresh button to manually update live streams
      const refreshBtn = document.createElement('button');
      refreshBtn.className = 'btn btn-primary';
      refreshBtn.style.cssText = 'padding: 0.25rem 0.5rem; font-size: 0.8rem; margin-right: 0.5rem;';
      refreshBtn.textContent = '🔄';
      refreshBtn.title = 'Refresh live streams';
      refreshBtn.onclick = async () => {
        showNotification('Refreshing live streams...');
        // Clear cached data and refresh
        if (typeof viewerData !== 'undefined') {
          viewerData.clear();
        }
        if (typeof updateViewerCounts === 'function') {
          await updateViewerCounts();
        }
        updateEventStreamsFromLiveData();
        renderEventStreams();
        updateStreamCount();
        showNotification('Event streams refreshed');
        
        // Force reload all preview iframes after a short delay
        setTimeout(() => {
          document.querySelectorAll('.stream-preview-iframe').forEach(iframe => {
            const currentSrc = iframe.src;
            iframe.src = '';
            setTimeout(() => {
              iframe.src = currentSrc;
            }, 100);
          });
        }, 1000);
      };
      
      // Insert before the close button
      const closeBtn = document.getElementById('close-sidebar');
      sidebarHeader.insertBefore(refreshBtn, closeBtn);
      sidebarHeader.insertBefore(returnBtn, refreshBtn);
    }
  </script>

  <!-- Donation System -->
  <div class="donation-overlay" id="donation-overlay"></div>

  <!-- Donation Buttons -->
  <div class="donation-buttons">
    <!-- PayPal Donation Button -->
    <div class="paypal-donation">
      <style>.pp-BC4EF2QC9T5GA{text-align:center;border:none;border-radius:0.25rem;min-width:11.625rem;padding:0 2rem;height:2.625rem;font-weight:bold;background-color:#ff0f0f;color:#000000;font-family:"Helvetica Neue",Arial,sans-serif;font-size:1rem;line-height:1.25rem;cursor:pointer;}</style>
      <form action="https://www.paypal.com/ncp/payment/BC4EF2QC9T5GA" method="post" target="_blank" style="display:inline-grid;justify-items:center;align-content:start;gap:0.5rem;">
        <input class="pp-BC4EF2QC9T5GA" type="submit" value="Donate Now" />
        <img src=https://www.paypalobjects.com/images/Debit_Credit_APM.svg alt="cards" />
        <section style="font-size: 0.75rem;"> Powered by <img src="https://www.paypalobjects.com/paypal-ui/logos/svg/paypal-wordmark-color.svg" alt="paypal" style="height:0.875rem;vertical-align:middle;"/></section>
      </form>
    </div>
  </div>

  <!-- Event Streams Sidebar -->
  <div class="sidebar-overlay" id="sidebar-overlay"></div>
  <div class="event-streams-sidebar" id="event-streams-sidebar">
    <div class="sidebar-header">
      <h3>Event Streams</h3>
      <button class="close-sidebar" id="close-sidebar">&times;</button>
    </div>
    <div class="sidebar-content">
      <div id="event-streams-list">
        <!-- Event streams will be populated here -->
      </div>
    </div>
  </div>
</body>
</html>
