<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Match Stats Admin</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="oauth.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen">
  <div id="nav-placeholder" data-include="nav.html"></div>

  <div id="loginDiv" class="max-w-sm mx-auto mt-10 space-y-4">
    <h1 class="text-2xl font-bold text-center">Admin Login</h1>
    <input id="email" type="email" placeholder="Email" class="w-full px-3 py-2 rounded bg-gray-800 border border-gray-700" />
    <input id="password" type="password" placeholder="Password" class="w-full px-3 py-2 rounded bg-gray-800 border border-gray-700" />
    <button id="loginBtn" class="w-full py-2 bg-blue-600 hover:bg-blue-700 rounded">Login</button>
  </div>

  <div id="adminPanel" class="hidden container mx-auto px-4 mt-8">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-3xl font-bold">Match Stats Admin</h1>
      <button id="logoutBtn" class="py-2 px-4 bg-red-600 hover:bg-red-700 rounded">Logout</button>
    </div>

    <form id="matchForm" class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
      <div>
        <label class="block text-sm mb-1">Team 1</label>
        <select id="team1" class="w-full px-3 py-2 rounded bg-gray-800 border border-gray-700"></select>
      </div>
      <div>
        <label class="block text-sm mb-1">Team 2</label>
        <select id="team2" class="w-full px-3 py-2 rounded bg-gray-800 border border-gray-700"></select>
      </div>
      <div>
        <label class="block text-sm mb-1">Map</label>
        <select id="map" class="w-full px-3 py-2 rounded bg-gray-800 border border-gray-700"></select>
      </div>
      <div class="flex items-end">
        <button type="button" id="createMatch" class="w-full py-2 bg-green-600 hover:bg-green-700 rounded">Create Match</button>
      </div>
    </form>

    <div id="statsSection" class="hidden">
      <div id="team1Stats"></div>
      <div id="team2Stats" class="mt-8"></div>
      <div class="mt-6">
        <button id="saveMatch" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded">Save Match</button>
      </div>
    </div>

    <div id="matchesList" class="mt-12"></div>

    <div id="runningTotalsSection" class="hidden mt-12">
      <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
        <div>
          <h2 id="runningTotalsTitle" class="text-2xl font-bold">Running Totals</h2>
          <p id="runningTotalsMeta" class="text-sm text-gray-300"></p>
        </div>
        <button id="exportBtn" class="self-start md:self-auto px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded" disabled>Export All Data to Excel</button>
      </div>
      <div id="output" class="mt-6"></div>
    </div>

  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';

    import { getFirestore, collection, getDocs, addDoc, doc, updateDoc, deleteDoc, setDoc, getDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

    const firebaseConfig = {
      apiKey: "AIzaSyB_ksHlcP2P9cT5jbo2IAGxbQ4zgEODkyM",
      authDomain: "team-sign-up-b5646.firebaseapp.com",
      projectId: "team-sign-up-b5646",
      storageBucket: "team-sign-up-b5646.firebasestorage.app",
      messagingSenderId: "951471144681",
      appId: "1:951471144681:web:a2458675ce73ce9ad9ba78"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth();
    const ADMIN_UIDS = [
      'DkBHsCzLK5a9KiX50g0pHJrEqGq2',
      'A2ZV8vziNsXqZkyqHzAB266B9pP2'
    ];

    const loginDiv = document.getElementById('loginDiv');
    const adminPanel = document.getElementById('adminPanel');
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');

    let editingMatchId = null, currentMatchCreated = null;

    function formatMatchMeta(data) {
      const created = data?.created;
      let createdDate = '';
      if (created?.toDate) {
        createdDate = created.toDate();
      } else if (created instanceof Date) {
        createdDate = created;
      } else if (typeof created === 'string' || typeof created === 'number') {
        const parsed = new Date(created);
        if (!Number.isNaN(parsed.getTime())) {
          createdDate = parsed;
        }
      }

      const createdText = createdDate ? createdDate.toLocaleString() : '';
      return {
        team1: data?.team1 ?? '',
        team2: data?.team2 ?? '',
        map: data?.map ?? '',
        createdText
      };
    }
    const toNumber = (value) => {
      const num = parseFloat(value);
      return Number.isFinite(num) ? num : 0;
    };


    loginBtn.addEventListener('click', () => {
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;
      signInWithEmailAndPassword(auth, email, password).catch(err => alert(err.message));
    });

    logoutBtn.addEventListener('click', () => signOut(auth));

    onAuthStateChanged(auth, user => {
      if (user && ADMIN_UIDS.includes(user.uid)) {
        loginDiv.classList.add('hidden');
        adminPanel.classList.remove('hidden');

        loadTeams().then(loadMatches);

      } else {
        loginDiv.classList.remove('hidden');
        adminPanel.classList.add('hidden');
        if (user) {
          alert('Access denied.');
          signOut(auth);
        }
      }
    });

    const mapList = ['Dry Dock','Raindance','Hollow','Dangerous Crossing','Torment','Katabatic','Wave Mist','Moonrise'];
    const mapSelect = document.getElementById('map');
    mapList.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m;
      opt.textContent = m;
      mapSelect.appendChild(opt);
    });

    let teamsData = [];

    async function loadTeams() {
      const snap = await getDocs(collection(db, 'teams'));
      teamsData = snap.docs.map(d => ({ id: d.id, name: d.data().teamName, players: (d.data().players || []).map(p => p.name) }));
      const team1Sel = document.getElementById('team1');
      const team2Sel = document.getElementById('team2');
      team1Sel.innerHTML = '<option value="">Select Team</option>';
      team2Sel.innerHTML = '<option value="">Select Team</option>';
      teamsData.forEach(t => {
        const opt1 = document.createElement('option');
        opt1.value = t.id;
        opt1.textContent = t.name;
        team1Sel.appendChild(opt1);
        const opt2 = document.createElement('option');
        opt2.value = t.id;
        opt2.textContent = t.name;
        team2Sel.appendChild(opt2);
      });
    }

    async function loadMatches() {
      try {
        const snap = await getDocs(collection(db, 'matches'));
        const listDiv = document.getElementById('matchesList');
        listDiv.innerHTML = '<h2 class="text-2xl font-bold mb-4">Saved Matches</h2>';
        if (snap.empty) {
          listDiv.innerHTML += '<p>No matches saved.</p>';
          if (!editingMatchId) {
            resetOutput();
          }
          return;
        }
      const table = document.createElement('table');
      table.className = 'min-w-full text-left border border-gray-700';
      table.innerHTML = `
        <thead>
          <tr>
            <th class="px-2">Date</th>
            <th class="px-2">Map</th>
            <th class="px-2">Teams</th>
            <th class="px-2">Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector('tbody');
      const matches = [];
      console.log('Loading matches, total documents:', snap.size);
      snap.forEach(docSnap => {
        const data = docSnap.data();
        matches.push({ id: docSnap.id, data });
      });

      // Sort matches by date (newest first)
      matches.sort((a, b) => {
        const aCreated = a.data?.created;
        const bCreated = b.data?.created;
        const aTime = aCreated?.toDate ? aCreated.toDate().getTime() : (aCreated instanceof Date ? aCreated.getTime() : new Date(aCreated || 0).getTime());
        const bTime = bCreated?.toDate ? bCreated.toDate().getTime() : (bCreated instanceof Date ? bCreated.getTime() : new Date(bCreated || 0).getTime());
        return bTime - aTime; // Sort newest first
      });

      // Now create table rows in sorted order
      matches.forEach(match => {
        const { id, data } = match;
        let dateStr = '';
        try { 
          dateStr = data.created.toDate().toLocaleString(); 
          console.log('Match found:', data.team1, 'vs', data.team2, 'on', dateStr);
        } catch(e) { 
          console.error('Error parsing date for match:', data, e);
          dateStr = ''; 
        }
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="px-2">${dateStr}</td>
          <td class="px-2">${data.map}</td>
          <td class="px-2">${data.team1} vs ${data.team2}</td>
          <td class="px-2 space-x-2">
            <button class="edit-btn bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded" data-id="${id}">Edit</button>
            <button class="delete-btn bg-red-600 hover:bg-red-700 px-2 py-1 rounded" data-id="${id}">Delete</button>
          </td>
        `;
        tbody.appendChild(tr);
        tr.querySelector('.edit-btn').addEventListener('click', () => loadMatchForEdit(id, data));
        tr.querySelector('.delete-btn').addEventListener('click', () => deleteMatch(id));
      });
      listDiv.appendChild(table);

      if (!editingMatchId && matches.length) {
        const latest = matches.reduce((latestMatch, current) => {
          const latestCreated = latestMatch?.data?.created;
          const currentCreated = current.data?.created;
          const latestTime = latestCreated?.toDate ? latestCreated.toDate().getTime() : (latestCreated instanceof Date ? latestCreated.getTime() : new Date(latestCreated || 0).getTime());
          const currentTime = currentCreated?.toDate ? currentCreated.toDate().getTime() : (currentCreated instanceof Date ? currentCreated.getTime() : new Date(currentCreated || 0).getTime());
          return currentTime > latestTime ? current : latestMatch;
        }, null) || matches[0];
        const matchMeta = formatMatchMeta(latest.data);
        renderRunningTotals(latest.data.stats || {}, matchMeta);
      }
      } catch (error) {
        console.error('Error loading matches:', error);
        const listDiv = document.getElementById('matchesList');
        listDiv.innerHTML = '<h2 class="text-2xl font-bold mb-4">Saved Matches</h2><p class="text-red-500">Error loading matches. Please refresh the page.</p>';
      }
    }

    async function deleteMatch(id) {
      if (!confirm('Delete this match?')) return;
      await deleteDoc(doc(db, 'matches', id));
      if (editingMatchId === id) {
        editingMatchId = null;
        currentMatchCreated = null;
        const statsSection = document.getElementById('statsSection');
        statsSection.classList.add('hidden');
        document.getElementById('saveMatch').textContent = 'Save Match';
        resetOutput();
      }
      loadMatches();
    }

    function loadMatchForEdit(id, data) {
      editingMatchId = id;
      currentMatchCreated = data.created;
      document.getElementById('saveMatch').textContent = 'Update Match';
      const team1 = teamsData.find(t => t.name === data.team1);
      const team2 = teamsData.find(t => t.name === data.team2);
      document.getElementById('team1').value = team1 ? team1.id : '';
      document.getElementById('team2').value = team2 ? team2.id : '';
      document.getElementById('map').value = data.map;
      const team1Stats = data.stats?.[data.team1] || null;
      const team2Stats = data.stats?.[data.team2] || null;
      const team1ForTable = team1 || { name: data.team1, players: Object.keys(team1Stats?.players || {}) };
      const team2ForTable = team2 || { name: data.team2, players: Object.keys(team2Stats?.players || {}) };
      createStatsTable('team1Stats', team1ForTable, team1Stats);
      createStatsTable('team2Stats', team2ForTable, team2Stats);
      document.getElementById('statsSection').classList.remove('hidden');
      const inputs = document.querySelectorAll('.stat-input');
      inputs.forEach(inp => {
        const player = inp.dataset.player;
        const team = inp.dataset.team;
        const stat = inp.dataset.stat;
        const teamData = data.stats?.[team];
        if (teamData && teamData.players[player]) {
          inp.value = teamData.players[player][stat] || 0;
        }
      });
      renderRunningTotals(data.stats || {}, formatMatchMeta(data));
    }

    document.getElementById('createMatch').addEventListener('click', () => {
      const t1 = teamsData.find(t => t.id === document.getElementById('team1').value);
      const t2 = teamsData.find(t => t.id === document.getElementById('team2').value);
      if (!t1 || !t2 || t1.id === t2.id) {
        alert('Please select two different teams.');
        return;
      }
      editingMatchId = null;
      currentMatchCreated = null;
      document.getElementById('saveMatch').textContent = 'Save Match';

      createStatsTable('team1Stats', t1);
      createStatsTable('team2Stats', t2);
      document.getElementById('statsSection').classList.remove('hidden');
      resetOutput();
    });

    function createStatsTable(containerId, team, existingStats = null) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      const wrapper = document.createElement('div');
      wrapper.className = 'space-y-2';

      const table = document.createElement('table');
      table.className = 'min-w-full text-left border border-gray-700';
      table.innerHTML = `
        <caption class="text-xl font-semibold mb-2">${team.name}</caption>
        <thead>
          <tr>
            <th class="px-2">Player</th>
            <th class="px-2">Score</th>
            <th class="px-2">Kills</th>
            <th class="px-2">Assists</th>
            <th class="px-2">Captures</th>
            <th class="px-2">Returns</th>
            <th class="px-2">Time (min)</th>
            <th class="px-2">Remove</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector('tbody');

      const rosterPlayers = team.players || [];
      const existingPlayers = existingStats?.players ? Object.keys(existingStats.players) : [];
      const playerSet = new Set([...rosterPlayers, ...existingPlayers]);

      const addPlayerRow = (playerName, statValues = {}, isRosterPlayer = false) => {
        const tr = document.createElement('tr');
        tr.dataset.playerName = playerName;

        const nameTd = document.createElement('td');
        nameTd.className = 'px-2';
        nameTd.textContent = playerName;
        tr.appendChild(nameTd);

        ['score', 'kills', 'assists', 'captures', 'returns', 'time'].forEach(stat => {
          const td = document.createElement('td');
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'stat-input w-20 px-1 bg-gray-800 border border-gray-700';
          input.dataset.player = playerName;
          input.dataset.team = team.name;
          input.dataset.stat = stat;
          input.value = statValues[stat] ?? 0;
          td.appendChild(input);
          tr.appendChild(td);
        });

        const removeTd = document.createElement('td');
        removeTd.className = 'px-2';
        if (!isRosterPlayer) {
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'px-2 py-1 bg-red-600 hover:bg-red-700 rounded';
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', () => {
            tbody.removeChild(tr);
            playerSet.delete(playerName);
          });
          removeTd.appendChild(removeBtn);
        }
        tr.appendChild(removeTd);

        tbody.appendChild(tr);
      };

      playerSet.forEach(p => {
        addPlayerRow(p, existingStats?.players?.[p] || {}, rosterPlayers.includes(p));
      });

      wrapper.appendChild(table);

      const addSubBtn = document.createElement('button');
      addSubBtn.type = 'button';
      addSubBtn.className = 'mt-2 px-3 py-1 bg-purple-600 hover:bg-purple-700 rounded';
      addSubBtn.textContent = 'Add Sub Player';
      addSubBtn.addEventListener('click', () => {
        const name = prompt('Enter sub player name:');
        if (!name) return;
        const trimmed = name.trim();
        if (!trimmed) return;
        if (playerSet.has(trimmed)) {
          alert('Player already exists in this team list.');
          return;
        }
        playerSet.add(trimmed);
        addPlayerRow(trimmed, {}, false);
      });

      wrapper.appendChild(addSubBtn);
      container.appendChild(wrapper);
    }


    async function rebuildPublicStats(existingSnapshot = null) {
      const snap = existingSnapshot || await getDocs(collection(db, 'matches'));
      const playerTotals = new Map();
      const playerMapStats = new Map();
      const teamTotals = new Map();
      let totalMatches = 0;

      snap.forEach(docSnap => {
        const data = docSnap.data();
        const stats = data.stats || {};
        const teams = Object.keys(stats);
        if (!teams.length) return;
        totalMatches += 1;
        const mapName = data.map || 'Unknown';

        teams.forEach(teamName => {
          const teamStats = stats[teamName];
          if (!teamStats) return;

          const totals = teamStats.totals || {};
          const teamEntry = teamTotals.get(teamName) || {
            name: teamName,
            matches: 0,
            time: 0,
            kills: 0,
            assists: 0,
            score: 0,
            captures: 0,
            returns: 0
          };
          teamEntry.matches += 1;
          teamEntry.time += toNumber(totals.time);
          teamEntry.kills += toNumber(totals.kills);
          teamEntry.assists += toNumber(totals.assists);
          teamEntry.score += toNumber(totals.score);
          teamEntry.captures += toNumber(totals.captures);
          teamEntry.returns += toNumber(totals.returns);
          teamTotals.set(teamName, teamEntry);

          const players = teamStats.players || {};
          Object.entries(players).forEach(([playerName, rawStats]) => {
            const kills = toNumber(rawStats.kills);
            const assists = toNumber(rawStats.assists);
            const score = toNumber(rawStats.score);
            const captures = toNumber(rawStats.captures);
            const returns = toNumber(rawStats.returns);
            const time = toNumber(rawStats.time);

            const totalEntry = playerTotals.get(playerName) || {
              name: playerName,
              teams: new Set(),
              matches: 0,
              time: 0,
              kills: 0,
              assists: 0,
              score: 0,
              captures: 0,
              returns: 0
            };
            totalEntry.teams.add(teamName);
            totalEntry.matches += 1;
            totalEntry.time += time;
            totalEntry.kills += kills;
            totalEntry.assists += assists;
            totalEntry.score += score;
            totalEntry.captures += captures;
            totalEntry.returns += returns;
            playerTotals.set(playerName, totalEntry);

            const mapKey = `${playerName}__${mapName}`;
            const mapEntry = playerMapStats.get(mapKey) || {
              player: playerName,
              teams: new Set(),
              map: mapName,
              matches: 0,
              time: 0,
              kills: 0,
              assists: 0,
              score: 0,
              captures: 0,
              returns: 0
            };
            mapEntry.teams.add(teamName);
            mapEntry.matches += 1;
            mapEntry.time += time;
            mapEntry.kills += kills;
            mapEntry.assists += assists;
            mapEntry.score += score;
            mapEntry.captures += captures;
            mapEntry.returns += returns;
            playerMapStats.set(mapKey, mapEntry);
          });
        });
      });

      const serializePlayerTotals = Array.from(playerTotals.values()).map(entry => ({
        name: entry.name,
        teams: Array.from(entry.teams),
        matches: entry.matches,
        time: Number(entry.time.toFixed(4)),
        kills: entry.kills,
        assists: entry.assists,
        score: entry.score,
        captures: entry.captures,
        returns: entry.returns
      }));

      const serializePlayerMapStats = Array.from(playerMapStats.values()).map(entry => ({
        player: entry.player,
        teams: Array.from(entry.teams),
        map: entry.map,
        matches: entry.matches,
        time: Number(entry.time.toFixed(4)),
        kills: entry.kills,
        assists: entry.assists,
        score: entry.score,
        captures: entry.captures,
        returns: entry.returns
      }));

      const serializeTeamTotals = Array.from(teamTotals.values()).map(entry => ({
        name: entry.name,
        matches: entry.matches,
        time: Number(entry.time.toFixed(4)),
        kills: entry.kills,
        assists: entry.assists,
        score: entry.score,
        captures: entry.captures,
        returns: entry.returns
      }));

      const payload = {
        generatedAt: serverTimestamp(),
        totalMatches,
        playerTotals: serializePlayerTotals,
        playerMapStats: serializePlayerMapStats,
        teamTotals: serializeTeamTotals
      };

      await setDoc(doc(db, 'publicStats', 'aggregates'), payload);
    }

    async function ensurePublicStatsSnapshot(existingSnapshot) {
      try {
        const statsDoc = await getDoc(doc(db, 'publicStats', 'aggregates'));
        if (!statsDoc.exists()) {
          await rebuildPublicStats(existingSnapshot);
        }
      } catch (err) {
        console.error('Failed to ensure public stats snapshot', err);
      }
    }



    function resetOutput() {
      document.getElementById('output').innerHTML = '';
      document.getElementById('exportBtn').disabled = true;
      document.getElementById('runningTotalsTitle').textContent = 'Running Totals';
      document.getElementById('runningTotalsMeta').textContent = '';
      document.getElementById('runningTotalsSection').classList.add('hidden');
    }

    function buildSaveData(map, t1, t2) {
      const inputs = Array.from(document.querySelectorAll('.stat-input'));
      const stats = {};
      inputs.forEach(inp => {
        const player = inp.dataset.player;
        const team = inp.dataset.team;
        const stat = inp.dataset.stat;
        const val = toNumber(inp.value);
        if (!stats[team]) stats[team] = {};
        if (!stats[team][player]) stats[team][player] = { kills:0, assists:0, score:0, captures:0, returns:0, time:0 };
        stats[team][player][stat] = val;
      });

      const payload = { map, team1: t1.name, team2: t2.name, created: currentMatchCreated || new Date(), stats: {} };

      [t1.name, t2.name].forEach(teamName => {
        const teamStats = stats[teamName] || {};
        const totals = { kills:0, assists:0, score:0, captures:0, returns:0, time:0 };
        const playersPayload = {};
        Object.keys(teamStats).forEach(player => {
          const s = teamStats[player];
          totals.kills += s.kills;
          totals.assists += s.assists;
          totals.score += s.score;
          totals.captures += s.captures;
          totals.returns += s.returns;
          totals.time += s.time;
          const kpm = s.time ? (s.kills / s.time).toFixed(2) : '0';
          const apm = s.time ? (s.assists / s.time).toFixed(2) : '0';
          const spm = s.time ? (s.score / s.time).toFixed(2) : '0';
          const cpm = s.time ? (s.captures / s.time).toFixed(2) : '0';
          const rpm = s.time ? (s.returns / s.time).toFixed(2) : '0';
          playersPayload[player] = { ...s, kpm, apm, spm, cpm, rpm };
        });
        const teamKpm = totals.time ? (totals.kills / totals.time).toFixed(2) : '0';
        const teamApm = totals.time ? (totals.assists / totals.time).toFixed(2) : '0';
        const teamSpm = totals.time ? (totals.score / totals.time).toFixed(2) : '0';
        const teamCpm = totals.time ? (totals.captures / totals.time).toFixed(2) : '0';
        const teamRpm = totals.time ? (totals.returns / totals.time).toFixed(2) : '0';
        payload.stats[teamName] = {
          players: playersPayload,
          totals: { ...totals, kpm: teamKpm, apm: teamApm, spm: teamSpm, cpm: teamCpm, rpm: teamRpm }
        };
      });

      return payload;
    }

    function renderRunningTotals(statsByTeam = {}, matchMeta = null) {

      const output = document.getElementById('output');
      const exportBtn = document.getElementById('exportBtn');
      const totalsSection = document.getElementById('runningTotalsSection');
      const title = document.getElementById('runningTotalsTitle');
      const meta = document.getElementById('runningTotalsMeta');

      output.innerHTML = '';
      const teamNames = Object.keys(statsByTeam);
      if (!teamNames.length) {
        exportBtn.disabled = true;
        totalsSection.classList.add('hidden');
        title.textContent = 'Running Totals';
        meta.textContent = '';
        return;
      }

      if (matchMeta) {
        const { team1, team2, map, createdText } = matchMeta;
        title.textContent = `${team1 || 'Team 1'} vs ${team2 || 'Team 2'}`;
        const parts = [];
        if (map) parts.push(`Map: ${map}`);
        if (createdText) parts.push(`Created: ${createdText}`);
        meta.textContent = parts.join(' â€¢ ');
      } else {
        title.textContent = 'Running Totals';
        meta.textContent = '';
      }

      totalsSection.classList.remove('hidden');
      exportBtn.disabled = false;

      const exportTable = document.createElement('table');
      exportTable.id = 'exportTable';
      exportTable.className = 'min-w-full text-left border border-gray-700';
      exportTable.innerHTML = `
        <thead>
          <tr>
            <th class="px-2">Team</th>
            <th class="px-2">Player</th>
            <th class="px-2">Score</th>
            <th class="px-2">Kills</th>
            <th class="px-2">Assists</th>
            <th class="px-2">Captures</th>
            <th class="px-2">Returns</th>
            <th class="px-2">Time</th>
            <th class="px-2">KPM</th>
            <th class="px-2">APM</th>
            <th class="px-2">SPM</th>
            <th class="px-2">CPM</th>
            <th class="px-2">RPM</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = exportTable.querySelector('tbody');

      teamNames.forEach(teamName => {
        const teamStats = statsByTeam[teamName] || {};
        const players = teamStats.players || {};
        const totals = { kills:0, assists:0, score:0, captures:0, returns:0, time:0 };

        Object.keys(players).forEach(player => {
          const statEntry = players[player] || {};
          const kills = toNumber(statEntry.kills);
          const assists = toNumber(statEntry.assists);
          const score = toNumber(statEntry.score);
          const captures = toNumber(statEntry.captures);
          const returns = toNumber(statEntry.returns);
          const time = toNumber(statEntry.time);
          totals.kills += kills;
          totals.assists += assists;
          totals.score += score;
          totals.captures += captures;
          totals.returns += returns;
          totals.time += time;

          const kpm = time ? (kills / time).toFixed(2) : (statEntry.kpm ?? '0');
          const apm = time ? (assists / time).toFixed(2) : (statEntry.apm ?? '0');
          const spm = time ? (score / time).toFixed(2) : (statEntry.spm ?? '0');
          const cpm = time ? (captures / time).toFixed(2) : (statEntry.cpm ?? '0');
          const rpm = time ? (returns / time).toFixed(2) : (statEntry.rpm ?? '0');


          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td class="px-2">${teamName}</td>
            <td class="px-2">${player}</td>
            <td class="px-2">${score}</td>
            <td class="px-2">${kills}</td>
            <td class="px-2">${assists}</td>

            <td class="px-2">${captures}</td>
            <td class="px-2">${returns}</td>
            <td class="px-2">${time}</td>
            <td class="px-2">${kpm}</td>
            <td class="px-2">${apm}</td>
            <td class="px-2">${spm}</td>
            <td class="px-2">${cpm}</td>
            <td class="px-2">${rpm}</td>
          `;
          tbody.appendChild(tr);
        });

        const totalsData = teamStats.totals || {};
        const totalKills = totalsData.kills ?? totals.kills;
        const totalAssists = totalsData.assists ?? totals.assists;
        const totalScore = totalsData.score ?? totals.score;
        const totalCaptures = totalsData.captures ?? totals.captures;
        const totalReturns = totalsData.returns ?? totals.returns;
        const totalTime = totalsData.time ?? totals.time;
        const teamKpm = totalTime ? (totalKills / totalTime).toFixed(2) : (totalsData.kpm ?? '0');
        const teamApm = totalTime ? (totalAssists / totalTime).toFixed(2) : (totalsData.apm ?? '0');
        const teamSpm = totalTime ? (totalScore / totalTime).toFixed(2) : (totalsData.spm ?? '0');
        const teamCpm = totalTime ? (totalCaptures / totalTime).toFixed(2) : (totalsData.cpm ?? '0');
        const teamRpm = totalTime ? (totalReturns / totalTime).toFixed(2) : (totalsData.rpm ?? '0');

        const trTot = document.createElement('tr');
        trTot.className = 'font-semibold';
        trTot.innerHTML = `
          <td class="px-2">${teamName}</td>
          <td class="px-2">Totals</td>

          <td class="px-2">${totalScore}</td>
          <td class="px-2">${totalKills}</td>
          <td class="px-2">${totalAssists}</td>

          <td class="px-2">${totalCaptures}</td>
          <td class="px-2">${totalReturns}</td>
          <td class="px-2">${totalTime}</td>
          <td class="px-2">${teamKpm}</td>
          <td class="px-2">${teamApm}</td>
          <td class="px-2">${teamSpm}</td>
          <td class="px-2">${teamCpm}</td>
          <td class="px-2">${teamRpm}</td>
        `;
        tbody.appendChild(trTot);
      });

      output.appendChild(exportTable);
      document.getElementById('exportBtn').disabled = false;
    }

    document.getElementById('saveMatch').addEventListener('click', async () => {
      const map = document.getElementById('map').value;
      const t1 = teamsData.find(t => t.id === document.getElementById('team1').value);
      const t2 = teamsData.find(t => t.id === document.getElementById('team2').value);

      if (!t1 || !t2 || t1.id === t2.id) {
        alert('Please select two different teams before saving.');
        return;
      }

      const saveData = buildSaveData(map, t1, t2);
      renderRunningTotals(saveData.stats, formatMatchMeta(saveData));

      let actionMessage = 'Match saved!';
      try {
        if (editingMatchId) {
          await updateDoc(doc(db, 'matches', editingMatchId), saveData);
          actionMessage = 'Match updated!';
        } else {
          await addDoc(collection(db, 'matches'), saveData);
        }
      } catch (err) {
        console.error('Failed to save match', err);
        alert('Failed to save match. Please try again.');
        return;
      }

      let rebuildError = null;
      try {
        await rebuildPublicStats();
      } catch (err) {
        rebuildError = err;
        console.error('Failed to rebuild public stats', err);
      }

      editingMatchId = null;
      currentMatchCreated = null;
      document.getElementById('saveMatch').textContent = 'Save Match';
      
      // Add a small delay to ensure Firestore consistency
      setTimeout(() => {
        loadMatches();
      }, 500);

      if (rebuildError) {
        alert(`${actionMessage} However, updating the public stats snapshot failed. Please try saving again to refresh the stats.`);
      } else {
        alert(`${actionMessage} Public stats have been refreshed.`);
      }
    });

    // Comprehensive Excel Export Functions
    function createAllMatchesSheet(wb, allMatches) {
      const data = [
        ['Date', 'Map', 'Team 1', 'Team 2', 'Team 1 Kills', 'Team 2 Kills', 'Team 1 Score', 'Team 2 Score', 'Team 1 Time', 'Team 2 Time']
      ];

      allMatches.forEach(match => {
        const date = match.created?.toDate ? match.created.toDate().toLocaleDateString() : 'Unknown';
        const team1Stats = match.stats?.[match.team1]?.totals || {};
        const team2Stats = match.stats?.[match.team2]?.totals || {};
        
        data.push([
          date,
          match.map || 'Unknown',
          match.team1 || 'Unknown',
          match.team2 || 'Unknown',
          team1Stats.kills || 0,
          team2Stats.kills || 0,
          team1Stats.score || 0,
          team2Stats.score || 0,
          team1Stats.time || 0,
          team2Stats.time || 0
        ]);
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, 'All Matches');
    }

    function createPlayerStatsSheet(wb, allMatches) {
      const playerStats = new Map();

      // Aggregate all player data
      allMatches.forEach(match => {
        const stats = match.stats || {};
        Object.entries(stats).forEach(([teamName, teamStats]) => {
          const players = teamStats.players || {};
          Object.entries(players).forEach(([playerName, playerData]) => {
            if (!playerStats.has(playerName)) {
              playerStats.set(playerName, {
                name: playerName,
                teams: new Set(),
                matches: 0,
                totalKills: 0,
                totalAssists: 0,
                totalScore: 0,
                totalCaptures: 0,
                totalReturns: 0,
                totalTime: 0
              });
            }
            
            const player = playerStats.get(playerName);
            player.teams.add(teamName);
            player.matches += 1;
            player.totalKills += toNumber(playerData.kills);
            player.totalAssists += toNumber(playerData.assists);
            player.totalScore += toNumber(playerData.score);
            player.totalCaptures += toNumber(playerData.captures);
            player.totalReturns += toNumber(playerData.returns);
            player.totalTime += toNumber(playerData.time);
          });
        });
      });

      const data = [
        ['Player Name', 'Teams', 'Matches', 'Total Kills', 'Total Assists', 'Total Score', 'Total Captures', 'Total Returns', 'Total Time (min)', 'KPM', 'APM', 'SPM', 'CPM', 'RPM']
      ];

      Array.from(playerStats.values())
        .sort((a, b) => b.totalKills - a.totalKills)
        .forEach(player => {
          const kpm = player.totalTime > 0 ? (player.totalKills / player.totalTime).toFixed(2) : '0.00';
          const apm = player.totalTime > 0 ? (player.totalAssists / player.totalTime).toFixed(2) : '0.00';
          const spm = player.totalTime > 0 ? (player.totalScore / player.totalTime).toFixed(2) : '0.00';
          const cpm = player.totalTime > 0 ? (player.totalCaptures / player.totalTime).toFixed(2) : '0.00';
          const rpm = player.totalTime > 0 ? (player.totalReturns / player.totalTime).toFixed(2) : '0.00';

          data.push([
            player.name,
            Array.from(player.teams).join(', '),
            player.matches,
            player.totalKills,
            player.totalAssists,
            player.totalScore,
            player.totalCaptures,
            player.totalReturns,
            player.totalTime.toFixed(2),
            kpm,
            apm,
            spm,
            cpm,
            rpm
          ]);
        });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, 'Player Stats');
    }

    function createTeamStatsSheet(wb, allMatches) {
      const teamStats = new Map();

      // Aggregate all team data
      allMatches.forEach(match => {
        const stats = match.stats || {};
        Object.entries(stats).forEach(([teamName, teamData]) => {
          if (!teamStats.has(teamName)) {
            teamStats.set(teamName, {
              name: teamName,
              matches: 0,
              totalKills: 0,
              totalAssists: 0,
              totalScore: 0,
              totalCaptures: 0,
              totalReturns: 0,
              totalTime: 0,
              players: new Set()
            });
          }
          
          const team = teamStats.get(teamName);
          const totals = teamData.totals || {};
          const players = teamData.players || {};
          
          team.matches += 1;
          team.totalKills += toNumber(totals.kills);
          team.totalAssists += toNumber(totals.assists);
          team.totalScore += toNumber(totals.score);
          team.totalCaptures += toNumber(totals.captures);
          team.totalReturns += toNumber(totals.returns);
          team.totalTime += toNumber(totals.time);
          
          Object.keys(players).forEach(player => team.players.add(player));
        });
      });

      const data = [
        ['Team Name', 'Matches', 'Unique Players', 'Total Kills', 'Total Assists', 'Total Score', 'Total Captures', 'Total Returns', 'Total Time (min)', 'KPM', 'APM', 'SPM', 'CPM', 'RPM']
      ];

      Array.from(teamStats.values())
        .sort((a, b) => b.totalKills - a.totalKills)
        .forEach(team => {
          const kpm = team.totalTime > 0 ? (team.totalKills / team.totalTime).toFixed(2) : '0.00';
          const apm = team.totalTime > 0 ? (team.totalAssists / team.totalTime).toFixed(2) : '0.00';
          const spm = team.totalTime > 0 ? (team.totalScore / team.totalTime).toFixed(2) : '0.00';
          const cpm = team.totalTime > 0 ? (team.totalCaptures / team.totalTime).toFixed(2) : '0.00';
          const rpm = team.totalTime > 0 ? (team.totalReturns / team.totalTime).toFixed(2) : '0.00';

          data.push([
            team.name,
            team.matches,
            team.players.size,
            team.totalKills,
            team.totalAssists,
            team.totalScore,
            team.totalCaptures,
            team.totalReturns,
            team.totalTime.toFixed(2),
            kpm,
            apm,
            spm,
            cpm,
            rpm
          ]);
        });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, 'Team Stats');
    }

    function createPerMinuteStatsSheet(wb, allMatches) {
      const data = [
        ['Player Name', 'Team', 'Match Date', 'Map', 'KPM', 'APM', 'SPM', 'CPM', 'RPM', 'Time (min)', 'Kills', 'Assists', 'Score', 'Captures', 'Returns']
      ];

      allMatches.forEach(match => {
        const date = match.created?.toDate ? match.created.toDate().toLocaleDateString() : 'Unknown';
        const stats = match.stats || {};
        
        Object.entries(stats).forEach(([teamName, teamData]) => {
          const players = teamData.players || {};
          Object.entries(players).forEach(([playerName, playerData]) => {
            const time = toNumber(playerData.time);
            const kpm = time > 0 ? (toNumber(playerData.kills) / time).toFixed(2) : '0.00';
            const apm = time > 0 ? (toNumber(playerData.assists) / time).toFixed(2) : '0.00';
            const spm = time > 0 ? (toNumber(playerData.score) / time).toFixed(2) : '0.00';
            const cpm = time > 0 ? (toNumber(playerData.captures) / time).toFixed(2) : '0.00';
            const rpm = time > 0 ? (toNumber(playerData.returns) / time).toFixed(2) : '0.00';

            data.push([
              playerName,
              teamName,
              date,
              match.map || 'Unknown',
              kpm,
              apm,
              spm,
              cpm,
              rpm,
              time.toFixed(2),
              toNumber(playerData.kills),
              toNumber(playerData.assists),
              toNumber(playerData.score),
              toNumber(playerData.captures),
              toNumber(playerData.returns)
            ]);
          });
        });
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, 'Per-Minute Stats');
    }

    function createMapStatsSheet(wb, allMatches) {
      const mapStats = new Map();

      // Aggregate map data
      allMatches.forEach(match => {
        const mapName = match.map || 'Unknown';
        if (!mapStats.has(mapName)) {
          mapStats.set(mapName, {
            name: mapName,
            matches: 0,
            totalKills: 0,
            totalAssists: 0,
            totalScore: 0,
            totalCaptures: 0,
            totalReturns: 0,
            totalTime: 0,
            teams: new Set(),
            players: new Set()
          });
        }
        
        const map = mapStats.get(mapName);
        map.matches += 1;
        
        const stats = match.stats || {};
        Object.entries(stats).forEach(([teamName, teamData]) => {
          map.teams.add(teamName);
          const totals = teamData.totals || {};
          const players = teamData.players || {};
          
          map.totalKills += toNumber(totals.kills);
          map.totalAssists += toNumber(totals.assists);
          map.totalScore += toNumber(totals.score);
          map.totalCaptures += toNumber(totals.captures);
          map.totalReturns += toNumber(totals.returns);
          map.totalTime += toNumber(totals.time);
          
          Object.keys(players).forEach(player => map.players.add(player));
        });
      });

      const data = [
        ['Map Name', 'Matches', 'Unique Teams', 'Unique Players', 'Total Kills', 'Total Assists', 'Total Score', 'Total Captures', 'Total Returns', 'Total Time (min)', 'Avg KPM', 'Avg APM', 'Avg SPM']
      ];

      Array.from(mapStats.values())
        .sort((a, b) => b.matches - a.matches)
        .forEach(map => {
          const avgKpm = map.totalTime > 0 ? (map.totalKills / map.totalTime).toFixed(2) : '0.00';
          const avgApm = map.totalTime > 0 ? (map.totalAssists / map.totalTime).toFixed(2) : '0.00';
          const avgSpm = map.totalTime > 0 ? (map.totalScore / map.totalTime).toFixed(2) : '0.00';

          data.push([
            map.name,
            map.matches,
            map.teams.size,
            map.players.size,
            map.totalKills,
            map.totalAssists,
            map.totalScore,
            map.totalCaptures,
            map.totalReturns,
            map.totalTime.toFixed(2),
            avgKpm,
            avgApm,
            avgSpm
          ]);
        });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, 'Map Performance');
    }

    function createMatchDetailsSheet(wb, allMatches) {
      const data = [
        ['Match ID', 'Date', 'Map', 'Team 1', 'Team 2', 'Player', 'Team', 'Kills', 'Assists', 'Score', 'Captures', 'Returns', 'Time (min)', 'KPM', 'APM', 'SPM', 'CPM', 'RPM']
      ];

      allMatches.forEach(match => {
        const date = match.created?.toDate ? match.created.toDate().toLocaleString() : 'Unknown';
        const stats = match.stats || {};
        
        Object.entries(stats).forEach(([teamName, teamData]) => {
          const players = teamData.players || {};
          Object.entries(players).forEach(([playerName, playerData]) => {
            const time = toNumber(playerData.time);
            const kpm = time > 0 ? (toNumber(playerData.kills) / time).toFixed(2) : '0.00';
            const apm = time > 0 ? (toNumber(playerData.assists) / time).toFixed(2) : '0.00';
            const spm = time > 0 ? (toNumber(playerData.score) / time).toFixed(2) : '0.00';
            const cpm = time > 0 ? (toNumber(playerData.captures) / time).toFixed(2) : '0.00';
            const rpm = time > 0 ? (toNumber(playerData.returns) / time).toFixed(2) : '0.00';

            data.push([
              match.id,
              date,
              match.map || 'Unknown',
              match.team1 || 'Unknown',
              match.team2 || 'Unknown',
              playerName,
              teamName,
              toNumber(playerData.kills),
              toNumber(playerData.assists),
              toNumber(playerData.score),
              toNumber(playerData.captures),
              toNumber(playerData.returns),
              time.toFixed(2),
              kpm,
              apm,
              spm,
              cpm,
              rpm
            ]);
          });
        });
      });

      const ws = XLSX.utils.aoa_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, 'Match Details');
    }

    document.getElementById('exportBtn').addEventListener('click', async () => {
      try {
        // Show loading state
        const exportBtn = document.getElementById('exportBtn');
        const originalText = exportBtn.textContent;
        exportBtn.textContent = 'Exporting...';
        exportBtn.disabled = true;

        // Get all matches data
        const matchesSnapshot = await getDocs(collection(db, 'matches'));
        const allMatches = [];
        matchesSnapshot.forEach(doc => {
          allMatches.push({ id: doc.id, ...doc.data() });
        });

        // Sort matches by date (newest first)
        allMatches.sort((a, b) => {
          const aTime = a.created?.toDate ? a.created.toDate().getTime() : new Date(a.created || 0).getTime();
          const bTime = b.created?.toDate ? b.created.toDate().getTime() : new Date(b.created || 0).getTime();
          return bTime - aTime;
        });

        // Create comprehensive Excel workbook
        const wb = XLSX.utils.book_new();

        // Sheet 1: All Matches Summary
        createAllMatchesSheet(wb, allMatches);

        // Sheet 2: Individual Player Stats
        createPlayerStatsSheet(wb, allMatches);

        // Sheet 3: Team Performance
        createTeamStatsSheet(wb, allMatches);

        // Sheet 4: Per-Minute Statistics
        createPerMinuteStatsSheet(wb, allMatches);

        // Sheet 5: Map Performance
        createMapStatsSheet(wb, allMatches);

        // Sheet 6: Match Details (Raw Data)
        createMatchDetailsSheet(wb, allMatches);

        // Generate filename with timestamp
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `tribes-league-stats-${timestamp}.xlsx`;

        // Export the workbook
        XLSX.writeFile(wb, filename);

        // Reset button
        exportBtn.textContent = originalText;
        exportBtn.disabled = false;

        alert(`Comprehensive stats exported successfully as ${filename}`);
      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed. Please try again.');
        
        // Reset button
        const exportBtn = document.getElementById('exportBtn');
        exportBtn.textContent = 'Export All Data to Excel';
        exportBtn.disabled = false;
      }
    });
  </script>
  <script src="./assets/include.js" defer></script>
</body>
</html>
